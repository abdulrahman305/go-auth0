// Code generated by Fern. DO NOT EDIT.

package management

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/auth0/go-auth0/v2/management/internal"
)

type CreateNetworkACLRequestContent struct {
	Description string `json:"description" url:"-"`
	// Indicates whether or not this access control list is actively being used
	Active bool `json:"active" url:"-"`
	// Indicates the order in which the ACL will be evaluated relative to other ACL rules.
	Priority float64         `json:"priority" url:"-"`
	Rule     *NetworkACLRule `json:"rule,omitempty" url:"-"`
}

type ListNetworkACLsRequestParameters struct {
	// Use this field to request a specific page of the list results.
	Page *int `json:"-" url:"page,omitempty"`
	// The amount of results per page.
	PerPage *int `json:"-" url:"per_page,omitempty"`
	// Return results inside an object that contains the total result count (true) or as a direct array of results (false, default).
	IncludeTotals *bool `json:"-" url:"include_totals,omitempty"`
}

type SetNetworkACLRequestContent struct {
	Description string `json:"description" url:"-"`
	// Indicates whether or not this access control list is actively being used
	Active bool `json:"active" url:"-"`
	// Indicates the order in which the ACL will be evaluated relative to other ACL rules.
	Priority float64         `json:"priority" url:"-"`
	Rule     *NetworkACLRule `json:"rule,omitempty" url:"-"`
}

type GetNetworkACLsResponseContent struct {
	ID          *string         `json:"id,omitempty" url:"id,omitempty"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Active      *bool           `json:"active,omitempty" url:"active,omitempty"`
	Priority    *float64        `json:"priority,omitempty" url:"priority,omitempty"`
	Rule        *NetworkACLRule `json:"rule,omitempty" url:"rule,omitempty"`
	// The timestamp when the Network ACL Configuration was created
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the Network ACL Configuration was last updated
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (g *GetNetworkACLsResponseContent) GetID() *string {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *GetNetworkACLsResponseContent) GetDescription() *string {
	if g == nil {
		return nil
	}
	return g.Description
}

func (g *GetNetworkACLsResponseContent) GetActive() *bool {
	if g == nil {
		return nil
	}
	return g.Active
}

func (g *GetNetworkACLsResponseContent) GetPriority() *float64 {
	if g == nil {
		return nil
	}
	return g.Priority
}

func (g *GetNetworkACLsResponseContent) GetRule() *NetworkACLRule {
	if g == nil {
		return nil
	}
	return g.Rule
}

func (g *GetNetworkACLsResponseContent) GetCreatedAt() *string {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *GetNetworkACLsResponseContent) GetUpdatedAt() *string {
	if g == nil {
		return nil
	}
	return g.UpdatedAt
}

func (g *GetNetworkACLsResponseContent) GetExtraProperties() map[string]interface{} {
	return g.ExtraProperties
}

func (g *GetNetworkACLsResponseContent) UnmarshalJSON(data []byte) error {
	type embed GetNetworkACLsResponseContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GetNetworkACLsResponseContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.ExtraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetNetworkACLsResponseContent) MarshalJSON() ([]byte, error) {
	type embed GetNetworkACLsResponseContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, g.ExtraProperties)
}

func (g *GetNetworkACLsResponseContent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListNetworkACLsOffsetPaginatedResponseContent struct {
	NetworkACLs []*NetworkACLsResponseContent `json:"network_acls,omitempty" url:"network_acls,omitempty"`
	Start       *float64                      `json:"start,omitempty" url:"start,omitempty"`
	Limit       *float64                      `json:"limit,omitempty" url:"limit,omitempty"`
	Total       *float64                      `json:"total,omitempty" url:"total,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListNetworkACLsOffsetPaginatedResponseContent) GetNetworkACLs() []*NetworkACLsResponseContent {
	if l == nil {
		return nil
	}
	return l.NetworkACLs
}

func (l *ListNetworkACLsOffsetPaginatedResponseContent) GetStart() *float64 {
	if l == nil {
		return nil
	}
	return l.Start
}

func (l *ListNetworkACLsOffsetPaginatedResponseContent) GetLimit() *float64 {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListNetworkACLsOffsetPaginatedResponseContent) GetTotal() *float64 {
	if l == nil {
		return nil
	}
	return l.Total
}

func (l *ListNetworkACLsOffsetPaginatedResponseContent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListNetworkACLsOffsetPaginatedResponseContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ListNetworkACLsOffsetPaginatedResponseContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListNetworkACLsOffsetPaginatedResponseContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListNetworkACLsOffsetPaginatedResponseContent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type NetworkACLAction struct {
	Block    *NetworkACLActionBlockEnum    `json:"block,omitempty" url:"block,omitempty"`
	Allow    *NetworkACLActionAllowEnum    `json:"allow,omitempty" url:"allow,omitempty"`
	Log      *NetworkACLActionLogEnum      `json:"log,omitempty" url:"log,omitempty"`
	Redirect *NetworkACLActionRedirectEnum `json:"redirect,omitempty" url:"redirect,omitempty"`
	// The URI to which the match or not_match requests will be routed
	RedirectURI *string `json:"redirect_uri,omitempty" url:"redirect_uri,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NetworkACLAction) GetBlock() *NetworkACLActionBlockEnum {
	if n == nil {
		return nil
	}
	return n.Block
}

func (n *NetworkACLAction) GetAllow() *NetworkACLActionAllowEnum {
	if n == nil {
		return nil
	}
	return n.Allow
}

func (n *NetworkACLAction) GetLog() *NetworkACLActionLogEnum {
	if n == nil {
		return nil
	}
	return n.Log
}

func (n *NetworkACLAction) GetRedirect() *NetworkACLActionRedirectEnum {
	if n == nil {
		return nil
	}
	return n.Redirect
}

func (n *NetworkACLAction) GetRedirectURI() *string {
	if n == nil {
		return nil
	}
	return n.RedirectURI
}

func (n *NetworkACLAction) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkACLAction) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkACLAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkACLAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NetworkACLAction) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Indicates the rule will allow requests that either match or not_match specific criteria
type NetworkACLActionAllowEnum = bool

// Indicates the rule will block requests that either match or not_match specific criteria
type NetworkACLActionBlockEnum = bool

// Indicates the rule will log requests that either match or not_match specific criteria
type NetworkACLActionLogEnum = bool

// Indicates the rule will redirect requests that either match or not_match specific criteria
type NetworkACLActionRedirectEnum = bool

type NetworkACLMatch struct {
	Asns                []int                     `json:"asns,omitempty" url:"asns,omitempty"`
	GeoCountryCodes     []string                  `json:"geo_country_codes,omitempty" url:"geo_country_codes,omitempty"`
	GeoSubdivisionCodes []string                  `json:"geo_subdivision_codes,omitempty" url:"geo_subdivision_codes,omitempty"`
	Ipv4Cidrs           []NetworkACLMatchIpv4Cidr `json:"ipv4_cidrs,omitempty" url:"ipv4_cidrs,omitempty"`
	Ipv6Cidrs           []NetworkACLMatchIpv6Cidr `json:"ipv6_cidrs,omitempty" url:"ipv6_cidrs,omitempty"`
	Ja3Fingerprints     []string                  `json:"ja3_fingerprints,omitempty" url:"ja3_fingerprints,omitempty"`
	Ja4Fingerprints     []string                  `json:"ja4_fingerprints,omitempty" url:"ja4_fingerprints,omitempty"`
	UserAgents          []string                  `json:"user_agents,omitempty" url:"user_agents,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NetworkACLMatch) GetAsns() []int {
	if n == nil {
		return nil
	}
	return n.Asns
}

func (n *NetworkACLMatch) GetGeoCountryCodes() []string {
	if n == nil {
		return nil
	}
	return n.GeoCountryCodes
}

func (n *NetworkACLMatch) GetGeoSubdivisionCodes() []string {
	if n == nil {
		return nil
	}
	return n.GeoSubdivisionCodes
}

func (n *NetworkACLMatch) GetIpv4Cidrs() []NetworkACLMatchIpv4Cidr {
	if n == nil {
		return nil
	}
	return n.Ipv4Cidrs
}

func (n *NetworkACLMatch) GetIpv6Cidrs() []NetworkACLMatchIpv6Cidr {
	if n == nil {
		return nil
	}
	return n.Ipv6Cidrs
}

func (n *NetworkACLMatch) GetJa3Fingerprints() []string {
	if n == nil {
		return nil
	}
	return n.Ja3Fingerprints
}

func (n *NetworkACLMatch) GetJa4Fingerprints() []string {
	if n == nil {
		return nil
	}
	return n.Ja4Fingerprints
}

func (n *NetworkACLMatch) GetUserAgents() []string {
	if n == nil {
		return nil
	}
	return n.UserAgents
}

func (n *NetworkACLMatch) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkACLMatch) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkACLMatch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkACLMatch(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NetworkACLMatch) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NetworkACLMatchIpv4Cidr = string

type NetworkACLMatchIpv6Cidr = string

type NetworkACLRule struct {
	Action   *NetworkACLAction       `json:"action" url:"action"`
	Match    *NetworkACLMatch        `json:"match,omitempty" url:"match,omitempty"`
	NotMatch *NetworkACLMatch        `json:"not_match,omitempty" url:"not_match,omitempty"`
	Scope    NetworkACLRuleScopeEnum `json:"scope" url:"scope"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NetworkACLRule) GetAction() *NetworkACLAction {
	if n == nil {
		return nil
	}
	return n.Action
}

func (n *NetworkACLRule) GetMatch() *NetworkACLMatch {
	if n == nil {
		return nil
	}
	return n.Match
}

func (n *NetworkACLRule) GetNotMatch() *NetworkACLMatch {
	if n == nil {
		return nil
	}
	return n.NotMatch
}

func (n *NetworkACLRule) GetScope() NetworkACLRuleScopeEnum {
	if n == nil {
		return ""
	}
	return n.Scope
}

func (n *NetworkACLRule) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkACLRule) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkACLRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkACLRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NetworkACLRule) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Identifies the origin of the request as the Management API (management), Authentication API (authentication), or either (tenant)
type NetworkACLRuleScopeEnum string

const (
	NetworkACLRuleScopeEnumManagement     NetworkACLRuleScopeEnum = "management"
	NetworkACLRuleScopeEnumAuthentication NetworkACLRuleScopeEnum = "authentication"
	NetworkACLRuleScopeEnumTenant         NetworkACLRuleScopeEnum = "tenant"
)

func NewNetworkACLRuleScopeEnumFromString(s string) (NetworkACLRuleScopeEnum, error) {
	switch s {
	case "management":
		return NetworkACLRuleScopeEnumManagement, nil
	case "authentication":
		return NetworkACLRuleScopeEnumAuthentication, nil
	case "tenant":
		return NetworkACLRuleScopeEnumTenant, nil
	}
	var t NetworkACLRuleScopeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NetworkACLRuleScopeEnum) Ptr() *NetworkACLRuleScopeEnum {
	return &n
}

type NetworkACLsResponseContent struct {
	ID          *string         `json:"id,omitempty" url:"id,omitempty"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Active      *bool           `json:"active,omitempty" url:"active,omitempty"`
	Priority    *float64        `json:"priority,omitempty" url:"priority,omitempty"`
	Rule        *NetworkACLRule `json:"rule,omitempty" url:"rule,omitempty"`
	// The timestamp when the Network ACL Configuration was created
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the Network ACL Configuration was last updated
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (n *NetworkACLsResponseContent) GetID() *string {
	if n == nil {
		return nil
	}
	return n.ID
}

func (n *NetworkACLsResponseContent) GetDescription() *string {
	if n == nil {
		return nil
	}
	return n.Description
}

func (n *NetworkACLsResponseContent) GetActive() *bool {
	if n == nil {
		return nil
	}
	return n.Active
}

func (n *NetworkACLsResponseContent) GetPriority() *float64 {
	if n == nil {
		return nil
	}
	return n.Priority
}

func (n *NetworkACLsResponseContent) GetRule() *NetworkACLRule {
	if n == nil {
		return nil
	}
	return n.Rule
}

func (n *NetworkACLsResponseContent) GetCreatedAt() *string {
	if n == nil {
		return nil
	}
	return n.CreatedAt
}

func (n *NetworkACLsResponseContent) GetUpdatedAt() *string {
	if n == nil {
		return nil
	}
	return n.UpdatedAt
}

func (n *NetworkACLsResponseContent) GetExtraProperties() map[string]interface{} {
	return n.ExtraProperties
}

func (n *NetworkACLsResponseContent) UnmarshalJSON(data []byte) error {
	type embed NetworkACLsResponseContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NetworkACLsResponseContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.ExtraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NetworkACLsResponseContent) MarshalJSON() ([]byte, error) {
	type embed NetworkACLsResponseContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, n.ExtraProperties)
}

func (n *NetworkACLsResponseContent) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type SetNetworkACLsResponseContent struct {
	ID          *string         `json:"id,omitempty" url:"id,omitempty"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Active      *bool           `json:"active,omitempty" url:"active,omitempty"`
	Priority    *float64        `json:"priority,omitempty" url:"priority,omitempty"`
	Rule        *NetworkACLRule `json:"rule,omitempty" url:"rule,omitempty"`
	// The timestamp when the Network ACL Configuration was created
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the Network ACL Configuration was last updated
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (s *SetNetworkACLsResponseContent) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *SetNetworkACLsResponseContent) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SetNetworkACLsResponseContent) GetActive() *bool {
	if s == nil {
		return nil
	}
	return s.Active
}

func (s *SetNetworkACLsResponseContent) GetPriority() *float64 {
	if s == nil {
		return nil
	}
	return s.Priority
}

func (s *SetNetworkACLsResponseContent) GetRule() *NetworkACLRule {
	if s == nil {
		return nil
	}
	return s.Rule
}

func (s *SetNetworkACLsResponseContent) GetCreatedAt() *string {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *SetNetworkACLsResponseContent) GetUpdatedAt() *string {
	if s == nil {
		return nil
	}
	return s.UpdatedAt
}

func (s *SetNetworkACLsResponseContent) GetExtraProperties() map[string]interface{} {
	return s.ExtraProperties
}

func (s *SetNetworkACLsResponseContent) UnmarshalJSON(data []byte) error {
	type embed SetNetworkACLsResponseContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SetNetworkACLsResponseContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.ExtraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SetNetworkACLsResponseContent) MarshalJSON() ([]byte, error) {
	type embed SetNetworkACLsResponseContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, s.ExtraProperties)
}

func (s *SetNetworkACLsResponseContent) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type UpdateNetworkACLResponseContent struct {
	ID          *string         `json:"id,omitempty" url:"id,omitempty"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Active      *bool           `json:"active,omitempty" url:"active,omitempty"`
	Priority    *float64        `json:"priority,omitempty" url:"priority,omitempty"`
	Rule        *NetworkACLRule `json:"rule,omitempty" url:"rule,omitempty"`
	// The timestamp when the Network ACL Configuration was created
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the Network ACL Configuration was last updated
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (u *UpdateNetworkACLResponseContent) GetID() *string {
	if u == nil {
		return nil
	}
	return u.ID
}

func (u *UpdateNetworkACLResponseContent) GetDescription() *string {
	if u == nil {
		return nil
	}
	return u.Description
}

func (u *UpdateNetworkACLResponseContent) GetActive() *bool {
	if u == nil {
		return nil
	}
	return u.Active
}

func (u *UpdateNetworkACLResponseContent) GetPriority() *float64 {
	if u == nil {
		return nil
	}
	return u.Priority
}

func (u *UpdateNetworkACLResponseContent) GetRule() *NetworkACLRule {
	if u == nil {
		return nil
	}
	return u.Rule
}

func (u *UpdateNetworkACLResponseContent) GetCreatedAt() *string {
	if u == nil {
		return nil
	}
	return u.CreatedAt
}

func (u *UpdateNetworkACLResponseContent) GetUpdatedAt() *string {
	if u == nil {
		return nil
	}
	return u.UpdatedAt
}

func (u *UpdateNetworkACLResponseContent) GetExtraProperties() map[string]interface{} {
	return u.ExtraProperties
}

func (u *UpdateNetworkACLResponseContent) UnmarshalJSON(data []byte) error {
	type embed UpdateNetworkACLResponseContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateNetworkACLResponseContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.ExtraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateNetworkACLResponseContent) MarshalJSON() ([]byte, error) {
	type embed UpdateNetworkACLResponseContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, u.ExtraProperties)
}

func (u *UpdateNetworkACLResponseContent) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateNetworkACLRequestContent struct {
	Description *string `json:"description,omitempty" url:"-"`
	// Indicates whether or not this access control list is actively being used
	Active *bool `json:"active,omitempty" url:"-"`
	// Indicates the order in which the ACL will be evaluated relative to other ACL rules.
	Priority *float64        `json:"priority,omitempty" url:"-"`
	Rule     *NetworkACLRule `json:"rule,omitempty" url:"-"`
}
