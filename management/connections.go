// Code generated by Fern. DO NOT EDIT.

package management

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/auth0/go-auth0/v2/management/internal"
)

type CreateConnectionRequestContent struct {
	// The name of the connection. Must start and end with an alphanumeric character and can only contain alphanumeric characters and '-'. Max length 128
	Name string `json:"name" url:"-"`
	// Connection name used in the new universal login experience
	DisplayName *string                        `json:"display_name,omitempty" url:"-"`
	Strategy    ConnectionIdentityProviderEnum `json:"strategy" url:"-"`
	Options     *ConnectionPropertiesOptions   `json:"options,omitempty" url:"-"`
	// DEPRECATED property. Use the PATCH /v2/connections/{id}/clients endpoint to enable the connection for a set of clients.
	EnabledClients []string `json:"enabled_clients,omitempty" url:"-"`
	// <code>true</code> promotes to a domain-level connection so that third-party applications can use it. <code>false</code> does not promote the connection, so only first-party applications with the connection enabled can use it. (Defaults to <code>false</code>.)
	IsDomainConnection *bool `json:"is_domain_connection,omitempty" url:"-"`
	// Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD. (Defaults to <code>false</code>.)
	ShowAsButton *bool `json:"show_as_button,omitempty" url:"-"`
	// Defines the realms for which the connection will be used (ie: email domains). If the array is empty or the property is not specified, the connection name will be added as realm.
	Realms   []string             `json:"realms,omitempty" url:"-"`
	Metadata *ConnectionsMetadata `json:"metadata,omitempty" url:"-"`
}

type GetConnectionRequestParameters struct {
	// A comma separated list of fields to include or exclude (depending on include_fields) from the result, empty to retrieve all fields
	Fields *string `json:"-" url:"fields,omitempty"`
	// <code>true</code> if the fields specified are to be included in the result, <code>false</code> otherwise (defaults to <code>true</code>)
	IncludeFields *bool `json:"-" url:"include_fields,omitempty"`
}

type ListConnectionsQueryParameters struct {
	// Optional Id from which to start selection.
	From *string `json:"-" url:"from,omitempty"`
	// Number of results per page. Defaults to 50.
	Take *int `json:"-" url:"take,omitempty"`
	// Provide strategies to only retrieve connections with such strategies
	Strategy []*ConnectionStrategyEnum `json:"-" url:"strategy,omitempty"`
	// Provide the name of the connection to retrieve
	Name *string `json:"-" url:"name,omitempty"`
	// A comma separated list of fields to include or exclude (depending on include_fields) from the result, empty to retrieve all fields
	Fields *string `json:"-" url:"fields,omitempty"`
	// <code>true</code> if the fields specified are to be included in the result, <code>false</code> otherwise (defaults to <code>true</code>)
	IncludeFields *bool `json:"-" url:"include_fields,omitempty"`
}

type ConnectionAttributeIdentifier struct {
	// Determines if the attribute is used for identification
	Active *bool `json:"active,omitempty" url:"active,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionAttributeIdentifier) GetActive() *bool {
	if c == nil {
		return nil
	}
	return c.Active
}

func (c *ConnectionAttributeIdentifier) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionAttributeIdentifier) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionAttributeIdentifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionAttributeIdentifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionAttributeIdentifier) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Attribute configuration
type ConnectionAttributes struct {
	Email       *EmailAttribute    `json:"email,omitempty" url:"email,omitempty"`
	PhoneNumber *PhoneAttribute    `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	Username    *UsernameAttribute `json:"username,omitempty" url:"username,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionAttributes) GetEmail() *EmailAttribute {
	if c == nil {
		return nil
	}
	return c.Email
}

func (c *ConnectionAttributes) GetPhoneNumber() *PhoneAttribute {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ConnectionAttributes) GetUsername() *UsernameAttribute {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *ConnectionAttributes) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionAttributes) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionAttributes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionAttributes(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionAttributes) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Options for enabling authentication methods.
type ConnectionAuthenticationMethods struct {
	Password *ConnectionPasswordAuthenticationMethod `json:"password,omitempty" url:"password,omitempty"`
	Passkey  *ConnectionPasskeyAuthenticationMethod  `json:"passkey,omitempty" url:"passkey,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionAuthenticationMethods) GetPassword() *ConnectionPasswordAuthenticationMethod {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *ConnectionAuthenticationMethods) GetPasskey() *ConnectionPasskeyAuthenticationMethod {
	if c == nil {
		return nil
	}
	return c.Passkey
}

func (c *ConnectionAuthenticationMethods) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionAuthenticationMethods) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionAuthenticationMethods
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionAuthenticationMethods(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionAuthenticationMethods) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A map of scripts used to integrate with a custom database.
type ConnectionCustomScripts struct {
	Login             *string `json:"login,omitempty" url:"login,omitempty"`
	GetUser           *string `json:"get_user,omitempty" url:"get_user,omitempty"`
	Delete            *string `json:"delete,omitempty" url:"delete,omitempty"`
	ChangePassword    *string `json:"change_password,omitempty" url:"change_password,omitempty"`
	Verify            *string `json:"verify,omitempty" url:"verify,omitempty"`
	Create            *string `json:"create,omitempty" url:"create,omitempty"`
	ChangeUsername    *string `json:"change_username,omitempty" url:"change_username,omitempty"`
	ChangeEmail       *string `json:"change_email,omitempty" url:"change_email,omitempty"`
	ChangePhoneNumber *string `json:"change_phone_number,omitempty" url:"change_phone_number,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ConnectionCustomScripts) GetLogin() *string {
	if c == nil {
		return nil
	}
	return c.Login
}

func (c *ConnectionCustomScripts) GetGetUser() *string {
	if c == nil {
		return nil
	}
	return c.GetUser
}

func (c *ConnectionCustomScripts) GetDelete() *string {
	if c == nil {
		return nil
	}
	return c.Delete
}

func (c *ConnectionCustomScripts) GetChangePassword() *string {
	if c == nil {
		return nil
	}
	return c.ChangePassword
}

func (c *ConnectionCustomScripts) GetVerify() *string {
	if c == nil {
		return nil
	}
	return c.Verify
}

func (c *ConnectionCustomScripts) GetCreate() *string {
	if c == nil {
		return nil
	}
	return c.Create
}

func (c *ConnectionCustomScripts) GetChangeUsername() *string {
	if c == nil {
		return nil
	}
	return c.ChangeUsername
}

func (c *ConnectionCustomScripts) GetChangeEmail() *string {
	if c == nil {
		return nil
	}
	return c.ChangeEmail
}

func (c *ConnectionCustomScripts) GetChangePhoneNumber() *string {
	if c == nil {
		return nil
	}
	return c.ChangePhoneNumber
}

func (c *ConnectionCustomScripts) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ConnectionCustomScripts) UnmarshalJSON(data []byte) error {
	type embed ConnectionCustomScripts
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConnectionCustomScripts(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionCustomScripts) MarshalJSON() ([]byte, error) {
	type embed ConnectionCustomScripts
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ConnectionCustomScripts) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Token-based authentication settings to be applied when connection is using an sms strategy.
type ConnectionGatewayAuthentication struct {
	// The Authorization header type.
	Method string `json:"method" url:"method"`
	// The subject to be added to the JWT payload.
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The audience to be added to the JWT payload.
	Audience string `json:"audience" url:"audience"`
	// The secret to be used for signing tokens.
	Secret string `json:"secret" url:"secret"`
	// Set to true if the provided secret is base64 encoded.
	SecretBase64Encoded *bool `json:"secret_base64_encoded,omitempty" url:"secret_base64_encoded,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ConnectionGatewayAuthentication) GetMethod() string {
	if c == nil {
		return ""
	}
	return c.Method
}

func (c *ConnectionGatewayAuthentication) GetSubject() *string {
	if c == nil {
		return nil
	}
	return c.Subject
}

func (c *ConnectionGatewayAuthentication) GetAudience() string {
	if c == nil {
		return ""
	}
	return c.Audience
}

func (c *ConnectionGatewayAuthentication) GetSecret() string {
	if c == nil {
		return ""
	}
	return c.Secret
}

func (c *ConnectionGatewayAuthentication) GetSecretBase64Encoded() *bool {
	if c == nil {
		return nil
	}
	return c.SecretBase64Encoded
}

func (c *ConnectionGatewayAuthentication) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ConnectionGatewayAuthentication) UnmarshalJSON(data []byte) error {
	type embed ConnectionGatewayAuthentication
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConnectionGatewayAuthentication(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionGatewayAuthentication) MarshalJSON() ([]byte, error) {
	type embed ConnectionGatewayAuthentication
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ConnectionGatewayAuthentication) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Order of precedence for attribute types
type ConnectionIdentifierPrecedenceEnum string

const (
	ConnectionIdentifierPrecedenceEnumEmail       ConnectionIdentifierPrecedenceEnum = "email"
	ConnectionIdentifierPrecedenceEnumPhoneNumber ConnectionIdentifierPrecedenceEnum = "phone_number"
	ConnectionIdentifierPrecedenceEnumUsername    ConnectionIdentifierPrecedenceEnum = "username"
)

func NewConnectionIdentifierPrecedenceEnumFromString(s string) (ConnectionIdentifierPrecedenceEnum, error) {
	switch s {
	case "email":
		return ConnectionIdentifierPrecedenceEnumEmail, nil
	case "phone_number":
		return ConnectionIdentifierPrecedenceEnumPhoneNumber, nil
	case "username":
		return ConnectionIdentifierPrecedenceEnumUsername, nil
	}
	var t ConnectionIdentifierPrecedenceEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionIdentifierPrecedenceEnum) Ptr() *ConnectionIdentifierPrecedenceEnum {
	return &c
}

// The identity provider identifier for the connection
type ConnectionIdentityProviderEnum string

const (
	ConnectionIdentityProviderEnumAd                  ConnectionIdentityProviderEnum = "ad"
	ConnectionIdentityProviderEnumAdfs                ConnectionIdentityProviderEnum = "adfs"
	ConnectionIdentityProviderEnumAmazon              ConnectionIdentityProviderEnum = "amazon"
	ConnectionIdentityProviderEnumApple               ConnectionIdentityProviderEnum = "apple"
	ConnectionIdentityProviderEnumDropbox             ConnectionIdentityProviderEnum = "dropbox"
	ConnectionIdentityProviderEnumBitbucket           ConnectionIdentityProviderEnum = "bitbucket"
	ConnectionIdentityProviderEnumAol                 ConnectionIdentityProviderEnum = "aol"
	ConnectionIdentityProviderEnumAuth0Oidc           ConnectionIdentityProviderEnum = "auth0-oidc"
	ConnectionIdentityProviderEnumAuth0               ConnectionIdentityProviderEnum = "auth0"
	ConnectionIdentityProviderEnumBaidu               ConnectionIdentityProviderEnum = "baidu"
	ConnectionIdentityProviderEnumBitly               ConnectionIdentityProviderEnum = "bitly"
	ConnectionIdentityProviderEnumBox                 ConnectionIdentityProviderEnum = "box"
	ConnectionIdentityProviderEnumCustom              ConnectionIdentityProviderEnum = "custom"
	ConnectionIdentityProviderEnumDaccount            ConnectionIdentityProviderEnum = "daccount"
	ConnectionIdentityProviderEnumDwolla              ConnectionIdentityProviderEnum = "dwolla"
	ConnectionIdentityProviderEnumEmail               ConnectionIdentityProviderEnum = "email"
	ConnectionIdentityProviderEnumEvernoteSandbox     ConnectionIdentityProviderEnum = "evernote-sandbox"
	ConnectionIdentityProviderEnumEvernote            ConnectionIdentityProviderEnum = "evernote"
	ConnectionIdentityProviderEnumExact               ConnectionIdentityProviderEnum = "exact"
	ConnectionIdentityProviderEnumFacebook            ConnectionIdentityProviderEnum = "facebook"
	ConnectionIdentityProviderEnumFitbit              ConnectionIdentityProviderEnum = "fitbit"
	ConnectionIdentityProviderEnumFlickr              ConnectionIdentityProviderEnum = "flickr"
	ConnectionIdentityProviderEnumGithub              ConnectionIdentityProviderEnum = "github"
	ConnectionIdentityProviderEnumGoogleApps          ConnectionIdentityProviderEnum = "google-apps"
	ConnectionIdentityProviderEnumGoogleOauth2        ConnectionIdentityProviderEnum = "google-oauth2"
	ConnectionIdentityProviderEnumInstagram           ConnectionIdentityProviderEnum = "instagram"
	ConnectionIdentityProviderEnumIP                  ConnectionIdentityProviderEnum = "ip"
	ConnectionIdentityProviderEnumLine                ConnectionIdentityProviderEnum = "line"
	ConnectionIdentityProviderEnumLinkedin            ConnectionIdentityProviderEnum = "linkedin"
	ConnectionIdentityProviderEnumMiicard             ConnectionIdentityProviderEnum = "miicard"
	ConnectionIdentityProviderEnumOauth1              ConnectionIdentityProviderEnum = "oauth1"
	ConnectionIdentityProviderEnumOauth2              ConnectionIdentityProviderEnum = "oauth2"
	ConnectionIdentityProviderEnumOffice365           ConnectionIdentityProviderEnum = "office365"
	ConnectionIdentityProviderEnumOidc                ConnectionIdentityProviderEnum = "oidc"
	ConnectionIdentityProviderEnumOkta                ConnectionIdentityProviderEnum = "okta"
	ConnectionIdentityProviderEnumPaypal              ConnectionIdentityProviderEnum = "paypal"
	ConnectionIdentityProviderEnumPaypalSandbox       ConnectionIdentityProviderEnum = "paypal-sandbox"
	ConnectionIdentityProviderEnumPingfederate        ConnectionIdentityProviderEnum = "pingfederate"
	ConnectionIdentityProviderEnumPlanningcenter      ConnectionIdentityProviderEnum = "planningcenter"
	ConnectionIdentityProviderEnumRenren              ConnectionIdentityProviderEnum = "renren"
	ConnectionIdentityProviderEnumSalesforceCommunity ConnectionIdentityProviderEnum = "salesforce-community"
	ConnectionIdentityProviderEnumSalesforceSandbox   ConnectionIdentityProviderEnum = "salesforce-sandbox"
	ConnectionIdentityProviderEnumSalesforce          ConnectionIdentityProviderEnum = "salesforce"
	ConnectionIdentityProviderEnumSamlp               ConnectionIdentityProviderEnum = "samlp"
	ConnectionIdentityProviderEnumSharepoint          ConnectionIdentityProviderEnum = "sharepoint"
	ConnectionIdentityProviderEnumShopify             ConnectionIdentityProviderEnum = "shopify"
	ConnectionIdentityProviderEnumShop                ConnectionIdentityProviderEnum = "shop"
	ConnectionIdentityProviderEnumSms                 ConnectionIdentityProviderEnum = "sms"
	ConnectionIdentityProviderEnumSoundcloud          ConnectionIdentityProviderEnum = "soundcloud"
	ConnectionIdentityProviderEnumThecitySandbox      ConnectionIdentityProviderEnum = "thecity-sandbox"
	ConnectionIdentityProviderEnumThecity             ConnectionIdentityProviderEnum = "thecity"
	ConnectionIdentityProviderEnumThirtysevensignals  ConnectionIdentityProviderEnum = "thirtysevensignals"
	ConnectionIdentityProviderEnumTwitter             ConnectionIdentityProviderEnum = "twitter"
	ConnectionIdentityProviderEnumUntappd             ConnectionIdentityProviderEnum = "untappd"
	ConnectionIdentityProviderEnumVkontakte           ConnectionIdentityProviderEnum = "vkontakte"
	ConnectionIdentityProviderEnumWaad                ConnectionIdentityProviderEnum = "waad"
	ConnectionIdentityProviderEnumWeibo               ConnectionIdentityProviderEnum = "weibo"
	ConnectionIdentityProviderEnumWindowslive         ConnectionIdentityProviderEnum = "windowslive"
	ConnectionIdentityProviderEnumWordpress           ConnectionIdentityProviderEnum = "wordpress"
	ConnectionIdentityProviderEnumYahoo               ConnectionIdentityProviderEnum = "yahoo"
	ConnectionIdentityProviderEnumYammer              ConnectionIdentityProviderEnum = "yammer"
	ConnectionIdentityProviderEnumYandex              ConnectionIdentityProviderEnum = "yandex"
)

func NewConnectionIdentityProviderEnumFromString(s string) (ConnectionIdentityProviderEnum, error) {
	switch s {
	case "ad":
		return ConnectionIdentityProviderEnumAd, nil
	case "adfs":
		return ConnectionIdentityProviderEnumAdfs, nil
	case "amazon":
		return ConnectionIdentityProviderEnumAmazon, nil
	case "apple":
		return ConnectionIdentityProviderEnumApple, nil
	case "dropbox":
		return ConnectionIdentityProviderEnumDropbox, nil
	case "bitbucket":
		return ConnectionIdentityProviderEnumBitbucket, nil
	case "aol":
		return ConnectionIdentityProviderEnumAol, nil
	case "auth0-oidc":
		return ConnectionIdentityProviderEnumAuth0Oidc, nil
	case "auth0":
		return ConnectionIdentityProviderEnumAuth0, nil
	case "baidu":
		return ConnectionIdentityProviderEnumBaidu, nil
	case "bitly":
		return ConnectionIdentityProviderEnumBitly, nil
	case "box":
		return ConnectionIdentityProviderEnumBox, nil
	case "custom":
		return ConnectionIdentityProviderEnumCustom, nil
	case "daccount":
		return ConnectionIdentityProviderEnumDaccount, nil
	case "dwolla":
		return ConnectionIdentityProviderEnumDwolla, nil
	case "email":
		return ConnectionIdentityProviderEnumEmail, nil
	case "evernote-sandbox":
		return ConnectionIdentityProviderEnumEvernoteSandbox, nil
	case "evernote":
		return ConnectionIdentityProviderEnumEvernote, nil
	case "exact":
		return ConnectionIdentityProviderEnumExact, nil
	case "facebook":
		return ConnectionIdentityProviderEnumFacebook, nil
	case "fitbit":
		return ConnectionIdentityProviderEnumFitbit, nil
	case "flickr":
		return ConnectionIdentityProviderEnumFlickr, nil
	case "github":
		return ConnectionIdentityProviderEnumGithub, nil
	case "google-apps":
		return ConnectionIdentityProviderEnumGoogleApps, nil
	case "google-oauth2":
		return ConnectionIdentityProviderEnumGoogleOauth2, nil
	case "instagram":
		return ConnectionIdentityProviderEnumInstagram, nil
	case "ip":
		return ConnectionIdentityProviderEnumIP, nil
	case "line":
		return ConnectionIdentityProviderEnumLine, nil
	case "linkedin":
		return ConnectionIdentityProviderEnumLinkedin, nil
	case "miicard":
		return ConnectionIdentityProviderEnumMiicard, nil
	case "oauth1":
		return ConnectionIdentityProviderEnumOauth1, nil
	case "oauth2":
		return ConnectionIdentityProviderEnumOauth2, nil
	case "office365":
		return ConnectionIdentityProviderEnumOffice365, nil
	case "oidc":
		return ConnectionIdentityProviderEnumOidc, nil
	case "okta":
		return ConnectionIdentityProviderEnumOkta, nil
	case "paypal":
		return ConnectionIdentityProviderEnumPaypal, nil
	case "paypal-sandbox":
		return ConnectionIdentityProviderEnumPaypalSandbox, nil
	case "pingfederate":
		return ConnectionIdentityProviderEnumPingfederate, nil
	case "planningcenter":
		return ConnectionIdentityProviderEnumPlanningcenter, nil
	case "renren":
		return ConnectionIdentityProviderEnumRenren, nil
	case "salesforce-community":
		return ConnectionIdentityProviderEnumSalesforceCommunity, nil
	case "salesforce-sandbox":
		return ConnectionIdentityProviderEnumSalesforceSandbox, nil
	case "salesforce":
		return ConnectionIdentityProviderEnumSalesforce, nil
	case "samlp":
		return ConnectionIdentityProviderEnumSamlp, nil
	case "sharepoint":
		return ConnectionIdentityProviderEnumSharepoint, nil
	case "shopify":
		return ConnectionIdentityProviderEnumShopify, nil
	case "shop":
		return ConnectionIdentityProviderEnumShop, nil
	case "sms":
		return ConnectionIdentityProviderEnumSms, nil
	case "soundcloud":
		return ConnectionIdentityProviderEnumSoundcloud, nil
	case "thecity-sandbox":
		return ConnectionIdentityProviderEnumThecitySandbox, nil
	case "thecity":
		return ConnectionIdentityProviderEnumThecity, nil
	case "thirtysevensignals":
		return ConnectionIdentityProviderEnumThirtysevensignals, nil
	case "twitter":
		return ConnectionIdentityProviderEnumTwitter, nil
	case "untappd":
		return ConnectionIdentityProviderEnumUntappd, nil
	case "vkontakte":
		return ConnectionIdentityProviderEnumVkontakte, nil
	case "waad":
		return ConnectionIdentityProviderEnumWaad, nil
	case "weibo":
		return ConnectionIdentityProviderEnumWeibo, nil
	case "windowslive":
		return ConnectionIdentityProviderEnumWindowslive, nil
	case "wordpress":
		return ConnectionIdentityProviderEnumWordpress, nil
	case "yahoo":
		return ConnectionIdentityProviderEnumYahoo, nil
	case "yammer":
		return ConnectionIdentityProviderEnumYammer, nil
	case "yandex":
		return ConnectionIdentityProviderEnumYandex, nil
	}
	var t ConnectionIdentityProviderEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionIdentityProviderEnum) Ptr() *ConnectionIdentityProviderEnum {
	return &c
}

// Passkey authentication enablement
type ConnectionPasskeyAuthenticationMethod struct {
	// Determines whether passkeys are enabled
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionPasskeyAuthenticationMethod) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *ConnectionPasskeyAuthenticationMethod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionPasskeyAuthenticationMethod) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionPasskeyAuthenticationMethod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionPasskeyAuthenticationMethod(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionPasskeyAuthenticationMethod) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Controls the UI used to challenge the user for their passkey.
type ConnectionPasskeyChallengeUIEnum string

const (
	ConnectionPasskeyChallengeUIEnumBoth     ConnectionPasskeyChallengeUIEnum = "both"
	ConnectionPasskeyChallengeUIEnumAutofill ConnectionPasskeyChallengeUIEnum = "autofill"
	ConnectionPasskeyChallengeUIEnumButton   ConnectionPasskeyChallengeUIEnum = "button"
)

func NewConnectionPasskeyChallengeUIEnumFromString(s string) (ConnectionPasskeyChallengeUIEnum, error) {
	switch s {
	case "both":
		return ConnectionPasskeyChallengeUIEnumBoth, nil
	case "autofill":
		return ConnectionPasskeyChallengeUIEnumAutofill, nil
	case "button":
		return ConnectionPasskeyChallengeUIEnumButton, nil
	}
	var t ConnectionPasskeyChallengeUIEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionPasskeyChallengeUIEnum) Ptr() *ConnectionPasskeyChallengeUIEnum {
	return &c
}

// Options for the passkey authentication method
type ConnectionPasskeyOptions struct {
	ChallengeUI *ConnectionPasskeyChallengeUIEnum `json:"challenge_ui,omitempty" url:"challenge_ui,omitempty"`
	// Enables or disables progressive enrollment of passkeys for the connection.
	ProgressiveEnrollmentEnabled *bool `json:"progressive_enrollment_enabled,omitempty" url:"progressive_enrollment_enabled,omitempty"`
	// Enables or disables enrollment prompt for local passkey when user authenticates using a cross-device passkey for the connection.
	LocalEnrollmentEnabled *bool `json:"local_enrollment_enabled,omitempty" url:"local_enrollment_enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionPasskeyOptions) GetChallengeUI() *ConnectionPasskeyChallengeUIEnum {
	if c == nil {
		return nil
	}
	return c.ChallengeUI
}

func (c *ConnectionPasskeyOptions) GetProgressiveEnrollmentEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.ProgressiveEnrollmentEnabled
}

func (c *ConnectionPasskeyOptions) GetLocalEnrollmentEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.LocalEnrollmentEnabled
}

func (c *ConnectionPasskeyOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionPasskeyOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionPasskeyOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionPasskeyOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionPasskeyOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Password authentication enablement
type ConnectionPasswordAuthenticationMethod struct {
	// Determines whether passwords are enabled
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionPasswordAuthenticationMethod) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *ConnectionPasswordAuthenticationMethod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionPasswordAuthenticationMethod) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionPasswordAuthenticationMethod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionPasswordAuthenticationMethod(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionPasswordAuthenticationMethod) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Password complexity options
type ConnectionPasswordComplexityOptions struct {
	// Minimum password length
	MinLength *int `json:"min_length,omitempty" url:"min_length,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionPasswordComplexityOptions) GetMinLength() *int {
	if c == nil {
		return nil
	}
	return c.MinLength
}

func (c *ConnectionPasswordComplexityOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionPasswordComplexityOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionPasswordComplexityOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionPasswordComplexityOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionPasswordComplexityOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Options for password dictionary policy
type ConnectionPasswordDictionaryOptions struct {
	Enable bool `json:"enable" url:"enable"`
	// Custom Password Dictionary. An array of up to 200 entries.
	Dictionary []string `json:"dictionary,omitempty" url:"dictionary,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionPasswordDictionaryOptions) GetEnable() bool {
	if c == nil {
		return false
	}
	return c.Enable
}

func (c *ConnectionPasswordDictionaryOptions) GetDictionary() []string {
	if c == nil {
		return nil
	}
	return c.Dictionary
}

func (c *ConnectionPasswordDictionaryOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionPasswordDictionaryOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionPasswordDictionaryOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionPasswordDictionaryOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionPasswordDictionaryOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Options for password history policy
type ConnectionPasswordHistoryOptions struct {
	Enable bool `json:"enable" url:"enable"`
	Size   *int `json:"size,omitempty" url:"size,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionPasswordHistoryOptions) GetEnable() bool {
	if c == nil {
		return false
	}
	return c.Enable
}

func (c *ConnectionPasswordHistoryOptions) GetSize() *int {
	if c == nil {
		return nil
	}
	return c.Size
}

func (c *ConnectionPasswordHistoryOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionPasswordHistoryOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionPasswordHistoryOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionPasswordHistoryOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionPasswordHistoryOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Options for personal info in passwords policy
type ConnectionPasswordNoPersonalInfoOptions struct {
	Enable bool `json:"enable" url:"enable"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionPasswordNoPersonalInfoOptions) GetEnable() bool {
	if c == nil {
		return false
	}
	return c.Enable
}

func (c *ConnectionPasswordNoPersonalInfoOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionPasswordNoPersonalInfoOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionPasswordNoPersonalInfoOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionPasswordNoPersonalInfoOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionPasswordNoPersonalInfoOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Password strength level
type ConnectionPasswordPolicyEnum = *string

// The connection's options (depend on the connection strategy)
type ConnectionPropertiesOptions struct {
	Validation *ConnectionValidationOptions `json:"validation,omitempty" url:"validation,omitempty"`
	// An array of user fields that should not be stored in the Auth0 database (https://auth0.com/docs/security/data-security/denylist)
	NonPersistentAttrs []string `json:"non_persistent_attrs,omitempty" url:"non_persistent_attrs,omitempty"`
	// Order of precedence for attribute types. If the property is not specified, the default precedence of attributes will be used.
	Precedence          []ConnectionIdentifierPrecedenceEnum `json:"precedence,omitempty" url:"precedence,omitempty"`
	Attributes          *ConnectionAttributes                `json:"attributes,omitempty" url:"attributes,omitempty"`
	EnableScriptContext *bool                                `json:"enable_script_context,omitempty" url:"enable_script_context,omitempty"`
	// Set to true to use a legacy user store
	EnabledDatabaseCustomization *bool `json:"enabledDatabaseCustomization,omitempty" url:"enabledDatabaseCustomization,omitempty"`
	// Enable this if you have a legacy user store and you want to gradually migrate those users to the Auth0 user store
	ImportMode                       *bool                                    `json:"import_mode,omitempty" url:"import_mode,omitempty"`
	CustomScripts                    *ConnectionCustomScripts                 `json:"customScripts,omitempty" url:"customScripts,omitempty"`
	AuthenticationMethods            *ConnectionAuthenticationMethods         `json:"authentication_methods,omitempty" url:"authentication_methods,omitempty"`
	PasskeyOptions                   *ConnectionPasskeyOptions                `json:"passkey_options,omitempty" url:"passkey_options,omitempty"`
	PasswordPolicy                   *ConnectionPasswordPolicyEnum            `json:"passwordPolicy,omitempty" url:"passwordPolicy,omitempty"`
	PasswordComplexityOptions        *ConnectionPasswordComplexityOptions     `json:"password_complexity_options,omitempty" url:"password_complexity_options,omitempty"`
	PasswordHistory                  *ConnectionPasswordHistoryOptions        `json:"password_history,omitempty" url:"password_history,omitempty"`
	PasswordNoPersonalInfo           *ConnectionPasswordNoPersonalInfoOptions `json:"password_no_personal_info,omitempty" url:"password_no_personal_info,omitempty"`
	PasswordDictionary               *ConnectionPasswordDictionaryOptions     `json:"password_dictionary,omitempty" url:"password_dictionary,omitempty"`
	APIEnableUsers                   *bool                                    `json:"api_enable_users,omitempty" url:"api_enable_users,omitempty"`
	BasicProfile                     *bool                                    `json:"basic_profile,omitempty" url:"basic_profile,omitempty"`
	ExtAdmin                         *bool                                    `json:"ext_admin,omitempty" url:"ext_admin,omitempty"`
	ExtIsSuspended                   *bool                                    `json:"ext_is_suspended,omitempty" url:"ext_is_suspended,omitempty"`
	ExtAgreedTerms                   *bool                                    `json:"ext_agreed_terms,omitempty" url:"ext_agreed_terms,omitempty"`
	ExtGroups                        *bool                                    `json:"ext_groups,omitempty" url:"ext_groups,omitempty"`
	ExtAssignedPlans                 *bool                                    `json:"ext_assigned_plans,omitempty" url:"ext_assigned_plans,omitempty"`
	ExtProfile                       *bool                                    `json:"ext_profile,omitempty" url:"ext_profile,omitempty"`
	DisableSelfServiceChangePassword *bool                                    `json:"disable_self_service_change_password,omitempty" url:"disable_self_service_change_password,omitempty"`
	UpstreamParams                   *ConnectionUpstreamParams                `json:"upstream_params,omitempty" url:"upstream_params,omitempty"`
	SetUserRootAttributes            *ConnectionSetUserRootAttributesEnum     `json:"set_user_root_attributes,omitempty" url:"set_user_root_attributes,omitempty"`
	GatewayAuthentication            *ConnectionGatewayAuthentication         `json:"gateway_authentication,omitempty" url:"gateway_authentication,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ConnectionPropertiesOptions) GetValidation() *ConnectionValidationOptions {
	if c == nil {
		return nil
	}
	return c.Validation
}

func (c *ConnectionPropertiesOptions) GetNonPersistentAttrs() []string {
	if c == nil {
		return nil
	}
	return c.NonPersistentAttrs
}

func (c *ConnectionPropertiesOptions) GetPrecedence() []ConnectionIdentifierPrecedenceEnum {
	if c == nil {
		return nil
	}
	return c.Precedence
}

func (c *ConnectionPropertiesOptions) GetAttributes() *ConnectionAttributes {
	if c == nil {
		return nil
	}
	return c.Attributes
}

func (c *ConnectionPropertiesOptions) GetEnableScriptContext() *bool {
	if c == nil {
		return nil
	}
	return c.EnableScriptContext
}

func (c *ConnectionPropertiesOptions) GetEnabledDatabaseCustomization() *bool {
	if c == nil {
		return nil
	}
	return c.EnabledDatabaseCustomization
}

func (c *ConnectionPropertiesOptions) GetImportMode() *bool {
	if c == nil {
		return nil
	}
	return c.ImportMode
}

func (c *ConnectionPropertiesOptions) GetCustomScripts() *ConnectionCustomScripts {
	if c == nil {
		return nil
	}
	return c.CustomScripts
}

func (c *ConnectionPropertiesOptions) GetAuthenticationMethods() *ConnectionAuthenticationMethods {
	if c == nil {
		return nil
	}
	return c.AuthenticationMethods
}

func (c *ConnectionPropertiesOptions) GetPasskeyOptions() *ConnectionPasskeyOptions {
	if c == nil {
		return nil
	}
	return c.PasskeyOptions
}

func (c *ConnectionPropertiesOptions) GetPasswordPolicy() *ConnectionPasswordPolicyEnum {
	if c == nil {
		return nil
	}
	return c.PasswordPolicy
}

func (c *ConnectionPropertiesOptions) GetPasswordComplexityOptions() *ConnectionPasswordComplexityOptions {
	if c == nil {
		return nil
	}
	return c.PasswordComplexityOptions
}

func (c *ConnectionPropertiesOptions) GetPasswordHistory() *ConnectionPasswordHistoryOptions {
	if c == nil {
		return nil
	}
	return c.PasswordHistory
}

func (c *ConnectionPropertiesOptions) GetPasswordNoPersonalInfo() *ConnectionPasswordNoPersonalInfoOptions {
	if c == nil {
		return nil
	}
	return c.PasswordNoPersonalInfo
}

func (c *ConnectionPropertiesOptions) GetPasswordDictionary() *ConnectionPasswordDictionaryOptions {
	if c == nil {
		return nil
	}
	return c.PasswordDictionary
}

func (c *ConnectionPropertiesOptions) GetAPIEnableUsers() *bool {
	if c == nil {
		return nil
	}
	return c.APIEnableUsers
}

func (c *ConnectionPropertiesOptions) GetBasicProfile() *bool {
	if c == nil {
		return nil
	}
	return c.BasicProfile
}

func (c *ConnectionPropertiesOptions) GetExtAdmin() *bool {
	if c == nil {
		return nil
	}
	return c.ExtAdmin
}

func (c *ConnectionPropertiesOptions) GetExtIsSuspended() *bool {
	if c == nil {
		return nil
	}
	return c.ExtIsSuspended
}

func (c *ConnectionPropertiesOptions) GetExtAgreedTerms() *bool {
	if c == nil {
		return nil
	}
	return c.ExtAgreedTerms
}

func (c *ConnectionPropertiesOptions) GetExtGroups() *bool {
	if c == nil {
		return nil
	}
	return c.ExtGroups
}

func (c *ConnectionPropertiesOptions) GetExtAssignedPlans() *bool {
	if c == nil {
		return nil
	}
	return c.ExtAssignedPlans
}

func (c *ConnectionPropertiesOptions) GetExtProfile() *bool {
	if c == nil {
		return nil
	}
	return c.ExtProfile
}

func (c *ConnectionPropertiesOptions) GetDisableSelfServiceChangePassword() *bool {
	if c == nil {
		return nil
	}
	return c.DisableSelfServiceChangePassword
}

func (c *ConnectionPropertiesOptions) GetUpstreamParams() *ConnectionUpstreamParams {
	if c == nil {
		return nil
	}
	return c.UpstreamParams
}

func (c *ConnectionPropertiesOptions) GetSetUserRootAttributes() *ConnectionSetUserRootAttributesEnum {
	if c == nil {
		return nil
	}
	return c.SetUserRootAttributes
}

func (c *ConnectionPropertiesOptions) GetGatewayAuthentication() *ConnectionGatewayAuthentication {
	if c == nil {
		return nil
	}
	return c.GatewayAuthentication
}

func (c *ConnectionPropertiesOptions) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ConnectionPropertiesOptions) UnmarshalJSON(data []byte) error {
	type embed ConnectionPropertiesOptions
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConnectionPropertiesOptions(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionPropertiesOptions) MarshalJSON() ([]byte, error) {
	type embed ConnectionPropertiesOptions
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ConnectionPropertiesOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// When using an external IdP, this flag determines  whether 'name', 'given_name', 'family_name', 'nickname', and 'picture' attributes are updated. In addition, it also determines whether the user is created when user doesnt exist previously. Possible values are 'on_each_login' (default value, it configures the connection to automatically create the user if necessary and update the root attributes from the external IdP with each user login. When this setting is used, root attributes cannot be independently updated), 'on_first_login' (configures the connection to create the user and set the root attributes on first login only, allowing them to be independently updated thereafter), and 'never_on_login' (configures the connection not to create the user and not to set the root attributes from the external IdP, allowing them to be independently updated).
type ConnectionSetUserRootAttributesEnum string

const (
	ConnectionSetUserRootAttributesEnumOnEachLogin  ConnectionSetUserRootAttributesEnum = "on_each_login"
	ConnectionSetUserRootAttributesEnumOnFirstLogin ConnectionSetUserRootAttributesEnum = "on_first_login"
	ConnectionSetUserRootAttributesEnumNeverOnLogin ConnectionSetUserRootAttributesEnum = "never_on_login"
)

func NewConnectionSetUserRootAttributesEnumFromString(s string) (ConnectionSetUserRootAttributesEnum, error) {
	switch s {
	case "on_each_login":
		return ConnectionSetUserRootAttributesEnumOnEachLogin, nil
	case "on_first_login":
		return ConnectionSetUserRootAttributesEnumOnFirstLogin, nil
	case "never_on_login":
		return ConnectionSetUserRootAttributesEnumNeverOnLogin, nil
	}
	var t ConnectionSetUserRootAttributesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionSetUserRootAttributesEnum) Ptr() *ConnectionSetUserRootAttributesEnum {
	return &c
}

// Options for adding parameters in the request to the upstream IdP
type ConnectionUpstreamParams = map[string]interface{}

type ConnectionUsernameValidationOptions struct {
	Min int `json:"min" url:"min"`
	Max int `json:"max" url:"max"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionUsernameValidationOptions) GetMin() int {
	if c == nil {
		return 0
	}
	return c.Min
}

func (c *ConnectionUsernameValidationOptions) GetMax() int {
	if c == nil {
		return 0
	}
	return c.Max
}

func (c *ConnectionUsernameValidationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionUsernameValidationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionUsernameValidationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionUsernameValidationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionUsernameValidationOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Options for validation
type ConnectionValidationOptions struct {
	Username *ConnectionUsernameValidationOptions `json:"username,omitempty" url:"username,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConnectionValidationOptions) GetUsername() *ConnectionUsernameValidationOptions {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *ConnectionValidationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionValidationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionValidationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionValidationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionValidationOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectionResponseContent struct {
	// The name of the connection
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Connection name used in login screen
	DisplayName *string            `json:"display_name,omitempty" url:"display_name,omitempty"`
	Options     *ConnectionOptions `json:"options,omitempty" url:"options,omitempty"`
	// The connection's identifier
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of the connection, related to the identity provider
	Strategy *string `json:"strategy,omitempty" url:"strategy,omitempty"`
	// Defines the realms for which the connection will be used (ie: email domains). If the array is empty or the property is not specified, the connection name will be added as realm.
	Realms []string `json:"realms,omitempty" url:"realms,omitempty"`
	// DEPRECATED property. Use the GET /connections/:id/clients endpoint to get the ids of the clients for which the connection is enabled
	EnabledClients []string `json:"enabled_clients,omitempty" url:"enabled_clients,omitempty"`
	// True if the connection is domain level
	IsDomainConnection *bool `json:"is_domain_connection,omitempty" url:"is_domain_connection,omitempty"`
	// Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD.
	ShowAsButton *bool                `json:"show_as_button,omitempty" url:"show_as_button,omitempty"`
	Metadata     *ConnectionsMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateConnectionResponseContent) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateConnectionResponseContent) GetDisplayName() *string {
	if c == nil {
		return nil
	}
	return c.DisplayName
}

func (c *CreateConnectionResponseContent) GetOptions() *ConnectionOptions {
	if c == nil {
		return nil
	}
	return c.Options
}

func (c *CreateConnectionResponseContent) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CreateConnectionResponseContent) GetStrategy() *string {
	if c == nil {
		return nil
	}
	return c.Strategy
}

func (c *CreateConnectionResponseContent) GetRealms() []string {
	if c == nil {
		return nil
	}
	return c.Realms
}

func (c *CreateConnectionResponseContent) GetEnabledClients() []string {
	if c == nil {
		return nil
	}
	return c.EnabledClients
}

func (c *CreateConnectionResponseContent) GetIsDomainConnection() *bool {
	if c == nil {
		return nil
	}
	return c.IsDomainConnection
}

func (c *CreateConnectionResponseContent) GetShowAsButton() *bool {
	if c == nil {
		return nil
	}
	return c.ShowAsButton
}

func (c *CreateConnectionResponseContent) GetMetadata() *ConnectionsMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateConnectionResponseContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateConnectionResponseContent) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectionResponseContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectionResponseContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectionResponseContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configuration for the email attribute for users.
type EmailAttribute struct {
	Identifier *ConnectionAttributeIdentifier `json:"identifier,omitempty" url:"identifier,omitempty"`
	// Determines if property should be required for users
	ProfileRequired    *bool                   `json:"profile_required,omitempty" url:"profile_required,omitempty"`
	VerificationMethod *VerificationMethodEnum `json:"verification_method,omitempty" url:"verification_method,omitempty"`
	Signup             *SignupVerified         `json:"signup,omitempty" url:"signup,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmailAttribute) GetIdentifier() *ConnectionAttributeIdentifier {
	if e == nil {
		return nil
	}
	return e.Identifier
}

func (e *EmailAttribute) GetProfileRequired() *bool {
	if e == nil {
		return nil
	}
	return e.ProfileRequired
}

func (e *EmailAttribute) GetVerificationMethod() *VerificationMethodEnum {
	if e == nil {
		return nil
	}
	return e.VerificationMethod
}

func (e *EmailAttribute) GetSignup() *SignupVerified {
	if e == nil {
		return nil
	}
	return e.Signup
}

func (e *EmailAttribute) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailAttribute(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailAttribute) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type GetConnectionResponseContent struct {
	// The name of the connection
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Connection name used in login screen
	DisplayName *string            `json:"display_name,omitempty" url:"display_name,omitempty"`
	Options     *ConnectionOptions `json:"options,omitempty" url:"options,omitempty"`
	// The connection's identifier
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of the connection, related to the identity provider
	Strategy *string `json:"strategy,omitempty" url:"strategy,omitempty"`
	// Defines the realms for which the connection will be used (ie: email domains). If the array is empty or the property is not specified, the connection name will be added as realm.
	Realms []string `json:"realms,omitempty" url:"realms,omitempty"`
	// DEPRECATED property. Use the GET /connections/:id/clients endpoint to get the ids of the clients for which the connection is enabled
	EnabledClients []string `json:"enabled_clients,omitempty" url:"enabled_clients,omitempty"`
	// True if the connection is domain level
	IsDomainConnection *bool `json:"is_domain_connection,omitempty" url:"is_domain_connection,omitempty"`
	// Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD.
	ShowAsButton *bool                `json:"show_as_button,omitempty" url:"show_as_button,omitempty"`
	Metadata     *ConnectionsMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetConnectionResponseContent) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GetConnectionResponseContent) GetDisplayName() *string {
	if g == nil {
		return nil
	}
	return g.DisplayName
}

func (g *GetConnectionResponseContent) GetOptions() *ConnectionOptions {
	if g == nil {
		return nil
	}
	return g.Options
}

func (g *GetConnectionResponseContent) GetID() *string {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *GetConnectionResponseContent) GetStrategy() *string {
	if g == nil {
		return nil
	}
	return g.Strategy
}

func (g *GetConnectionResponseContent) GetRealms() []string {
	if g == nil {
		return nil
	}
	return g.Realms
}

func (g *GetConnectionResponseContent) GetEnabledClients() []string {
	if g == nil {
		return nil
	}
	return g.EnabledClients
}

func (g *GetConnectionResponseContent) GetIsDomainConnection() *bool {
	if g == nil {
		return nil
	}
	return g.IsDomainConnection
}

func (g *GetConnectionResponseContent) GetShowAsButton() *bool {
	if g == nil {
		return nil
	}
	return g.ShowAsButton
}

func (g *GetConnectionResponseContent) GetMetadata() *ConnectionsMetadata {
	if g == nil {
		return nil
	}
	return g.Metadata
}

func (g *GetConnectionResponseContent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetConnectionResponseContent) UnmarshalJSON(data []byte) error {
	type unmarshaler GetConnectionResponseContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetConnectionResponseContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetConnectionResponseContent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListConnectionsCheckpointPaginatedResponseContent struct {
	// Opaque identifier for use with the <i>from</i> query parameter for the next page of results.
	Next        *string              `json:"next,omitempty" url:"next,omitempty"`
	Connections []*ConnectionForList `json:"connections,omitempty" url:"connections,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListConnectionsCheckpointPaginatedResponseContent) GetNext() *string {
	if l == nil {
		return nil
	}
	return l.Next
}

func (l *ListConnectionsCheckpointPaginatedResponseContent) GetConnections() []*ConnectionForList {
	if l == nil {
		return nil
	}
	return l.Connections
}

func (l *ListConnectionsCheckpointPaginatedResponseContent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListConnectionsCheckpointPaginatedResponseContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ListConnectionsCheckpointPaginatedResponseContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListConnectionsCheckpointPaginatedResponseContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListConnectionsCheckpointPaginatedResponseContent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Configuration for the phone number attribute for users.
type PhoneAttribute struct {
	Identifier *ConnectionAttributeIdentifier `json:"identifier,omitempty" url:"identifier,omitempty"`
	// Determines if property should be required for users
	ProfileRequired *bool           `json:"profile_required,omitempty" url:"profile_required,omitempty"`
	Signup          *SignupVerified `json:"signup,omitempty" url:"signup,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PhoneAttribute) GetIdentifier() *ConnectionAttributeIdentifier {
	if p == nil {
		return nil
	}
	return p.Identifier
}

func (p *PhoneAttribute) GetProfileRequired() *bool {
	if p == nil {
		return nil
	}
	return p.ProfileRequired
}

func (p *PhoneAttribute) GetSignup() *SignupVerified {
	if p == nil {
		return nil
	}
	return p.Signup
}

func (p *PhoneAttribute) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhoneAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler PhoneAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhoneAttribute(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhoneAttribute) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type SignupSchema struct {
	Status *SignupStatusEnum `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SignupSchema) GetStatus() *SignupStatusEnum {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SignupSchema) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignupSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler SignupSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignupSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignupSchema) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SignupStatusEnum string

const (
	SignupStatusEnumRequired SignupStatusEnum = "required"
	SignupStatusEnumOptional SignupStatusEnum = "optional"
	SignupStatusEnumInactive SignupStatusEnum = "inactive"
)

func NewSignupStatusEnumFromString(s string) (SignupStatusEnum, error) {
	switch s {
	case "required":
		return SignupStatusEnumRequired, nil
	case "optional":
		return SignupStatusEnumOptional, nil
	case "inactive":
		return SignupStatusEnumInactive, nil
	}
	var t SignupStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SignupStatusEnum) Ptr() *SignupStatusEnum {
	return &s
}

type SignupVerification struct {
	Active *bool `json:"active,omitempty" url:"active,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SignupVerification) GetActive() *bool {
	if s == nil {
		return nil
	}
	return s.Active
}

func (s *SignupVerification) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignupVerification) UnmarshalJSON(data []byte) error {
	type unmarshaler SignupVerification
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignupVerification(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignupVerification) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SignupVerified struct {
	Status       *SignupStatusEnum   `json:"status,omitempty" url:"status,omitempty"`
	Verification *SignupVerification `json:"verification,omitempty" url:"verification,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SignupVerified) GetStatus() *SignupStatusEnum {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SignupVerified) GetVerification() *SignupVerification {
	if s == nil {
		return nil
	}
	return s.Verification
}

func (s *SignupVerified) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignupVerified) UnmarshalJSON(data []byte) error {
	type unmarshaler SignupVerified
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignupVerified(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignupVerified) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The connection's options (depend on the connection strategy). To update these options, the `update:connections_options` scope must be present. To verify your changes, also include the `read:connections_options` scope. If this scope is not specified, you will not be able to review the updated object.
type UpdateConnectionOptions struct {
	Validation *ConnectionValidationOptions `json:"validation,omitempty" url:"validation,omitempty"`
	// An array of user fields that should not be stored in the Auth0 database (https://auth0.com/docs/security/data-security/denylist)
	NonPersistentAttrs []string `json:"non_persistent_attrs,omitempty" url:"non_persistent_attrs,omitempty"`
	// Order of precedence for attribute types. If the property is not specified, the default precedence of attributes will be used.
	Precedence          []ConnectionIdentifierPrecedenceEnum `json:"precedence,omitempty" url:"precedence,omitempty"`
	Attributes          *ConnectionAttributes                `json:"attributes,omitempty" url:"attributes,omitempty"`
	EnableScriptContext *bool                                `json:"enable_script_context,omitempty" url:"enable_script_context,omitempty"`
	// Set to true to use a legacy user store
	EnabledDatabaseCustomization *bool `json:"enabledDatabaseCustomization,omitempty" url:"enabledDatabaseCustomization,omitempty"`
	// Enable this if you have a legacy user store and you want to gradually migrate those users to the Auth0 user store
	ImportMode                       *bool                                    `json:"import_mode,omitempty" url:"import_mode,omitempty"`
	CustomScripts                    *ConnectionCustomScripts                 `json:"customScripts,omitempty" url:"customScripts,omitempty"`
	AuthenticationMethods            *ConnectionAuthenticationMethods         `json:"authentication_methods,omitempty" url:"authentication_methods,omitempty"`
	PasskeyOptions                   *ConnectionPasskeyOptions                `json:"passkey_options,omitempty" url:"passkey_options,omitempty"`
	PasswordPolicy                   *ConnectionPasswordPolicyEnum            `json:"passwordPolicy,omitempty" url:"passwordPolicy,omitempty"`
	PasswordComplexityOptions        *ConnectionPasswordComplexityOptions     `json:"password_complexity_options,omitempty" url:"password_complexity_options,omitempty"`
	PasswordHistory                  *ConnectionPasswordHistoryOptions        `json:"password_history,omitempty" url:"password_history,omitempty"`
	PasswordNoPersonalInfo           *ConnectionPasswordNoPersonalInfoOptions `json:"password_no_personal_info,omitempty" url:"password_no_personal_info,omitempty"`
	PasswordDictionary               *ConnectionPasswordDictionaryOptions     `json:"password_dictionary,omitempty" url:"password_dictionary,omitempty"`
	APIEnableUsers                   *bool                                    `json:"api_enable_users,omitempty" url:"api_enable_users,omitempty"`
	BasicProfile                     *bool                                    `json:"basic_profile,omitempty" url:"basic_profile,omitempty"`
	ExtAdmin                         *bool                                    `json:"ext_admin,omitempty" url:"ext_admin,omitempty"`
	ExtIsSuspended                   *bool                                    `json:"ext_is_suspended,omitempty" url:"ext_is_suspended,omitempty"`
	ExtAgreedTerms                   *bool                                    `json:"ext_agreed_terms,omitempty" url:"ext_agreed_terms,omitempty"`
	ExtGroups                        *bool                                    `json:"ext_groups,omitempty" url:"ext_groups,omitempty"`
	ExtAssignedPlans                 *bool                                    `json:"ext_assigned_plans,omitempty" url:"ext_assigned_plans,omitempty"`
	ExtProfile                       *bool                                    `json:"ext_profile,omitempty" url:"ext_profile,omitempty"`
	DisableSelfServiceChangePassword *bool                                    `json:"disable_self_service_change_password,omitempty" url:"disable_self_service_change_password,omitempty"`
	UpstreamParams                   *ConnectionUpstreamParams                `json:"upstream_params,omitempty" url:"upstream_params,omitempty"`
	SetUserRootAttributes            *ConnectionSetUserRootAttributesEnum     `json:"set_user_root_attributes,omitempty" url:"set_user_root_attributes,omitempty"`
	GatewayAuthentication            *ConnectionGatewayAuthentication         `json:"gateway_authentication,omitempty" url:"gateway_authentication,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (u *UpdateConnectionOptions) GetValidation() *ConnectionValidationOptions {
	if u == nil {
		return nil
	}
	return u.Validation
}

func (u *UpdateConnectionOptions) GetNonPersistentAttrs() []string {
	if u == nil {
		return nil
	}
	return u.NonPersistentAttrs
}

func (u *UpdateConnectionOptions) GetPrecedence() []ConnectionIdentifierPrecedenceEnum {
	if u == nil {
		return nil
	}
	return u.Precedence
}

func (u *UpdateConnectionOptions) GetAttributes() *ConnectionAttributes {
	if u == nil {
		return nil
	}
	return u.Attributes
}

func (u *UpdateConnectionOptions) GetEnableScriptContext() *bool {
	if u == nil {
		return nil
	}
	return u.EnableScriptContext
}

func (u *UpdateConnectionOptions) GetEnabledDatabaseCustomization() *bool {
	if u == nil {
		return nil
	}
	return u.EnabledDatabaseCustomization
}

func (u *UpdateConnectionOptions) GetImportMode() *bool {
	if u == nil {
		return nil
	}
	return u.ImportMode
}

func (u *UpdateConnectionOptions) GetCustomScripts() *ConnectionCustomScripts {
	if u == nil {
		return nil
	}
	return u.CustomScripts
}

func (u *UpdateConnectionOptions) GetAuthenticationMethods() *ConnectionAuthenticationMethods {
	if u == nil {
		return nil
	}
	return u.AuthenticationMethods
}

func (u *UpdateConnectionOptions) GetPasskeyOptions() *ConnectionPasskeyOptions {
	if u == nil {
		return nil
	}
	return u.PasskeyOptions
}

func (u *UpdateConnectionOptions) GetPasswordPolicy() *ConnectionPasswordPolicyEnum {
	if u == nil {
		return nil
	}
	return u.PasswordPolicy
}

func (u *UpdateConnectionOptions) GetPasswordComplexityOptions() *ConnectionPasswordComplexityOptions {
	if u == nil {
		return nil
	}
	return u.PasswordComplexityOptions
}

func (u *UpdateConnectionOptions) GetPasswordHistory() *ConnectionPasswordHistoryOptions {
	if u == nil {
		return nil
	}
	return u.PasswordHistory
}

func (u *UpdateConnectionOptions) GetPasswordNoPersonalInfo() *ConnectionPasswordNoPersonalInfoOptions {
	if u == nil {
		return nil
	}
	return u.PasswordNoPersonalInfo
}

func (u *UpdateConnectionOptions) GetPasswordDictionary() *ConnectionPasswordDictionaryOptions {
	if u == nil {
		return nil
	}
	return u.PasswordDictionary
}

func (u *UpdateConnectionOptions) GetAPIEnableUsers() *bool {
	if u == nil {
		return nil
	}
	return u.APIEnableUsers
}

func (u *UpdateConnectionOptions) GetBasicProfile() *bool {
	if u == nil {
		return nil
	}
	return u.BasicProfile
}

func (u *UpdateConnectionOptions) GetExtAdmin() *bool {
	if u == nil {
		return nil
	}
	return u.ExtAdmin
}

func (u *UpdateConnectionOptions) GetExtIsSuspended() *bool {
	if u == nil {
		return nil
	}
	return u.ExtIsSuspended
}

func (u *UpdateConnectionOptions) GetExtAgreedTerms() *bool {
	if u == nil {
		return nil
	}
	return u.ExtAgreedTerms
}

func (u *UpdateConnectionOptions) GetExtGroups() *bool {
	if u == nil {
		return nil
	}
	return u.ExtGroups
}

func (u *UpdateConnectionOptions) GetExtAssignedPlans() *bool {
	if u == nil {
		return nil
	}
	return u.ExtAssignedPlans
}

func (u *UpdateConnectionOptions) GetExtProfile() *bool {
	if u == nil {
		return nil
	}
	return u.ExtProfile
}

func (u *UpdateConnectionOptions) GetDisableSelfServiceChangePassword() *bool {
	if u == nil {
		return nil
	}
	return u.DisableSelfServiceChangePassword
}

func (u *UpdateConnectionOptions) GetUpstreamParams() *ConnectionUpstreamParams {
	if u == nil {
		return nil
	}
	return u.UpstreamParams
}

func (u *UpdateConnectionOptions) GetSetUserRootAttributes() *ConnectionSetUserRootAttributesEnum {
	if u == nil {
		return nil
	}
	return u.SetUserRootAttributes
}

func (u *UpdateConnectionOptions) GetGatewayAuthentication() *ConnectionGatewayAuthentication {
	if u == nil {
		return nil
	}
	return u.GatewayAuthentication
}

func (u *UpdateConnectionOptions) GetExtraProperties() map[string]interface{} {
	return u.ExtraProperties
}

func (u *UpdateConnectionOptions) UnmarshalJSON(data []byte) error {
	type embed UpdateConnectionOptions
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateConnectionOptions(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.ExtraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateConnectionOptions) MarshalJSON() ([]byte, error) {
	type embed UpdateConnectionOptions
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, u.ExtraProperties)
}

func (u *UpdateConnectionOptions) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateConnectionResponseContent struct {
	// The name of the connection
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Connection name used in login screen
	DisplayName *string            `json:"display_name,omitempty" url:"display_name,omitempty"`
	Options     *ConnectionOptions `json:"options,omitempty" url:"options,omitempty"`
	// The connection's identifier
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of the connection, related to the identity provider
	Strategy *string `json:"strategy,omitempty" url:"strategy,omitempty"`
	// Defines the realms for which the connection will be used (ie: email domains). If the array is empty or the property is not specified, the connection name will be added as realm.
	Realms []string `json:"realms,omitempty" url:"realms,omitempty"`
	// DEPRECATED property. Use the GET /connections/:id/clients endpoint to get the ids of the clients for which the connection is enabled
	EnabledClients []string `json:"enabled_clients,omitempty" url:"enabled_clients,omitempty"`
	// True if the connection is domain level
	IsDomainConnection *bool `json:"is_domain_connection,omitempty" url:"is_domain_connection,omitempty"`
	// Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD.
	ShowAsButton *bool                `json:"show_as_button,omitempty" url:"show_as_button,omitempty"`
	Metadata     *ConnectionsMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateConnectionResponseContent) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateConnectionResponseContent) GetDisplayName() *string {
	if u == nil {
		return nil
	}
	return u.DisplayName
}

func (u *UpdateConnectionResponseContent) GetOptions() *ConnectionOptions {
	if u == nil {
		return nil
	}
	return u.Options
}

func (u *UpdateConnectionResponseContent) GetID() *string {
	if u == nil {
		return nil
	}
	return u.ID
}

func (u *UpdateConnectionResponseContent) GetStrategy() *string {
	if u == nil {
		return nil
	}
	return u.Strategy
}

func (u *UpdateConnectionResponseContent) GetRealms() []string {
	if u == nil {
		return nil
	}
	return u.Realms
}

func (u *UpdateConnectionResponseContent) GetEnabledClients() []string {
	if u == nil {
		return nil
	}
	return u.EnabledClients
}

func (u *UpdateConnectionResponseContent) GetIsDomainConnection() *bool {
	if u == nil {
		return nil
	}
	return u.IsDomainConnection
}

func (u *UpdateConnectionResponseContent) GetShowAsButton() *bool {
	if u == nil {
		return nil
	}
	return u.ShowAsButton
}

func (u *UpdateConnectionResponseContent) GetMetadata() *ConnectionsMetadata {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UpdateConnectionResponseContent) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateConnectionResponseContent) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateConnectionResponseContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateConnectionResponseContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateConnectionResponseContent) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UsernameAllowedTypes struct {
	Email       *bool `json:"email,omitempty" url:"email,omitempty"`
	PhoneNumber *bool `json:"phone_number,omitempty" url:"phone_number,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UsernameAllowedTypes) GetEmail() *bool {
	if u == nil {
		return nil
	}
	return u.Email
}

func (u *UsernameAllowedTypes) GetPhoneNumber() *bool {
	if u == nil {
		return nil
	}
	return u.PhoneNumber
}

func (u *UsernameAllowedTypes) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsernameAllowedTypes) UnmarshalJSON(data []byte) error {
	type unmarshaler UsernameAllowedTypes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsernameAllowedTypes(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsernameAllowedTypes) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Configuration for the username attribute for users.
type UsernameAttribute struct {
	Identifier *ConnectionAttributeIdentifier `json:"identifier,omitempty" url:"identifier,omitempty"`
	// Determines if property should be required for users
	ProfileRequired *bool               `json:"profile_required,omitempty" url:"profile_required,omitempty"`
	Signup          *SignupSchema       `json:"signup,omitempty" url:"signup,omitempty"`
	Validation      *UsernameValidation `json:"validation,omitempty" url:"validation,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UsernameAttribute) GetIdentifier() *ConnectionAttributeIdentifier {
	if u == nil {
		return nil
	}
	return u.Identifier
}

func (u *UsernameAttribute) GetProfileRequired() *bool {
	if u == nil {
		return nil
	}
	return u.ProfileRequired
}

func (u *UsernameAttribute) GetSignup() *SignupSchema {
	if u == nil {
		return nil
	}
	return u.Signup
}

func (u *UsernameAttribute) GetValidation() *UsernameValidation {
	if u == nil {
		return nil
	}
	return u.Validation
}

func (u *UsernameAttribute) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsernameAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler UsernameAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsernameAttribute(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsernameAttribute) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UsernameValidation struct {
	// Minimum allowed length
	MinLength *float64 `json:"min_length,omitempty" url:"min_length,omitempty"`
	// Maximum allowed length
	MaxLength    *float64              `json:"max_length,omitempty" url:"max_length,omitempty"`
	AllowedTypes *UsernameAllowedTypes `json:"allowed_types,omitempty" url:"allowed_types,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UsernameValidation) GetMinLength() *float64 {
	if u == nil {
		return nil
	}
	return u.MinLength
}

func (u *UsernameValidation) GetMaxLength() *float64 {
	if u == nil {
		return nil
	}
	return u.MaxLength
}

func (u *UsernameValidation) GetAllowedTypes() *UsernameAllowedTypes {
	if u == nil {
		return nil
	}
	return u.AllowedTypes
}

func (u *UsernameValidation) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsernameValidation) UnmarshalJSON(data []byte) error {
	type unmarshaler UsernameValidation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsernameValidation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsernameValidation) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type VerificationMethodEnum string

const (
	VerificationMethodEnumLink VerificationMethodEnum = "link"
	VerificationMethodEnumOtp  VerificationMethodEnum = "otp"
)

func NewVerificationMethodEnumFromString(s string) (VerificationMethodEnum, error) {
	switch s {
	case "link":
		return VerificationMethodEnumLink, nil
	case "otp":
		return VerificationMethodEnumOtp, nil
	}
	var t VerificationMethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationMethodEnum) Ptr() *VerificationMethodEnum {
	return &v
}

type UpdateConnectionRequestContent struct {
	// The connection name used in the new universal login experience. If display_name is not included in the request, the field will be overwritten with the name value.
	DisplayName *string                  `json:"display_name,omitempty" url:"-"`
	Options     *UpdateConnectionOptions `json:"options,omitempty" url:"-"`
	// DEPRECATED property. Use the PATCH /v2/connections/{id}/clients endpoint to enable or disable the connection for any clients.
	EnabledClients []string `json:"enabled_clients,omitempty" url:"-"`
	// <code>true</code> promotes to a domain-level connection so that third-party applications can use it. <code>false</code> does not promote the connection, so only first-party applications with the connection enabled can use it. (Defaults to <code>false</code>.)
	IsDomainConnection *bool `json:"is_domain_connection,omitempty" url:"-"`
	// Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD. (Defaults to <code>false</code>.)
	ShowAsButton *bool `json:"show_as_button,omitempty" url:"-"`
	// Defines the realms for which the connection will be used (ie: email domains). If the array is empty or the property is not specified, the connection name will be added as realm.
	Realms   []string             `json:"realms,omitempty" url:"-"`
	Metadata *ConnectionsMetadata `json:"metadata,omitempty" url:"-"`
}
