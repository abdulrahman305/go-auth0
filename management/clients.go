// Code generated by Fern. DO NOT EDIT.

package management

import (
	json "encoding/json"
	fmt "fmt"
	time "time"

	internal "github.com/auth0/go-auth0/v2/management/internal"
)

type CreateClientRequestContent struct {
	// Name of this client (min length: 1 character, does not allow `<` or `>`).
	Name string `json:"name" url:"-"`
	// Free text description of this client (max length: 140 characters).
	Description *string `json:"description,omitempty" url:"-"`
	// URL of the logo to display for this client. Recommended size is 150x150 pixels.
	LogoURI *string `json:"logo_uri,omitempty" url:"-"`
	// Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication.
	Callbacks             []string                             `json:"callbacks,omitempty" url:"-"`
	OidcLogout            *ClientOidcBackchannelLogoutSettings `json:"oidc_logout,omitempty" url:"-"`
	OidcBackchannelLogout *ClientOidcBackchannelLogoutSettings `json:"oidc_backchannel_logout,omitempty" url:"-"`
	SessionTransfer       *ClientSessionTransferConfiguration  `json:"session_transfer,omitempty" url:"-"`
	// Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs.
	AllowedOrigins []string `json:"allowed_origins,omitempty" url:"-"`
	// Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>.
	WebOrigins []string `json:"web_origins,omitempty" url:"-"`
	// List of audiences/realms for SAML protocol. Used by the wsfed addon.
	ClientAliases []string `json:"client_aliases,omitempty" url:"-"`
	// List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed.
	AllowedClients []string `json:"allowed_clients,omitempty" url:"-"`
	// Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains.
	AllowedLogoutURLs []string `json:"allowed_logout_urls,omitempty" url:"-"`
	// List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, and `urn:ietf:params:oauth:grant-type:device_code`.
	GrantTypes              []string                           `json:"grant_types,omitempty" url:"-"`
	TokenEndpointAuthMethod *ClientTokenEndpointAuthMethodEnum `json:"token_endpoint_auth_method,omitempty" url:"-"`
	AppType                 *ClientAppTypeEnum                 `json:"app_type,omitempty" url:"-"`
	// Whether this client a first party client or not
	IsFirstParty *bool `json:"is_first_party,omitempty" url:"-"`
	// Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false).
	OidcConformant   *bool                   `json:"oidc_conformant,omitempty" url:"-"`
	JwtConfiguration *ClientJwtConfiguration `json:"jwt_configuration,omitempty" url:"-"`
	EncryptionKey    *ClientEncryptionKey    `json:"encryption_key,omitempty" url:"-"`
	// Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false).
	SSO *bool `json:"sso,omitempty" url:"-"`
	// Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false).
	CrossOriginAuthentication *bool `json:"cross_origin_authentication,omitempty" url:"-"`
	// URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page.
	CrossOriginLoc *string `json:"cross_origin_loc,omitempty" url:"-"`
	// <code>true</code> to disable Single Sign On, <code>false</code> otherwise (default: <code>false</code>)
	SSODisabled *bool `json:"sso_disabled,omitempty" url:"-"`
	// <code>true</code> if the custom login page is to be used, <code>false</code> otherwise. Defaults to <code>true</code>
	CustomLoginPageOn *bool `json:"custom_login_page_on,omitempty" url:"-"`
	// The content (HTML, CSS, JS) of the custom login page.
	CustomLoginPage *string `json:"custom_login_page,omitempty" url:"-"`
	// The content (HTML, CSS, JS) of the custom login page. (Used on Previews)
	CustomLoginPagePreview *string `json:"custom_login_page_preview,omitempty" url:"-"`
	// HTML form template to be used for WS-Federation.
	FormTemplate   *string         `json:"form_template,omitempty" url:"-"`
	Addons         *ClientAddons   `json:"addons,omitempty" url:"-"`
	ClientMetadata *ClientMetadata `json:"client_metadata,omitempty" url:"-"`
	Mobile         *ClientMobile   `json:"mobile,omitempty" url:"-"`
	// Initiate login uri, must be https
	InitiateLoginURI            *string                                `json:"initiate_login_uri,omitempty" url:"-"`
	NativeSocialLogin           *NativeSocialLogin                     `json:"native_social_login,omitempty" url:"-"`
	RefreshToken                *ClientRefreshTokenConfiguration       `json:"refresh_token,omitempty" url:"-"`
	DefaultOrganization         *ClientDefaultOrganization             `json:"default_organization,omitempty" url:"-"`
	OrganizationUsage           *ClientOrganizationUsageEnum           `json:"organization_usage,omitempty" url:"-"`
	OrganizationRequireBehavior *ClientOrganizationRequireBehaviorEnum `json:"organization_require_behavior,omitempty" url:"-"`
	ClientAuthenticationMethods *ClientCreateAuthenticationMethod      `json:"client_authentication_methods,omitempty" url:"-"`
	// Makes the use of Pushed Authorization Requests mandatory for this client
	RequirePushedAuthorizationRequests *bool `json:"require_pushed_authorization_requests,omitempty" url:"-"`
	// Makes the use of Proof-of-Possession mandatory for this client
	RequireProofOfPossession *bool                                   `json:"require_proof_of_possession,omitempty" url:"-"`
	SignedRequestObject      *ClientSignedRequestObjectWithPublicKey `json:"signed_request_object,omitempty" url:"-"`
	ComplianceLevel          *ClientComplianceLevelEnum              `json:"compliance_level,omitempty" url:"-"`
	// Specifies how long, in seconds, a Pushed Authorization Request URI remains valid
	ParRequestExpiry *int              `json:"par_request_expiry,omitempty" url:"-"`
	TokenQuota       *CreateTokenQuota `json:"token_quota,omitempty" url:"-"`
	// The identifier of the resource server that this client is linked to.
	ResourceServerIdentifier *string `json:"resource_server_identifier,omitempty" url:"-"`
}

type GetClientRequestParameters struct {
	// Comma-separated list of fields to include or exclude (based on value provided for include_fields) in the result. Leave empty to retrieve all fields.
	Fields *string `json:"-" url:"fields,omitempty"`
	// Whether specified fields are to be included (true) or excluded (false).
	IncludeFields *bool `json:"-" url:"include_fields,omitempty"`
}

type ListClientsRequestParameters struct {
	// Comma-separated list of fields to include or exclude (based on value provided for include_fields) in the result. Leave empty to retrieve all fields.
	Fields *string `json:"-" url:"fields,omitempty"`
	// Whether specified fields are to be included (true) or excluded (false).
	IncludeFields *bool `json:"-" url:"include_fields,omitempty"`
	// Page index of the results to return. First page is 0.
	Page *int `json:"-" url:"page,omitempty"`
	// Number of results per page. Default value is 50, maximum value is 100
	PerPage *int `json:"-" url:"per_page,omitempty"`
	// Return results inside an object that contains the total result count (true) or as a direct array of results (false, default).
	IncludeTotals *bool `json:"-" url:"include_totals,omitempty"`
	// Optional filter on the global client parameter.
	IsGlobal *bool `json:"-" url:"is_global,omitempty"`
	// Optional filter on whether or not a client is a first-party client.
	IsFirstParty *bool `json:"-" url:"is_first_party,omitempty"`
	// Optional filter by a comma-separated list of application types.
	AppType *string `json:"-" url:"app_type,omitempty"`
	// Advanced Query in <a href="http://www.lucenetutorial.com/lucene-query-syntax.html">Lucene</a> syntax.<br /><b>Permitted Queries</b>:<br /><ul><li><i>client_grant.organization_id:{organization_id}</i></li><li><i>client_grant.allow_any_organization:true</i></li></ul><b>Additional Restrictions</b>:<br /><ul><li>Cannot be used in combination with other filters</li><li>Requires use of the <i>from</i> and <i>take</i> paging parameters (checkpoint paginatinon)</li><li>Reduced rate limits apply. See <a href="https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/enterprise-public">Rate Limit Configurations</a></li></ul><i><b>Note</b>: Recent updates may not be immediately reflected in query results</i>
	Q *string `json:"-" url:"q,omitempty"`
}

type Client struct {
	// ID of this client.
	ClientID *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// Name of the tenant this client belongs to.
	Tenant *string `json:"tenant,omitempty" url:"tenant,omitempty"`
	// Name of this client (min length: 1 character, does not allow `<` or `>`).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Free text description of this client (max length: 140 characters).
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Whether this is your global 'All Applications' client representing legacy tenant settings (true) or a regular client (false).
	Global *bool `json:"global,omitempty" url:"global,omitempty"`
	// Client secret (which you must not make public).
	ClientSecret *string `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	// Type of client used to determine which settings are applicable. Can be `spa`, `native`, `non_interactive`, or `regular_web`.
	AppType *string `json:"app_type,omitempty" url:"app_type,omitempty"`
	// URL of the logo to display for this client. Recommended size is 150x150 pixels.
	LogoURI *string `json:"logo_uri,omitempty" url:"logo_uri,omitempty"`
	// Whether this client a first party client (true) or not (false).
	IsFirstParty *bool `json:"is_first_party,omitempty" url:"is_first_party,omitempty"`
	// Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false).
	OidcConformant *bool `json:"oidc_conformant,omitempty" url:"oidc_conformant,omitempty"`
	// Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication.
	Callbacks []string `json:"callbacks,omitempty" url:"callbacks,omitempty"`
	// Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs.
	AllowedOrigins []string `json:"allowed_origins,omitempty" url:"allowed_origins,omitempty"`
	// Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>.
	WebOrigins []string `json:"web_origins,omitempty" url:"web_origins,omitempty"`
	// List of audiences/realms for SAML protocol. Used by the wsfed addon.
	ClientAliases []string `json:"client_aliases,omitempty" url:"client_aliases,omitempty"`
	// List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed.
	AllowedClients []string `json:"allowed_clients,omitempty" url:"allowed_clients,omitempty"`
	// Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains.
	AllowedLogoutURLs []string                             `json:"allowed_logout_urls,omitempty" url:"allowed_logout_urls,omitempty"`
	SessionTransfer   *ClientSessionTransferConfiguration  `json:"session_transfer,omitempty" url:"session_transfer,omitempty"`
	OidcLogout        *ClientOidcBackchannelLogoutSettings `json:"oidc_logout,omitempty" url:"oidc_logout,omitempty"`
	// List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, and `urn:ietf:params:oauth:grant-type:device_code`.
	GrantTypes       []string                `json:"grant_types,omitempty" url:"grant_types,omitempty"`
	JwtConfiguration *ClientJwtConfiguration `json:"jwt_configuration,omitempty" url:"jwt_configuration,omitempty"`
	SigningKeys      *ClientSigningKeys      `json:"signing_keys,omitempty" url:"signing_keys,omitempty"`
	EncryptionKey    *ClientEncryptionKey    `json:"encryption_key,omitempty" url:"encryption_key,omitempty"`
	// Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false).
	SSO *bool `json:"sso,omitempty" url:"sso,omitempty"`
	// Whether Single Sign On is disabled (true) or enabled (true). Defaults to true.
	SSODisabled *bool `json:"sso_disabled,omitempty" url:"sso_disabled,omitempty"`
	// Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false).
	CrossOriginAuthentication *bool `json:"cross_origin_authentication,omitempty" url:"cross_origin_authentication,omitempty"`
	// URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page.
	CrossOriginLoc *string `json:"cross_origin_loc,omitempty" url:"cross_origin_loc,omitempty"`
	// Whether a custom login page is to be used (true) or the default provided login page (false).
	CustomLoginPageOn *bool `json:"custom_login_page_on,omitempty" url:"custom_login_page_on,omitempty"`
	// The content (HTML, CSS, JS) of the custom login page.
	CustomLoginPage *string `json:"custom_login_page,omitempty" url:"custom_login_page,omitempty"`
	// The content (HTML, CSS, JS) of the custom login page. (Used on Previews)
	CustomLoginPagePreview *string `json:"custom_login_page_preview,omitempty" url:"custom_login_page_preview,omitempty"`
	// HTML form template to be used for WS-Federation.
	FormTemplate            *string                            `json:"form_template,omitempty" url:"form_template,omitempty"`
	Addons                  *ClientAddons                      `json:"addons,omitempty" url:"addons,omitempty"`
	TokenEndpointAuthMethod *ClientTokenEndpointAuthMethodEnum `json:"token_endpoint_auth_method,omitempty" url:"token_endpoint_auth_method,omitempty"`
	ClientMetadata          *ClientMetadata                    `json:"client_metadata,omitempty" url:"client_metadata,omitempty"`
	Mobile                  *ClientMobile                      `json:"mobile,omitempty" url:"mobile,omitempty"`
	// Initiate login uri, must be https
	InitiateLoginURI            *string                                `json:"initiate_login_uri,omitempty" url:"initiate_login_uri,omitempty"`
	RefreshToken                *ClientRefreshTokenConfiguration       `json:"refresh_token,omitempty" url:"refresh_token,omitempty"`
	DefaultOrganization         *ClientDefaultOrganization             `json:"default_organization,omitempty" url:"default_organization,omitempty"`
	OrganizationUsage           *ClientOrganizationUsageEnum           `json:"organization_usage,omitempty" url:"organization_usage,omitempty"`
	OrganizationRequireBehavior *ClientOrganizationRequireBehaviorEnum `json:"organization_require_behavior,omitempty" url:"organization_require_behavior,omitempty"`
	ClientAuthenticationMethods *ClientAuthenticationMethod            `json:"client_authentication_methods,omitempty" url:"client_authentication_methods,omitempty"`
	// Makes the use of Pushed Authorization Requests mandatory for this client
	RequirePushedAuthorizationRequests *bool `json:"require_pushed_authorization_requests,omitempty" url:"require_pushed_authorization_requests,omitempty"`
	// Makes the use of Proof-of-Possession mandatory for this client
	RequireProofOfPossession *bool                                      `json:"require_proof_of_possession,omitempty" url:"require_proof_of_possession,omitempty"`
	SignedRequestObject      *ClientSignedRequestObjectWithCredentialID `json:"signed_request_object,omitempty" url:"signed_request_object,omitempty"`
	ComplianceLevel          *ClientComplianceLevelEnum                 `json:"compliance_level,omitempty" url:"compliance_level,omitempty"`
	// Specifies how long, in seconds, a Pushed Authorization Request URI remains valid
	ParRequestExpiry *int        `json:"par_request_expiry,omitempty" url:"par_request_expiry,omitempty"`
	TokenQuota       *TokenQuota `json:"token_quota,omitempty" url:"token_quota,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *Client) GetClientID() *string {
	if c == nil {
		return nil
	}
	return c.ClientID
}

func (c *Client) GetTenant() *string {
	if c == nil {
		return nil
	}
	return c.Tenant
}

func (c *Client) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *Client) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *Client) GetGlobal() *bool {
	if c == nil {
		return nil
	}
	return c.Global
}

func (c *Client) GetClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientSecret
}

func (c *Client) GetAppType() *string {
	if c == nil {
		return nil
	}
	return c.AppType
}

func (c *Client) GetLogoURI() *string {
	if c == nil {
		return nil
	}
	return c.LogoURI
}

func (c *Client) GetIsFirstParty() *bool {
	if c == nil {
		return nil
	}
	return c.IsFirstParty
}

func (c *Client) GetOidcConformant() *bool {
	if c == nil {
		return nil
	}
	return c.OidcConformant
}

func (c *Client) GetCallbacks() []string {
	if c == nil {
		return nil
	}
	return c.Callbacks
}

func (c *Client) GetAllowedOrigins() []string {
	if c == nil {
		return nil
	}
	return c.AllowedOrigins
}

func (c *Client) GetWebOrigins() []string {
	if c == nil {
		return nil
	}
	return c.WebOrigins
}

func (c *Client) GetClientAliases() []string {
	if c == nil {
		return nil
	}
	return c.ClientAliases
}

func (c *Client) GetAllowedClients() []string {
	if c == nil {
		return nil
	}
	return c.AllowedClients
}

func (c *Client) GetAllowedLogoutURLs() []string {
	if c == nil {
		return nil
	}
	return c.AllowedLogoutURLs
}

func (c *Client) GetSessionTransfer() *ClientSessionTransferConfiguration {
	if c == nil {
		return nil
	}
	return c.SessionTransfer
}

func (c *Client) GetOidcLogout() *ClientOidcBackchannelLogoutSettings {
	if c == nil {
		return nil
	}
	return c.OidcLogout
}

func (c *Client) GetGrantTypes() []string {
	if c == nil {
		return nil
	}
	return c.GrantTypes
}

func (c *Client) GetJwtConfiguration() *ClientJwtConfiguration {
	if c == nil {
		return nil
	}
	return c.JwtConfiguration
}

func (c *Client) GetSigningKeys() *ClientSigningKeys {
	if c == nil {
		return nil
	}
	return c.SigningKeys
}

func (c *Client) GetEncryptionKey() *ClientEncryptionKey {
	if c == nil {
		return nil
	}
	return c.EncryptionKey
}

func (c *Client) GetSSO() *bool {
	if c == nil {
		return nil
	}
	return c.SSO
}

func (c *Client) GetSSODisabled() *bool {
	if c == nil {
		return nil
	}
	return c.SSODisabled
}

func (c *Client) GetCrossOriginAuthentication() *bool {
	if c == nil {
		return nil
	}
	return c.CrossOriginAuthentication
}

func (c *Client) GetCrossOriginLoc() *string {
	if c == nil {
		return nil
	}
	return c.CrossOriginLoc
}

func (c *Client) GetCustomLoginPageOn() *bool {
	if c == nil {
		return nil
	}
	return c.CustomLoginPageOn
}

func (c *Client) GetCustomLoginPage() *string {
	if c == nil {
		return nil
	}
	return c.CustomLoginPage
}

func (c *Client) GetCustomLoginPagePreview() *string {
	if c == nil {
		return nil
	}
	return c.CustomLoginPagePreview
}

func (c *Client) GetFormTemplate() *string {
	if c == nil {
		return nil
	}
	return c.FormTemplate
}

func (c *Client) GetAddons() *ClientAddons {
	if c == nil {
		return nil
	}
	return c.Addons
}

func (c *Client) GetTokenEndpointAuthMethod() *ClientTokenEndpointAuthMethodEnum {
	if c == nil {
		return nil
	}
	return c.TokenEndpointAuthMethod
}

func (c *Client) GetClientMetadata() *ClientMetadata {
	if c == nil {
		return nil
	}
	return c.ClientMetadata
}

func (c *Client) GetMobile() *ClientMobile {
	if c == nil {
		return nil
	}
	return c.Mobile
}

func (c *Client) GetInitiateLoginURI() *string {
	if c == nil {
		return nil
	}
	return c.InitiateLoginURI
}

func (c *Client) GetRefreshToken() *ClientRefreshTokenConfiguration {
	if c == nil {
		return nil
	}
	return c.RefreshToken
}

func (c *Client) GetDefaultOrganization() *ClientDefaultOrganization {
	if c == nil {
		return nil
	}
	return c.DefaultOrganization
}

func (c *Client) GetOrganizationUsage() *ClientOrganizationUsageEnum {
	if c == nil {
		return nil
	}
	return c.OrganizationUsage
}

func (c *Client) GetOrganizationRequireBehavior() *ClientOrganizationRequireBehaviorEnum {
	if c == nil {
		return nil
	}
	return c.OrganizationRequireBehavior
}

func (c *Client) GetClientAuthenticationMethods() *ClientAuthenticationMethod {
	if c == nil {
		return nil
	}
	return c.ClientAuthenticationMethods
}

func (c *Client) GetRequirePushedAuthorizationRequests() *bool {
	if c == nil {
		return nil
	}
	return c.RequirePushedAuthorizationRequests
}

func (c *Client) GetRequireProofOfPossession() *bool {
	if c == nil {
		return nil
	}
	return c.RequireProofOfPossession
}

func (c *Client) GetSignedRequestObject() *ClientSignedRequestObjectWithCredentialID {
	if c == nil {
		return nil
	}
	return c.SignedRequestObject
}

func (c *Client) GetComplianceLevel() *ClientComplianceLevelEnum {
	if c == nil {
		return nil
	}
	return c.ComplianceLevel
}

func (c *Client) GetParRequestExpiry() *int {
	if c == nil {
		return nil
	}
	return c.ParRequestExpiry
}

func (c *Client) GetTokenQuota() *TokenQuota {
	if c == nil {
		return nil
	}
	return c.TokenQuota
}

func (c *Client) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *Client) UnmarshalJSON(data []byte) error {
	type embed Client
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Client(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Client) MarshalJSON() ([]byte, error) {
	type embed Client
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *Client) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// AWS addon configuration.
type ClientAddonAws struct {
	// AWS principal ARN, e.g. `arn:aws:iam::010616021751:saml-provider/idpname`
	Principal *string `json:"principal,omitempty" url:"principal,omitempty"`
	// AWS role ARN, e.g. `arn:aws:iam::010616021751:role/foo`
	Role *string `json:"role,omitempty" url:"role,omitempty"`
	// AWS token lifetime in seconds
	LifetimeInSeconds *int `json:"lifetime_in_seconds,omitempty" url:"lifetime_in_seconds,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonAws) GetPrincipal() *string {
	if c == nil {
		return nil
	}
	return c.Principal
}

func (c *ClientAddonAws) GetRole() *string {
	if c == nil {
		return nil
	}
	return c.Role
}

func (c *ClientAddonAws) GetLifetimeInSeconds() *int {
	if c == nil {
		return nil
	}
	return c.LifetimeInSeconds
}

func (c *ClientAddonAws) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonAws) UnmarshalJSON(data []byte) error {
	type embed ClientAddonAws
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonAws(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonAws) MarshalJSON() ([]byte, error) {
	type embed ClientAddonAws
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonAws) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Azure Blob Storage addon configuration.
type ClientAddonAzureBlob struct {
	// Your Azure storage account name. Usually first segment in your Azure storage URL. e.g. `https://acme-org.blob.core.windows.net` would be the account name `acme-org`.
	AccountName *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	// Access key associated with this storage account.
	StorageAccessKey *string `json:"storageAccessKey,omitempty" url:"storageAccessKey,omitempty"`
	// Container to request a token for. e.g. `my-container`.
	ContainerName *string `json:"containerName,omitempty" url:"containerName,omitempty"`
	// Entity to request a token for. e.g. `my-blob`. If blank the computed SAS will apply to the entire storage container.
	BlobName *string `json:"blobName,omitempty" url:"blobName,omitempty"`
	// Expiration in minutes for the generated token (default of 5 minutes).
	Expiration *int `json:"expiration,omitempty" url:"expiration,omitempty"`
	// Shared access policy identifier defined in your storage account resource.
	SignedIdentifier *string `json:"signedIdentifier,omitempty" url:"signedIdentifier,omitempty"`
	// Indicates if the issued token has permission to read the content, properties, metadata and block list. Use the blob as the source of a copy operation.
	BlobRead *bool `json:"blob_read,omitempty" url:"blob_read,omitempty"`
	// Indicates if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
	BlobWrite *bool `json:"blob_write,omitempty" url:"blob_write,omitempty"`
	// Indicates if the issued token has permission to delete the blob.
	BlobDelete *bool `json:"blob_delete,omitempty" url:"blob_delete,omitempty"`
	// Indicates if the issued token has permission to read the content, properties, metadata or block list of any blob in the container. Use any blob in the container as the source of a copy operation
	ContainerRead *bool `json:"container_read,omitempty" url:"container_read,omitempty"`
	// Indicates that for any blob in the container if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account.
	ContainerWrite *bool `json:"container_write,omitempty" url:"container_write,omitempty"`
	// Indicates if issued token has permission to delete any blob in the container.
	ContainerDelete *bool `json:"container_delete,omitempty" url:"container_delete,omitempty"`
	// Indicates if the issued token has permission to list blobs in the container.
	ContainerList *bool `json:"container_list,omitempty" url:"container_list,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonAzureBlob) GetAccountName() *string {
	if c == nil {
		return nil
	}
	return c.AccountName
}

func (c *ClientAddonAzureBlob) GetStorageAccessKey() *string {
	if c == nil {
		return nil
	}
	return c.StorageAccessKey
}

func (c *ClientAddonAzureBlob) GetContainerName() *string {
	if c == nil {
		return nil
	}
	return c.ContainerName
}

func (c *ClientAddonAzureBlob) GetBlobName() *string {
	if c == nil {
		return nil
	}
	return c.BlobName
}

func (c *ClientAddonAzureBlob) GetExpiration() *int {
	if c == nil {
		return nil
	}
	return c.Expiration
}

func (c *ClientAddonAzureBlob) GetSignedIdentifier() *string {
	if c == nil {
		return nil
	}
	return c.SignedIdentifier
}

func (c *ClientAddonAzureBlob) GetBlobRead() *bool {
	if c == nil {
		return nil
	}
	return c.BlobRead
}

func (c *ClientAddonAzureBlob) GetBlobWrite() *bool {
	if c == nil {
		return nil
	}
	return c.BlobWrite
}

func (c *ClientAddonAzureBlob) GetBlobDelete() *bool {
	if c == nil {
		return nil
	}
	return c.BlobDelete
}

func (c *ClientAddonAzureBlob) GetContainerRead() *bool {
	if c == nil {
		return nil
	}
	return c.ContainerRead
}

func (c *ClientAddonAzureBlob) GetContainerWrite() *bool {
	if c == nil {
		return nil
	}
	return c.ContainerWrite
}

func (c *ClientAddonAzureBlob) GetContainerDelete() *bool {
	if c == nil {
		return nil
	}
	return c.ContainerDelete
}

func (c *ClientAddonAzureBlob) GetContainerList() *bool {
	if c == nil {
		return nil
	}
	return c.ContainerList
}

func (c *ClientAddonAzureBlob) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonAzureBlob) UnmarshalJSON(data []byte) error {
	type embed ClientAddonAzureBlob
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonAzureBlob(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonAzureBlob) MarshalJSON() ([]byte, error) {
	type embed ClientAddonAzureBlob
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonAzureBlob) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Azure Storage Bus addon configuration.
type ClientAddonAzureSb struct {
	// Your Azure Service Bus namespace. Usually the first segment of your Service Bus URL (e.g. `https://acme-org.servicebus.windows.net` would be `acme-org`).
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// Your shared access policy name defined in your Service Bus entity.
	SasKeyName *string `json:"sasKeyName,omitempty" url:"sasKeyName,omitempty"`
	// Primary Key associated with your shared access policy.
	SasKey *string `json:"sasKey,omitempty" url:"sasKey,omitempty"`
	// Entity you want to request a token for. e.g. `my-queue`.'
	EntityPath *string `json:"entityPath,omitempty" url:"entityPath,omitempty"`
	// Optional expiration in minutes for the generated token. Defaults to 5 minutes.
	Expiration *int `json:"expiration,omitempty" url:"expiration,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonAzureSb) GetNamespace() *string {
	if c == nil {
		return nil
	}
	return c.Namespace
}

func (c *ClientAddonAzureSb) GetSasKeyName() *string {
	if c == nil {
		return nil
	}
	return c.SasKeyName
}

func (c *ClientAddonAzureSb) GetSasKey() *string {
	if c == nil {
		return nil
	}
	return c.SasKey
}

func (c *ClientAddonAzureSb) GetEntityPath() *string {
	if c == nil {
		return nil
	}
	return c.EntityPath
}

func (c *ClientAddonAzureSb) GetExpiration() *int {
	if c == nil {
		return nil
	}
	return c.Expiration
}

func (c *ClientAddonAzureSb) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonAzureSb) UnmarshalJSON(data []byte) error {
	type embed ClientAddonAzureSb
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonAzureSb(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonAzureSb) MarshalJSON() ([]byte, error) {
	type embed ClientAddonAzureSb
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonAzureSb) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Box SSO indicator (no configuration settings needed for Box SSO).
type ClientAddonBox = map[string]interface{}

// CloudBees SSO indicator (no configuration settings needed for CloudBees SSO).
type ClientAddonCloudBees = map[string]interface{}

// Concur SSO indicator (no configuration settings needed for Concur SSO).
type ClientAddonConcur = map[string]interface{}

// Dropbox SSO indicator (no configuration settings needed for Dropbox SSO).
type ClientAddonDropbox = map[string]interface{}

// Adobe EchoSign SSO configuration.
type ClientAddonEchoSign struct {
	// Your custom domain found in your EchoSign URL. e.g. `https://acme-org.echosign.com` would be `acme-org`.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonEchoSign) GetDomain() *string {
	if c == nil {
		return nil
	}
	return c.Domain
}

func (c *ClientAddonEchoSign) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonEchoSign) UnmarshalJSON(data []byte) error {
	type embed ClientAddonEchoSign
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonEchoSign(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonEchoSign) MarshalJSON() ([]byte, error) {
	type embed ClientAddonEchoSign
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonEchoSign) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Egnyte SSO configuration.
type ClientAddonEgnyte struct {
	// Your custom domain found in your Egnyte URL. e.g. `https://acme-org.egnyte.com` would be `acme-org`.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonEgnyte) GetDomain() *string {
	if c == nil {
		return nil
	}
	return c.Domain
}

func (c *ClientAddonEgnyte) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonEgnyte) UnmarshalJSON(data []byte) error {
	type embed ClientAddonEgnyte
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonEgnyte(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonEgnyte) MarshalJSON() ([]byte, error) {
	type embed ClientAddonEgnyte
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonEgnyte) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Google Firebase addon configuration.
type ClientAddonFirebase struct {
	// Google Firebase Secret. (SDK 2 only).
	Secret *string `json:"secret,omitempty" url:"secret,omitempty"`
	// Optional ID of the private key to obtain kid header in the issued token (SDK v3+ tokens only).
	PrivateKeyID *string `json:"private_key_id,omitempty" url:"private_key_id,omitempty"`
	// Private Key for signing the token (SDK v3+ tokens only).
	PrivateKey *string `json:"private_key,omitempty" url:"private_key,omitempty"`
	// ID of the Service Account you have created (shown as `client_email` in the generated JSON file, SDK v3+ tokens only).
	ClientEmail *string `json:"client_email,omitempty" url:"client_email,omitempty"`
	// Optional expiration in seconds for the generated token. Defaults to 3600 seconds (SDK v3+ tokens only).
	LifetimeInSeconds *int `json:"lifetime_in_seconds,omitempty" url:"lifetime_in_seconds,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonFirebase) GetSecret() *string {
	if c == nil {
		return nil
	}
	return c.Secret
}

func (c *ClientAddonFirebase) GetPrivateKeyID() *string {
	if c == nil {
		return nil
	}
	return c.PrivateKeyID
}

func (c *ClientAddonFirebase) GetPrivateKey() *string {
	if c == nil {
		return nil
	}
	return c.PrivateKey
}

func (c *ClientAddonFirebase) GetClientEmail() *string {
	if c == nil {
		return nil
	}
	return c.ClientEmail
}

func (c *ClientAddonFirebase) GetLifetimeInSeconds() *int {
	if c == nil {
		return nil
	}
	return c.LifetimeInSeconds
}

func (c *ClientAddonFirebase) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonFirebase) UnmarshalJSON(data []byte) error {
	type embed ClientAddonFirebase
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonFirebase(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonFirebase) MarshalJSON() ([]byte, error) {
	type embed ClientAddonFirebase
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonFirebase) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Layer addon configuration.
type ClientAddonLayer struct {
	// Provider ID of your Layer account
	ProviderID string `json:"providerId" url:"providerId"`
	// Authentication Key identifier used to sign the Layer token.
	KeyID string `json:"keyId" url:"keyId"`
	// Private key for signing the Layer token.
	PrivateKey string `json:"privateKey" url:"privateKey"`
	// Name of the property used as the unique user id in Layer. If not specified `user_id` is used.
	Principal *string `json:"principal,omitempty" url:"principal,omitempty"`
	// Optional expiration in minutes for the generated token. Defaults to 5 minutes.
	Expiration *int `json:"expiration,omitempty" url:"expiration,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonLayer) GetProviderID() string {
	if c == nil {
		return ""
	}
	return c.ProviderID
}

func (c *ClientAddonLayer) GetKeyID() string {
	if c == nil {
		return ""
	}
	return c.KeyID
}

func (c *ClientAddonLayer) GetPrivateKey() string {
	if c == nil {
		return ""
	}
	return c.PrivateKey
}

func (c *ClientAddonLayer) GetPrincipal() *string {
	if c == nil {
		return nil
	}
	return c.Principal
}

func (c *ClientAddonLayer) GetExpiration() *int {
	if c == nil {
		return nil
	}
	return c.Expiration
}

func (c *ClientAddonLayer) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonLayer) UnmarshalJSON(data []byte) error {
	type embed ClientAddonLayer
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonLayer(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonLayer) MarshalJSON() ([]byte, error) {
	type embed ClientAddonLayer
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonLayer) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Microsoft Dynamics CRM SSO configuration.
type ClientAddonMscrm struct {
	// Microsoft Dynamics CRM application URL.
	URL string `json:"url" url:"url"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonMscrm) GetURL() string {
	if c == nil {
		return ""
	}
	return c.URL
}

func (c *ClientAddonMscrm) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonMscrm) UnmarshalJSON(data []byte) error {
	type embed ClientAddonMscrm
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonMscrm(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonMscrm) MarshalJSON() ([]byte, error) {
	type embed ClientAddonMscrm
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonMscrm) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// New Relic SSO configuration.
type ClientAddonNewRelic struct {
	// Your New Relic Account ID found in your New Relic URL after the `/accounts/` path. e.g. `https://rpm.newrelic.com/accounts/123456/query` would be `123456`.
	Account *string `json:"account,omitempty" url:"account,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonNewRelic) GetAccount() *string {
	if c == nil {
		return nil
	}
	return c.Account
}

func (c *ClientAddonNewRelic) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonNewRelic) UnmarshalJSON(data []byte) error {
	type embed ClientAddonNewRelic
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonNewRelic(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonNewRelic) MarshalJSON() ([]byte, error) {
	type embed ClientAddonNewRelic
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonNewRelic) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Okta Access Gateway SSO configuration
type ClientAddonOag struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientAddonOag) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientAddonOag) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientAddonOag
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientAddonOag(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonOag) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Microsoft Office 365 SSO configuration.
type ClientAddonOffice365 struct {
	// Your Office 365 domain name. e.g. `acme-org.com`.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// Optional Auth0 database connection for testing an already-configured Office 365 tenant.
	Connection *string `json:"connection,omitempty" url:"connection,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonOffice365) GetDomain() *string {
	if c == nil {
		return nil
	}
	return c.Domain
}

func (c *ClientAddonOffice365) GetConnection() *string {
	if c == nil {
		return nil
	}
	return c.Connection
}

func (c *ClientAddonOffice365) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonOffice365) UnmarshalJSON(data []byte) error {
	type embed ClientAddonOffice365
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonOffice365(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonOffice365) MarshalJSON() ([]byte, error) {
	type embed ClientAddonOffice365
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonOffice365) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Active Directory Rights Management Service SSO configuration.
type ClientAddonRms struct {
	// URL of your Rights Management Server. It can be internal or external, but users will have to be able to reach it.
	URL string `json:"url" url:"url"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonRms) GetURL() string {
	if c == nil {
		return ""
	}
	return c.URL
}

func (c *ClientAddonRms) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonRms) UnmarshalJSON(data []byte) error {
	type embed ClientAddonRms
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonRms(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonRms) MarshalJSON() ([]byte, error) {
	type embed ClientAddonRms
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonRms) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Salesforce SSO configuration.
type ClientAddonSalesforce struct {
	// Arbitrary logical URL that identifies the Saleforce resource. e.g. `https://acme-org.com`.
	EntityID *string `json:"entity_id,omitempty" url:"entity_id,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonSalesforce) GetEntityID() *string {
	if c == nil {
		return nil
	}
	return c.EntityID
}

func (c *ClientAddonSalesforce) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonSalesforce) UnmarshalJSON(data []byte) error {
	type embed ClientAddonSalesforce
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonSalesforce(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonSalesforce) MarshalJSON() ([]byte, error) {
	type embed ClientAddonSalesforce
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonSalesforce) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Salesforce API addon configuration.
type ClientAddonSalesforceAPI struct {
	// Consumer Key assigned by Salesforce to the Connected App.
	Clientid *string `json:"clientid,omitempty" url:"clientid,omitempty"`
	// Name of the property in the user object that maps to a Salesforce username. e.g. `email`.
	Principal *string `json:"principal,omitempty" url:"principal,omitempty"`
	// Community name.
	CommunityName *string `json:"communityName,omitempty" url:"communityName,omitempty"`
	// Community url section.
	CommunityURLSection *string `json:"community_url_section,omitempty" url:"community_url_section,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonSalesforceAPI) GetClientid() *string {
	if c == nil {
		return nil
	}
	return c.Clientid
}

func (c *ClientAddonSalesforceAPI) GetPrincipal() *string {
	if c == nil {
		return nil
	}
	return c.Principal
}

func (c *ClientAddonSalesforceAPI) GetCommunityName() *string {
	if c == nil {
		return nil
	}
	return c.CommunityName
}

func (c *ClientAddonSalesforceAPI) GetCommunityURLSection() *string {
	if c == nil {
		return nil
	}
	return c.CommunityURLSection
}

func (c *ClientAddonSalesforceAPI) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonSalesforceAPI) UnmarshalJSON(data []byte) error {
	type embed ClientAddonSalesforceAPI
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonSalesforceAPI(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonSalesforceAPI) MarshalJSON() ([]byte, error) {
	type embed ClientAddonSalesforceAPI
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonSalesforceAPI) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Salesforce Sandbox addon configuration.
type ClientAddonSalesforceSandboxAPI struct {
	// Consumer Key assigned by Salesforce to the Connected App.
	Clientid *string `json:"clientid,omitempty" url:"clientid,omitempty"`
	// Name of the property in the user object that maps to a Salesforce username. e.g. `email`.
	Principal *string `json:"principal,omitempty" url:"principal,omitempty"`
	// Community name.
	CommunityName *string `json:"communityName,omitempty" url:"communityName,omitempty"`
	// Community url section.
	CommunityURLSection *string `json:"community_url_section,omitempty" url:"community_url_section,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonSalesforceSandboxAPI) GetClientid() *string {
	if c == nil {
		return nil
	}
	return c.Clientid
}

func (c *ClientAddonSalesforceSandboxAPI) GetPrincipal() *string {
	if c == nil {
		return nil
	}
	return c.Principal
}

func (c *ClientAddonSalesforceSandboxAPI) GetCommunityName() *string {
	if c == nil {
		return nil
	}
	return c.CommunityName
}

func (c *ClientAddonSalesforceSandboxAPI) GetCommunityURLSection() *string {
	if c == nil {
		return nil
	}
	return c.CommunityURLSection
}

func (c *ClientAddonSalesforceSandboxAPI) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonSalesforceSandboxAPI) UnmarshalJSON(data []byte) error {
	type embed ClientAddonSalesforceSandboxAPI
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonSalesforceSandboxAPI(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonSalesforceSandboxAPI) MarshalJSON() ([]byte, error) {
	type embed ClientAddonSalesforceSandboxAPI
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonSalesforceSandboxAPI) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// SAML2 addon indicator (no configuration settings needed for SAML2 addon).
type ClientAddonSAML struct {
	Mappings                       *ClientAddonSAMLMapping `json:"mappings,omitempty" url:"mappings,omitempty"`
	Audience                       *string                 `json:"audience,omitempty" url:"audience,omitempty"`
	Recipient                      *string                 `json:"recipient,omitempty" url:"recipient,omitempty"`
	CreateUpnClaim                 *bool                   `json:"createUpnClaim,omitempty" url:"createUpnClaim,omitempty"`
	MapUnknownClaimsAsIs           *bool                   `json:"mapUnknownClaimsAsIs,omitempty" url:"mapUnknownClaimsAsIs,omitempty"`
	PassthroughClaimsWithNoMapping *bool                   `json:"passthroughClaimsWithNoMapping,omitempty" url:"passthroughClaimsWithNoMapping,omitempty"`
	MapIdentities                  *bool                   `json:"mapIdentities,omitempty" url:"mapIdentities,omitempty"`
	SignatureAlgorithm             *string                 `json:"signatureAlgorithm,omitempty" url:"signatureAlgorithm,omitempty"`
	DigestAlgorithm                *string                 `json:"digestAlgorithm,omitempty" url:"digestAlgorithm,omitempty"`
	Issuer                         *string                 `json:"issuer,omitempty" url:"issuer,omitempty"`
	Destination                    *string                 `json:"destination,omitempty" url:"destination,omitempty"`
	LifetimeInSeconds              *int                    `json:"lifetimeInSeconds,omitempty" url:"lifetimeInSeconds,omitempty"`
	SignResponse                   *bool                   `json:"signResponse,omitempty" url:"signResponse,omitempty"`
	NameIdentifierFormat           *string                 `json:"nameIdentifierFormat,omitempty" url:"nameIdentifierFormat,omitempty"`
	NameIdentifierProbes           []string                `json:"nameIdentifierProbes,omitempty" url:"nameIdentifierProbes,omitempty"`
	AuthnContextClassRef           *string                 `json:"authnContextClassRef,omitempty" url:"authnContextClassRef,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonSAML) GetMappings() *ClientAddonSAMLMapping {
	if c == nil {
		return nil
	}
	return c.Mappings
}

func (c *ClientAddonSAML) GetAudience() *string {
	if c == nil {
		return nil
	}
	return c.Audience
}

func (c *ClientAddonSAML) GetRecipient() *string {
	if c == nil {
		return nil
	}
	return c.Recipient
}

func (c *ClientAddonSAML) GetCreateUpnClaim() *bool {
	if c == nil {
		return nil
	}
	return c.CreateUpnClaim
}

func (c *ClientAddonSAML) GetMapUnknownClaimsAsIs() *bool {
	if c == nil {
		return nil
	}
	return c.MapUnknownClaimsAsIs
}

func (c *ClientAddonSAML) GetPassthroughClaimsWithNoMapping() *bool {
	if c == nil {
		return nil
	}
	return c.PassthroughClaimsWithNoMapping
}

func (c *ClientAddonSAML) GetMapIdentities() *bool {
	if c == nil {
		return nil
	}
	return c.MapIdentities
}

func (c *ClientAddonSAML) GetSignatureAlgorithm() *string {
	if c == nil {
		return nil
	}
	return c.SignatureAlgorithm
}

func (c *ClientAddonSAML) GetDigestAlgorithm() *string {
	if c == nil {
		return nil
	}
	return c.DigestAlgorithm
}

func (c *ClientAddonSAML) GetIssuer() *string {
	if c == nil {
		return nil
	}
	return c.Issuer
}

func (c *ClientAddonSAML) GetDestination() *string {
	if c == nil {
		return nil
	}
	return c.Destination
}

func (c *ClientAddonSAML) GetLifetimeInSeconds() *int {
	if c == nil {
		return nil
	}
	return c.LifetimeInSeconds
}

func (c *ClientAddonSAML) GetSignResponse() *bool {
	if c == nil {
		return nil
	}
	return c.SignResponse
}

func (c *ClientAddonSAML) GetNameIdentifierFormat() *string {
	if c == nil {
		return nil
	}
	return c.NameIdentifierFormat
}

func (c *ClientAddonSAML) GetNameIdentifierProbes() []string {
	if c == nil {
		return nil
	}
	return c.NameIdentifierProbes
}

func (c *ClientAddonSAML) GetAuthnContextClassRef() *string {
	if c == nil {
		return nil
	}
	return c.AuthnContextClassRef
}

func (c *ClientAddonSAML) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonSAML) UnmarshalJSON(data []byte) error {
	type embed ClientAddonSAML
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonSAML(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonSAML) MarshalJSON() ([]byte, error) {
	type embed ClientAddonSAML
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonSAML) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientAddonSAMLMapping = map[string]interface{}

// SAP API addon configuration.
type ClientAddonSapapi struct {
	// If activated in the OAuth 2.0 client configuration (transaction SOAUTH2) the SAML attribute client_id must be set and equal the client_id form parameter of the access token request.
	Clientid *string `json:"clientid,omitempty" url:"clientid,omitempty"`
	// Name of the property in the user object that maps to a SAP username. e.g. `email`.
	UsernameAttribute *string `json:"usernameAttribute,omitempty" url:"usernameAttribute,omitempty"`
	// Your SAP OData server OAuth2 token endpoint URL.
	TokenEndpointURL *string `json:"tokenEndpointUrl,omitempty" url:"tokenEndpointUrl,omitempty"`
	// Requested scope for SAP APIs.
	Scope *string `json:"scope,omitempty" url:"scope,omitempty"`
	// Service account password to use to authenticate API calls to the token endpoint.
	ServicePassword *string `json:"servicePassword,omitempty" url:"servicePassword,omitempty"`
	// NameID element of the Subject which can be used to express the user's identity. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.
	NameIdentifierFormat *string `json:"nameIdentifierFormat,omitempty" url:"nameIdentifierFormat,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonSapapi) GetClientid() *string {
	if c == nil {
		return nil
	}
	return c.Clientid
}

func (c *ClientAddonSapapi) GetUsernameAttribute() *string {
	if c == nil {
		return nil
	}
	return c.UsernameAttribute
}

func (c *ClientAddonSapapi) GetTokenEndpointURL() *string {
	if c == nil {
		return nil
	}
	return c.TokenEndpointURL
}

func (c *ClientAddonSapapi) GetScope() *string {
	if c == nil {
		return nil
	}
	return c.Scope
}

func (c *ClientAddonSapapi) GetServicePassword() *string {
	if c == nil {
		return nil
	}
	return c.ServicePassword
}

func (c *ClientAddonSapapi) GetNameIdentifierFormat() *string {
	if c == nil {
		return nil
	}
	return c.NameIdentifierFormat
}

func (c *ClientAddonSapapi) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonSapapi) UnmarshalJSON(data []byte) error {
	type embed ClientAddonSapapi
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonSapapi(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonSapapi) MarshalJSON() ([]byte, error) {
	type embed ClientAddonSapapi
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonSapapi) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Sentry SSO configuration.
type ClientAddonSentry struct {
	// Generated slug for your Sentry organization. Found in your Sentry URL. e.g. `https://sentry.acme.com/acme-org/` would be `acme-org`.
	OrgSlug *string `json:"org_slug,omitempty" url:"org_slug,omitempty"`
	// URL prefix only if running Sentry Community Edition, otherwise leave should be blank.
	BaseURL *string `json:"base_url,omitempty" url:"base_url,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonSentry) GetOrgSlug() *string {
	if c == nil {
		return nil
	}
	return c.OrgSlug
}

func (c *ClientAddonSentry) GetBaseURL() *string {
	if c == nil {
		return nil
	}
	return c.BaseURL
}

func (c *ClientAddonSentry) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonSentry) UnmarshalJSON(data []byte) error {
	type embed ClientAddonSentry
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonSentry(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonSentry) MarshalJSON() ([]byte, error) {
	type embed ClientAddonSentry
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonSentry) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// SharePoint SSO configuration.
type ClientAddonSharePoint struct {
	// Internal SharePoint application URL.
	URL         *string                           `json:"url,omitempty" url:"url,omitempty"`
	ExternalURL *ClientAddonSharePointExternalURL `json:"external_url,omitempty" url:"external_url,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonSharePoint) GetURL() *string {
	if c == nil {
		return nil
	}
	return c.URL
}

func (c *ClientAddonSharePoint) GetExternalURL() *ClientAddonSharePointExternalURL {
	if c == nil {
		return nil
	}
	return c.ExternalURL
}

func (c *ClientAddonSharePoint) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonSharePoint) UnmarshalJSON(data []byte) error {
	type embed ClientAddonSharePoint
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonSharePoint(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonSharePoint) MarshalJSON() ([]byte, error) {
	type embed ClientAddonSharePoint
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonSharePoint) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// External SharePoint application URLs if exposed to the Internet.
type ClientAddonSharePointExternalURL struct {
	StringList []string
	String     string

	typ string
}

func (c *ClientAddonSharePointExternalURL) GetStringList() []string {
	if c == nil {
		return nil
	}
	return c.StringList
}

func (c *ClientAddonSharePointExternalURL) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *ClientAddonSharePointExternalURL) UnmarshalJSON(data []byte) error {
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typ = "StringList"
		c.StringList = valueStringList
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientAddonSharePointExternalURL) MarshalJSON() ([]byte, error) {
	if c.typ == "StringList" || c.StringList != nil {
		return json.Marshal(c.StringList)
	}
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientAddonSharePointExternalURLVisitor interface {
	VisitStringList([]string) error
	VisitString(string) error
}

func (c *ClientAddonSharePointExternalURL) Accept(visitor ClientAddonSharePointExternalURLVisitor) error {
	if c.typ == "StringList" || c.StringList != nil {
		return visitor.VisitStringList(c.StringList)
	}
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Slack team or workspace name usually first segment in your Slack URL. e.g. `https://acme-org.slack.com` would be `acme-org`.
type ClientAddonSlack struct {
	// Slack team name.
	Team string `json:"team" url:"team"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonSlack) GetTeam() string {
	if c == nil {
		return ""
	}
	return c.Team
}

func (c *ClientAddonSlack) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonSlack) UnmarshalJSON(data []byte) error {
	type embed ClientAddonSlack
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonSlack(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonSlack) MarshalJSON() ([]byte, error) {
	type embed ClientAddonSlack
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonSlack) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// SpringCM SSO configuration.
type ClientAddonSpringCm struct {
	// SpringCM ACS URL, e.g. `https://na11.springcm.com/atlas/sso/SSOEndpoint.ashx`.
	Acsurl *string `json:"acsurl,omitempty" url:"acsurl,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonSpringCm) GetAcsurl() *string {
	if c == nil {
		return nil
	}
	return c.Acsurl
}

func (c *ClientAddonSpringCm) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonSpringCm) UnmarshalJSON(data []byte) error {
	type embed ClientAddonSpringCm
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonSpringCm(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonSpringCm) MarshalJSON() ([]byte, error) {
	type embed ClientAddonSpringCm
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonSpringCm) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientAddonSSOIntegration struct {
	// SSO integration name
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// SSO integration version installed
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonSSOIntegration) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ClientAddonSSOIntegration) GetVersion() *string {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *ClientAddonSSOIntegration) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonSSOIntegration) UnmarshalJSON(data []byte) error {
	type embed ClientAddonSSOIntegration
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonSSOIntegration(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonSSOIntegration) MarshalJSON() ([]byte, error) {
	type embed ClientAddonSSOIntegration
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonSSOIntegration) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Windows Azure Mobile Services addon configuration.
type ClientAddonWams struct {
	// Your master key for Windows Azure Mobile Services.
	Masterkey *string `json:"masterkey,omitempty" url:"masterkey,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonWams) GetMasterkey() *string {
	if c == nil {
		return nil
	}
	return c.Masterkey
}

func (c *ClientAddonWams) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonWams) UnmarshalJSON(data []byte) error {
	type embed ClientAddonWams
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonWams(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonWams) MarshalJSON() ([]byte, error) {
	type embed ClientAddonWams
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonWams) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// WS-Fed (WIF) addon indicator. Actual configuration is stored in `callback` and `client_aliases` properties on the client.
type ClientAddonWsFed = map[string]interface{}

// Zendesk SSO configuration.
type ClientAddonZendesk struct {
	// Zendesk account name usually first segment in your Zendesk URL. e.g. `https://acme-org.zendesk.com` would be `acme-org`.
	AccountName *string `json:"accountName,omitempty" url:"accountName,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonZendesk) GetAccountName() *string {
	if c == nil {
		return nil
	}
	return c.AccountName
}

func (c *ClientAddonZendesk) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonZendesk) UnmarshalJSON(data []byte) error {
	type embed ClientAddonZendesk
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonZendesk(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonZendesk) MarshalJSON() ([]byte, error) {
	type embed ClientAddonZendesk
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonZendesk) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Zoom SSO configuration.
type ClientAddonZoom struct {
	// Zoom account name usually first segment of your Zoom URL, e.g. `https://acme-org.zoom.us` would be `acme-org`.
	Account *string `json:"account,omitempty" url:"account,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientAddonZoom) GetAccount() *string {
	if c == nil {
		return nil
	}
	return c.Account
}

func (c *ClientAddonZoom) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientAddonZoom) UnmarshalJSON(data []byte) error {
	type embed ClientAddonZoom
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientAddonZoom(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddonZoom) MarshalJSON() ([]byte, error) {
	type embed ClientAddonZoom
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientAddonZoom) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Addons enabled for this client and their associated configurations.
type ClientAddons struct {
	Aws                  *ClientAddonAws                  `json:"aws,omitempty" url:"aws,omitempty"`
	AzureBlob            *ClientAddonAzureBlob            `json:"azure_blob,omitempty" url:"azure_blob,omitempty"`
	AzureSb              *ClientAddonAzureSb              `json:"azure_sb,omitempty" url:"azure_sb,omitempty"`
	Rms                  *ClientAddonRms                  `json:"rms,omitempty" url:"rms,omitempty"`
	Mscrm                *ClientAddonMscrm                `json:"mscrm,omitempty" url:"mscrm,omitempty"`
	Slack                *ClientAddonSlack                `json:"slack,omitempty" url:"slack,omitempty"`
	Sentry               *ClientAddonSentry               `json:"sentry,omitempty" url:"sentry,omitempty"`
	Box                  *ClientAddonBox                  `json:"box,omitempty" url:"box,omitempty"`
	Cloudbees            *ClientAddonCloudBees            `json:"cloudbees,omitempty" url:"cloudbees,omitempty"`
	Concur               *ClientAddonConcur               `json:"concur,omitempty" url:"concur,omitempty"`
	Dropbox              *ClientAddonDropbox              `json:"dropbox,omitempty" url:"dropbox,omitempty"`
	Echosign             *ClientAddonEchoSign             `json:"echosign,omitempty" url:"echosign,omitempty"`
	Egnyte               *ClientAddonEgnyte               `json:"egnyte,omitempty" url:"egnyte,omitempty"`
	Firebase             *ClientAddonFirebase             `json:"firebase,omitempty" url:"firebase,omitempty"`
	Newrelic             *ClientAddonNewRelic             `json:"newrelic,omitempty" url:"newrelic,omitempty"`
	Office365            *ClientAddonOffice365            `json:"office365,omitempty" url:"office365,omitempty"`
	Salesforce           *ClientAddonSalesforce           `json:"salesforce,omitempty" url:"salesforce,omitempty"`
	SalesforceAPI        *ClientAddonSalesforceAPI        `json:"salesforce_api,omitempty" url:"salesforce_api,omitempty"`
	SalesforceSandboxAPI *ClientAddonSalesforceSandboxAPI `json:"salesforce_sandbox_api,omitempty" url:"salesforce_sandbox_api,omitempty"`
	Samlp                *ClientAddonSAML                 `json:"samlp,omitempty" url:"samlp,omitempty"`
	Layer                *ClientAddonLayer                `json:"layer,omitempty" url:"layer,omitempty"`
	SapAPI               *ClientAddonSapapi               `json:"sap_api,omitempty" url:"sap_api,omitempty"`
	Sharepoint           *ClientAddonSharePoint           `json:"sharepoint,omitempty" url:"sharepoint,omitempty"`
	Springcm             *ClientAddonSpringCm             `json:"springcm,omitempty" url:"springcm,omitempty"`
	Wams                 *ClientAddonWams                 `json:"wams,omitempty" url:"wams,omitempty"`
	Wsfed                *ClientAddonWsFed                `json:"wsfed,omitempty" url:"wsfed,omitempty"`
	Zendesk              *ClientAddonZendesk              `json:"zendesk,omitempty" url:"zendesk,omitempty"`
	Zoom                 *ClientAddonZoom                 `json:"zoom,omitempty" url:"zoom,omitempty"`
	SSOIntegration       *ClientAddonSSOIntegration       `json:"sso_integration,omitempty" url:"sso_integration,omitempty"`
	Oag                  *ClientAddonOag                  `json:"oag,omitempty" url:"oag,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientAddons) GetAws() *ClientAddonAws {
	if c == nil {
		return nil
	}
	return c.Aws
}

func (c *ClientAddons) GetAzureBlob() *ClientAddonAzureBlob {
	if c == nil {
		return nil
	}
	return c.AzureBlob
}

func (c *ClientAddons) GetAzureSb() *ClientAddonAzureSb {
	if c == nil {
		return nil
	}
	return c.AzureSb
}

func (c *ClientAddons) GetRms() *ClientAddonRms {
	if c == nil {
		return nil
	}
	return c.Rms
}

func (c *ClientAddons) GetMscrm() *ClientAddonMscrm {
	if c == nil {
		return nil
	}
	return c.Mscrm
}

func (c *ClientAddons) GetSlack() *ClientAddonSlack {
	if c == nil {
		return nil
	}
	return c.Slack
}

func (c *ClientAddons) GetSentry() *ClientAddonSentry {
	if c == nil {
		return nil
	}
	return c.Sentry
}

func (c *ClientAddons) GetBox() *ClientAddonBox {
	if c == nil {
		return nil
	}
	return c.Box
}

func (c *ClientAddons) GetCloudbees() *ClientAddonCloudBees {
	if c == nil {
		return nil
	}
	return c.Cloudbees
}

func (c *ClientAddons) GetConcur() *ClientAddonConcur {
	if c == nil {
		return nil
	}
	return c.Concur
}

func (c *ClientAddons) GetDropbox() *ClientAddonDropbox {
	if c == nil {
		return nil
	}
	return c.Dropbox
}

func (c *ClientAddons) GetEchosign() *ClientAddonEchoSign {
	if c == nil {
		return nil
	}
	return c.Echosign
}

func (c *ClientAddons) GetEgnyte() *ClientAddonEgnyte {
	if c == nil {
		return nil
	}
	return c.Egnyte
}

func (c *ClientAddons) GetFirebase() *ClientAddonFirebase {
	if c == nil {
		return nil
	}
	return c.Firebase
}

func (c *ClientAddons) GetNewrelic() *ClientAddonNewRelic {
	if c == nil {
		return nil
	}
	return c.Newrelic
}

func (c *ClientAddons) GetOffice365() *ClientAddonOffice365 {
	if c == nil {
		return nil
	}
	return c.Office365
}

func (c *ClientAddons) GetSalesforce() *ClientAddonSalesforce {
	if c == nil {
		return nil
	}
	return c.Salesforce
}

func (c *ClientAddons) GetSalesforceAPI() *ClientAddonSalesforceAPI {
	if c == nil {
		return nil
	}
	return c.SalesforceAPI
}

func (c *ClientAddons) GetSalesforceSandboxAPI() *ClientAddonSalesforceSandboxAPI {
	if c == nil {
		return nil
	}
	return c.SalesforceSandboxAPI
}

func (c *ClientAddons) GetSamlp() *ClientAddonSAML {
	if c == nil {
		return nil
	}
	return c.Samlp
}

func (c *ClientAddons) GetLayer() *ClientAddonLayer {
	if c == nil {
		return nil
	}
	return c.Layer
}

func (c *ClientAddons) GetSapAPI() *ClientAddonSapapi {
	if c == nil {
		return nil
	}
	return c.SapAPI
}

func (c *ClientAddons) GetSharepoint() *ClientAddonSharePoint {
	if c == nil {
		return nil
	}
	return c.Sharepoint
}

func (c *ClientAddons) GetSpringcm() *ClientAddonSpringCm {
	if c == nil {
		return nil
	}
	return c.Springcm
}

func (c *ClientAddons) GetWams() *ClientAddonWams {
	if c == nil {
		return nil
	}
	return c.Wams
}

func (c *ClientAddons) GetWsfed() *ClientAddonWsFed {
	if c == nil {
		return nil
	}
	return c.Wsfed
}

func (c *ClientAddons) GetZendesk() *ClientAddonZendesk {
	if c == nil {
		return nil
	}
	return c.Zendesk
}

func (c *ClientAddons) GetZoom() *ClientAddonZoom {
	if c == nil {
		return nil
	}
	return c.Zoom
}

func (c *ClientAddons) GetSSOIntegration() *ClientAddonSSOIntegration {
	if c == nil {
		return nil
	}
	return c.SSOIntegration
}

func (c *ClientAddons) GetOag() *ClientAddonOag {
	if c == nil {
		return nil
	}
	return c.Oag
}

func (c *ClientAddons) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientAddons) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientAddons
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientAddons(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAddons) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Type of client used to determine which settings are applicable. Can be `spa`, `native`, `non_interactive`, `regular_web` or `resource_server`.
type ClientAppTypeEnum string

const (
	ClientAppTypeEnumNative               ClientAppTypeEnum = "native"
	ClientAppTypeEnumSpa                  ClientAppTypeEnum = "spa"
	ClientAppTypeEnumRegularWeb           ClientAppTypeEnum = "regular_web"
	ClientAppTypeEnumNonInteractive       ClientAppTypeEnum = "non_interactive"
	ClientAppTypeEnumResourceServer       ClientAppTypeEnum = "resource_server"
	ClientAppTypeEnumExpressConfiguration ClientAppTypeEnum = "express_configuration"
	ClientAppTypeEnumRms                  ClientAppTypeEnum = "rms"
	ClientAppTypeEnumBox                  ClientAppTypeEnum = "box"
	ClientAppTypeEnumCloudbees            ClientAppTypeEnum = "cloudbees"
	ClientAppTypeEnumConcur               ClientAppTypeEnum = "concur"
	ClientAppTypeEnumDropbox              ClientAppTypeEnum = "dropbox"
	ClientAppTypeEnumMscrm                ClientAppTypeEnum = "mscrm"
	ClientAppTypeEnumEchosign             ClientAppTypeEnum = "echosign"
	ClientAppTypeEnumEgnyte               ClientAppTypeEnum = "egnyte"
	ClientAppTypeEnumNewrelic             ClientAppTypeEnum = "newrelic"
	ClientAppTypeEnumOffice365            ClientAppTypeEnum = "office365"
	ClientAppTypeEnumSalesforce           ClientAppTypeEnum = "salesforce"
	ClientAppTypeEnumSentry               ClientAppTypeEnum = "sentry"
	ClientAppTypeEnumSharepoint           ClientAppTypeEnum = "sharepoint"
	ClientAppTypeEnumSlack                ClientAppTypeEnum = "slack"
	ClientAppTypeEnumSpringcm             ClientAppTypeEnum = "springcm"
	ClientAppTypeEnumZendesk              ClientAppTypeEnum = "zendesk"
	ClientAppTypeEnumZoom                 ClientAppTypeEnum = "zoom"
	ClientAppTypeEnumSSOIntegration       ClientAppTypeEnum = "sso_integration"
	ClientAppTypeEnumOag                  ClientAppTypeEnum = "oag"
)

func NewClientAppTypeEnumFromString(s string) (ClientAppTypeEnum, error) {
	switch s {
	case "native":
		return ClientAppTypeEnumNative, nil
	case "spa":
		return ClientAppTypeEnumSpa, nil
	case "regular_web":
		return ClientAppTypeEnumRegularWeb, nil
	case "non_interactive":
		return ClientAppTypeEnumNonInteractive, nil
	case "resource_server":
		return ClientAppTypeEnumResourceServer, nil
	case "express_configuration":
		return ClientAppTypeEnumExpressConfiguration, nil
	case "rms":
		return ClientAppTypeEnumRms, nil
	case "box":
		return ClientAppTypeEnumBox, nil
	case "cloudbees":
		return ClientAppTypeEnumCloudbees, nil
	case "concur":
		return ClientAppTypeEnumConcur, nil
	case "dropbox":
		return ClientAppTypeEnumDropbox, nil
	case "mscrm":
		return ClientAppTypeEnumMscrm, nil
	case "echosign":
		return ClientAppTypeEnumEchosign, nil
	case "egnyte":
		return ClientAppTypeEnumEgnyte, nil
	case "newrelic":
		return ClientAppTypeEnumNewrelic, nil
	case "office365":
		return ClientAppTypeEnumOffice365, nil
	case "salesforce":
		return ClientAppTypeEnumSalesforce, nil
	case "sentry":
		return ClientAppTypeEnumSentry, nil
	case "sharepoint":
		return ClientAppTypeEnumSharepoint, nil
	case "slack":
		return ClientAppTypeEnumSlack, nil
	case "springcm":
		return ClientAppTypeEnumSpringcm, nil
	case "zendesk":
		return ClientAppTypeEnumZendesk, nil
	case "zoom":
		return ClientAppTypeEnumZoom, nil
	case "sso_integration":
		return ClientAppTypeEnumSSOIntegration, nil
	case "oag":
		return ClientAppTypeEnumOag, nil
	}
	var t ClientAppTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientAppTypeEnum) Ptr() *ClientAppTypeEnum {
	return &c
}

// Defines client authentication methods.
type ClientAuthenticationMethod struct {
	PrivateKeyJwt           *PrivateKeyJwt                                     `json:"private_key_jwt,omitempty" url:"private_key_jwt,omitempty"`
	TLSClientAuth           *ClientAuthenticationMethodTLSClientAuth           `json:"tls_client_auth,omitempty" url:"tls_client_auth,omitempty"`
	SelfSignedTLSClientAuth *ClientAuthenticationMethodSelfSignedTLSClientAuth `json:"self_signed_tls_client_auth,omitempty" url:"self_signed_tls_client_auth,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientAuthenticationMethod) GetPrivateKeyJwt() *PrivateKeyJwt {
	if c == nil {
		return nil
	}
	return c.PrivateKeyJwt
}

func (c *ClientAuthenticationMethod) GetTLSClientAuth() *ClientAuthenticationMethodTLSClientAuth {
	if c == nil {
		return nil
	}
	return c.TLSClientAuth
}

func (c *ClientAuthenticationMethod) GetSelfSignedTLSClientAuth() *ClientAuthenticationMethodSelfSignedTLSClientAuth {
	if c == nil {
		return nil
	}
	return c.SelfSignedTLSClientAuth
}

func (c *ClientAuthenticationMethod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientAuthenticationMethod) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientAuthenticationMethod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientAuthenticationMethod(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAuthenticationMethod) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines `self_signed_tls_client_auth` client authentication method. If the property is defined, the client is configured to use mTLS authentication method utilizing self-signed certificate.
type ClientAuthenticationMethodSelfSignedTLSClientAuth struct {
	// A list of unique and previously created credential IDs enabled on the client for mTLS authentication utilizing self-signed certificate.
	Credentials []*CredentialID `json:"credentials" url:"credentials"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientAuthenticationMethodSelfSignedTLSClientAuth) GetCredentials() []*CredentialID {
	if c == nil {
		return nil
	}
	return c.Credentials
}

func (c *ClientAuthenticationMethodSelfSignedTLSClientAuth) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientAuthenticationMethodSelfSignedTLSClientAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientAuthenticationMethodSelfSignedTLSClientAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientAuthenticationMethodSelfSignedTLSClientAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAuthenticationMethodSelfSignedTLSClientAuth) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines `tls_client_auth` client authentication method. If the property is defined, the client is configured to use CA-based mTLS authentication method.
type ClientAuthenticationMethodTLSClientAuth struct {
	// A list of unique and previously created credential IDs enabled on the client for CA-based mTLS authentication.
	Credentials []*CredentialID `json:"credentials" url:"credentials"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientAuthenticationMethodTLSClientAuth) GetCredentials() []*CredentialID {
	if c == nil {
		return nil
	}
	return c.Credentials
}

func (c *ClientAuthenticationMethodTLSClientAuth) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientAuthenticationMethodTLSClientAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientAuthenticationMethodTLSClientAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientAuthenticationMethodTLSClientAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientAuthenticationMethodTLSClientAuth) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the compliance level for this client, which may restrict it's capabilities
type ClientComplianceLevelEnum = *string

// Defines client authentication methods.
type ClientCreateAuthenticationMethod struct {
	PrivateKeyJwt           *PrivateKeyJwt                                     `json:"private_key_jwt,omitempty" url:"private_key_jwt,omitempty"`
	TLSClientAuth           *ClientAuthenticationMethodTLSClientAuth           `json:"tls_client_auth,omitempty" url:"tls_client_auth,omitempty"`
	SelfSignedTLSClientAuth *ClientAuthenticationMethodSelfSignedTLSClientAuth `json:"self_signed_tls_client_auth,omitempty" url:"self_signed_tls_client_auth,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientCreateAuthenticationMethod) GetPrivateKeyJwt() *PrivateKeyJwt {
	if c == nil {
		return nil
	}
	return c.PrivateKeyJwt
}

func (c *ClientCreateAuthenticationMethod) GetTLSClientAuth() *ClientAuthenticationMethodTLSClientAuth {
	if c == nil {
		return nil
	}
	return c.TLSClientAuth
}

func (c *ClientCreateAuthenticationMethod) GetSelfSignedTLSClientAuth() *ClientAuthenticationMethodSelfSignedTLSClientAuth {
	if c == nil {
		return nil
	}
	return c.SelfSignedTLSClientAuth
}

func (c *ClientCreateAuthenticationMethod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientCreateAuthenticationMethod) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientCreateAuthenticationMethod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientCreateAuthenticationMethod(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientCreateAuthenticationMethod) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the default Organization ID and flows
type ClientDefaultOrganization struct {
	// The default Organization ID to be used
	OrganizationID string `json:"organization_id" url:"organization_id"`
	// The default Organization usage
	Flows []ClientDefaultOrganizationFlowsEnum `json:"flows" url:"flows"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientDefaultOrganization) GetOrganizationID() string {
	if c == nil {
		return ""
	}
	return c.OrganizationID
}

func (c *ClientDefaultOrganization) GetFlows() []ClientDefaultOrganizationFlowsEnum {
	if c == nil {
		return nil
	}
	return c.Flows
}

func (c *ClientDefaultOrganization) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientDefaultOrganization) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientDefaultOrganization
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientDefaultOrganization(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientDefaultOrganization) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientDefaultOrganizationFlowsEnum = string

// Encryption used for WsFed responses with this client.
type ClientEncryptionKey struct {
	// Encryption Public RSA Key.
	Pub *string `json:"pub,omitempty" url:"pub,omitempty"`
	// Encryption certificate for public key in X.509 (.CER) format.
	Cert *string `json:"cert,omitempty" url:"cert,omitempty"`
	// Encryption certificate name for this certificate in the format `/CN={domain}`.
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientEncryptionKey) GetPub() *string {
	if c == nil {
		return nil
	}
	return c.Pub
}

func (c *ClientEncryptionKey) GetCert() *string {
	if c == nil {
		return nil
	}
	return c.Cert
}

func (c *ClientEncryptionKey) GetSubject() *string {
	if c == nil {
		return nil
	}
	return c.Subject
}

func (c *ClientEncryptionKey) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientEncryptionKey) UnmarshalJSON(data []byte) error {
	type embed ClientEncryptionKey
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientEncryptionKey(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientEncryptionKey) MarshalJSON() ([]byte, error) {
	type embed ClientEncryptionKey
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientEncryptionKey) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configuration related to JWTs for the client.
type ClientJwtConfiguration struct {
	// Number of seconds the JWT will be valid for (affects `exp` claim).
	LifetimeInSeconds *int `json:"lifetime_in_seconds,omitempty" url:"lifetime_in_seconds,omitempty"`
	// Whether the client secret is base64 encoded (true) or unencoded (false).
	SecretEncoded *bool                         `json:"secret_encoded,omitempty" url:"secret_encoded,omitempty"`
	Scopes        *ClientJwtConfigurationScopes `json:"scopes,omitempty" url:"scopes,omitempty"`
	Alg           *SigningAlgorithmEnum         `json:"alg,omitempty" url:"alg,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientJwtConfiguration) GetLifetimeInSeconds() *int {
	if c == nil {
		return nil
	}
	return c.LifetimeInSeconds
}

func (c *ClientJwtConfiguration) GetSecretEncoded() *bool {
	if c == nil {
		return nil
	}
	return c.SecretEncoded
}

func (c *ClientJwtConfiguration) GetScopes() *ClientJwtConfigurationScopes {
	if c == nil {
		return nil
	}
	return c.Scopes
}

func (c *ClientJwtConfiguration) GetAlg() *SigningAlgorithmEnum {
	if c == nil {
		return nil
	}
	return c.Alg
}

func (c *ClientJwtConfiguration) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientJwtConfiguration) UnmarshalJSON(data []byte) error {
	type embed ClientJwtConfiguration
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientJwtConfiguration(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientJwtConfiguration) MarshalJSON() ([]byte, error) {
	type embed ClientJwtConfiguration
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientJwtConfiguration) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configuration related to id token claims for the client.
type ClientJwtConfigurationScopes = map[string]interface{}

// Metadata associated with the client, in the form of an object with string values (max 255 chars).  Maximum of 10 metadata properties allowed.  Field names (max 255 chars) are alphanumeric and may only include the following special characters:  :,-+=_*?"/\()<>@	[Tab] [Space]
type ClientMetadata = map[string]interface{}

// Additional configuration for native mobile apps.
type ClientMobile struct {
	Android *ClientMobileAndroid `json:"android,omitempty" url:"android,omitempty"`
	Ios     *ClientMobileiOs     `json:"ios,omitempty" url:"ios,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientMobile) GetAndroid() *ClientMobileAndroid {
	if c == nil {
		return nil
	}
	return c.Android
}

func (c *ClientMobile) GetIos() *ClientMobileiOs {
	if c == nil {
		return nil
	}
	return c.Ios
}

func (c *ClientMobile) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientMobile) UnmarshalJSON(data []byte) error {
	type embed ClientMobile
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMobile(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMobile) MarshalJSON() ([]byte, error) {
	type embed ClientMobile
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientMobile) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Android native app configuration.
type ClientMobileAndroid struct {
	// App package name found in AndroidManifest.xml.
	AppPackageName *string `json:"app_package_name,omitempty" url:"app_package_name,omitempty"`
	// SHA256 fingerprints of the app's signing certificate. Multiple fingerprints can be used to support different versions of your app, such as debug and production builds.
	Sha256CertFingerprints []string `json:"sha256_cert_fingerprints,omitempty" url:"sha256_cert_fingerprints,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientMobileAndroid) GetAppPackageName() *string {
	if c == nil {
		return nil
	}
	return c.AppPackageName
}

func (c *ClientMobileAndroid) GetSha256CertFingerprints() []string {
	if c == nil {
		return nil
	}
	return c.Sha256CertFingerprints
}

func (c *ClientMobileAndroid) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientMobileAndroid) UnmarshalJSON(data []byte) error {
	type embed ClientMobileAndroid
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMobileAndroid(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMobileAndroid) MarshalJSON() ([]byte, error) {
	type embed ClientMobileAndroid
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientMobileAndroid) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// iOS native app configuration.
type ClientMobileiOs struct {
	// Identifier assigned to the Apple account that signs and uploads the app to the store.
	TeamID *string `json:"team_id,omitempty" url:"team_id,omitempty"`
	// Assigned by developer to the app as its unique identifier inside the store. Usually this is a reverse domain plus the app name, e.g. `com.you.MyApp`.
	AppBundleIdentifier *string `json:"app_bundle_identifier,omitempty" url:"app_bundle_identifier,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientMobileiOs) GetTeamID() *string {
	if c == nil {
		return nil
	}
	return c.TeamID
}

func (c *ClientMobileiOs) GetAppBundleIdentifier() *string {
	if c == nil {
		return nil
	}
	return c.AppBundleIdentifier
}

func (c *ClientMobileiOs) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientMobileiOs) UnmarshalJSON(data []byte) error {
	type embed ClientMobileiOs
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMobileiOs(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMobileiOs) MarshalJSON() ([]byte, error) {
	type embed ClientMobileiOs
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientMobileiOs) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configuration for OIDC backchannel logout initiators
type ClientOidcBackchannelLogoutInitiators struct {
	Mode               *ClientOidcBackchannelLogoutInitiatorsModeEnum `json:"mode,omitempty" url:"mode,omitempty"`
	SelectedInitiators []ClientOidcBackchannelLogoutInitiatorsEnum    `json:"selected_initiators,omitempty" url:"selected_initiators,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientOidcBackchannelLogoutInitiators) GetMode() *ClientOidcBackchannelLogoutInitiatorsModeEnum {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *ClientOidcBackchannelLogoutInitiators) GetSelectedInitiators() []ClientOidcBackchannelLogoutInitiatorsEnum {
	if c == nil {
		return nil
	}
	return c.SelectedInitiators
}

func (c *ClientOidcBackchannelLogoutInitiators) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientOidcBackchannelLogoutInitiators) UnmarshalJSON(data []byte) error {
	type embed ClientOidcBackchannelLogoutInitiators
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientOidcBackchannelLogoutInitiators(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientOidcBackchannelLogoutInitiators) MarshalJSON() ([]byte, error) {
	type embed ClientOidcBackchannelLogoutInitiators
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientOidcBackchannelLogoutInitiators) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The `selected_initiators` property contains the list of initiators to be enabled for the given application.
type ClientOidcBackchannelLogoutInitiatorsEnum string

const (
	ClientOidcBackchannelLogoutInitiatorsEnumRpLogout               ClientOidcBackchannelLogoutInitiatorsEnum = "rp-logout"
	ClientOidcBackchannelLogoutInitiatorsEnumIdpLogout              ClientOidcBackchannelLogoutInitiatorsEnum = "idp-logout"
	ClientOidcBackchannelLogoutInitiatorsEnumPasswordChanged        ClientOidcBackchannelLogoutInitiatorsEnum = "password-changed"
	ClientOidcBackchannelLogoutInitiatorsEnumSessionExpired         ClientOidcBackchannelLogoutInitiatorsEnum = "session-expired"
	ClientOidcBackchannelLogoutInitiatorsEnumSessionRevoked         ClientOidcBackchannelLogoutInitiatorsEnum = "session-revoked"
	ClientOidcBackchannelLogoutInitiatorsEnumAccountDeleted         ClientOidcBackchannelLogoutInitiatorsEnum = "account-deleted"
	ClientOidcBackchannelLogoutInitiatorsEnumEmailIdentifierChanged ClientOidcBackchannelLogoutInitiatorsEnum = "email-identifier-changed"
	ClientOidcBackchannelLogoutInitiatorsEnumMfaPhoneUnenrolled     ClientOidcBackchannelLogoutInitiatorsEnum = "mfa-phone-unenrolled"
	ClientOidcBackchannelLogoutInitiatorsEnumAccountDeactivated     ClientOidcBackchannelLogoutInitiatorsEnum = "account-deactivated"
)

func NewClientOidcBackchannelLogoutInitiatorsEnumFromString(s string) (ClientOidcBackchannelLogoutInitiatorsEnum, error) {
	switch s {
	case "rp-logout":
		return ClientOidcBackchannelLogoutInitiatorsEnumRpLogout, nil
	case "idp-logout":
		return ClientOidcBackchannelLogoutInitiatorsEnumIdpLogout, nil
	case "password-changed":
		return ClientOidcBackchannelLogoutInitiatorsEnumPasswordChanged, nil
	case "session-expired":
		return ClientOidcBackchannelLogoutInitiatorsEnumSessionExpired, nil
	case "session-revoked":
		return ClientOidcBackchannelLogoutInitiatorsEnumSessionRevoked, nil
	case "account-deleted":
		return ClientOidcBackchannelLogoutInitiatorsEnumAccountDeleted, nil
	case "email-identifier-changed":
		return ClientOidcBackchannelLogoutInitiatorsEnumEmailIdentifierChanged, nil
	case "mfa-phone-unenrolled":
		return ClientOidcBackchannelLogoutInitiatorsEnumMfaPhoneUnenrolled, nil
	case "account-deactivated":
		return ClientOidcBackchannelLogoutInitiatorsEnumAccountDeactivated, nil
	}
	var t ClientOidcBackchannelLogoutInitiatorsEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientOidcBackchannelLogoutInitiatorsEnum) Ptr() *ClientOidcBackchannelLogoutInitiatorsEnum {
	return &c
}

// The `mode` property determines the configuration method for enabling initiators. `custom` enables only the initiators listed in the selected_initiators array, `all` enables all current and future initiators.
type ClientOidcBackchannelLogoutInitiatorsModeEnum string

const (
	ClientOidcBackchannelLogoutInitiatorsModeEnumCustom ClientOidcBackchannelLogoutInitiatorsModeEnum = "custom"
	ClientOidcBackchannelLogoutInitiatorsModeEnumAll    ClientOidcBackchannelLogoutInitiatorsModeEnum = "all"
)

func NewClientOidcBackchannelLogoutInitiatorsModeEnumFromString(s string) (ClientOidcBackchannelLogoutInitiatorsModeEnum, error) {
	switch s {
	case "custom":
		return ClientOidcBackchannelLogoutInitiatorsModeEnumCustom, nil
	case "all":
		return ClientOidcBackchannelLogoutInitiatorsModeEnumAll, nil
	}
	var t ClientOidcBackchannelLogoutInitiatorsModeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientOidcBackchannelLogoutInitiatorsModeEnum) Ptr() *ClientOidcBackchannelLogoutInitiatorsModeEnum {
	return &c
}

// Configuration for OIDC backchannel logout
type ClientOidcBackchannelLogoutSettings struct {
	// Comma-separated list of URLs that are valid to call back from Auth0 for OIDC backchannel logout. Currently only one URL is allowed.
	BackchannelLogoutURLs       []string                               `json:"backchannel_logout_urls,omitempty" url:"backchannel_logout_urls,omitempty"`
	BackchannelLogoutInitiators *ClientOidcBackchannelLogoutInitiators `json:"backchannel_logout_initiators,omitempty" url:"backchannel_logout_initiators,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientOidcBackchannelLogoutSettings) GetBackchannelLogoutURLs() []string {
	if c == nil {
		return nil
	}
	return c.BackchannelLogoutURLs
}

func (c *ClientOidcBackchannelLogoutSettings) GetBackchannelLogoutInitiators() *ClientOidcBackchannelLogoutInitiators {
	if c == nil {
		return nil
	}
	return c.BackchannelLogoutInitiators
}

func (c *ClientOidcBackchannelLogoutSettings) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientOidcBackchannelLogoutSettings) UnmarshalJSON(data []byte) error {
	type embed ClientOidcBackchannelLogoutSettings
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientOidcBackchannelLogoutSettings(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientOidcBackchannelLogoutSettings) MarshalJSON() ([]byte, error) {
	type embed ClientOidcBackchannelLogoutSettings
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientOidcBackchannelLogoutSettings) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines how to proceed during an authentication transaction when `client.organization_usage: 'require'`. Can be `no_prompt` (default), `pre_login_prompt` or `post_login_prompt`. `post_login_prompt` requires `oidc_conformant: true`.
type ClientOrganizationRequireBehaviorEnum string

const (
	ClientOrganizationRequireBehaviorEnumNoPrompt        ClientOrganizationRequireBehaviorEnum = "no_prompt"
	ClientOrganizationRequireBehaviorEnumPreLoginPrompt  ClientOrganizationRequireBehaviorEnum = "pre_login_prompt"
	ClientOrganizationRequireBehaviorEnumPostLoginPrompt ClientOrganizationRequireBehaviorEnum = "post_login_prompt"
)

func NewClientOrganizationRequireBehaviorEnumFromString(s string) (ClientOrganizationRequireBehaviorEnum, error) {
	switch s {
	case "no_prompt":
		return ClientOrganizationRequireBehaviorEnumNoPrompt, nil
	case "pre_login_prompt":
		return ClientOrganizationRequireBehaviorEnumPreLoginPrompt, nil
	case "post_login_prompt":
		return ClientOrganizationRequireBehaviorEnumPostLoginPrompt, nil
	}
	var t ClientOrganizationRequireBehaviorEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientOrganizationRequireBehaviorEnum) Ptr() *ClientOrganizationRequireBehaviorEnum {
	return &c
}

// Defines how to proceed during an authentication transaction when `client.organization_usage: 'require'`. Can be `no_prompt` (default), `pre_login_prompt` or `post_login_prompt`. `post_login_prompt` requires `oidc_conformant: true`.
type ClientOrganizationRequireBehaviorPatchEnum = *string

// Defines how to proceed during an authentication transaction with regards an organization. Can be `deny` (default), `allow` or `require`.
type ClientOrganizationUsageEnum string

const (
	ClientOrganizationUsageEnumDeny    ClientOrganizationUsageEnum = "deny"
	ClientOrganizationUsageEnumAllow   ClientOrganizationUsageEnum = "allow"
	ClientOrganizationUsageEnumRequire ClientOrganizationUsageEnum = "require"
)

func NewClientOrganizationUsageEnumFromString(s string) (ClientOrganizationUsageEnum, error) {
	switch s {
	case "deny":
		return ClientOrganizationUsageEnumDeny, nil
	case "allow":
		return ClientOrganizationUsageEnumAllow, nil
	case "require":
		return ClientOrganizationUsageEnumRequire, nil
	}
	var t ClientOrganizationUsageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientOrganizationUsageEnum) Ptr() *ClientOrganizationUsageEnum {
	return &c
}

// Defines how to proceed during an authentication transaction with regards an organization. Can be `deny` (default), `allow` or `require`.
type ClientOrganizationUsagePatchEnum = *string

// Refresh token configuration
type ClientRefreshTokenConfiguration struct {
	RotationType   RefreshTokenRotationTypeEnum   `json:"rotation_type" url:"rotation_type"`
	ExpirationType RefreshTokenExpirationTypeEnum `json:"expiration_type" url:"expiration_type"`
	// Period in seconds where the previous refresh token can be exchanged without triggering breach detection
	Leeway *int `json:"leeway,omitempty" url:"leeway,omitempty"`
	// Period (in seconds) for which refresh tokens will remain valid
	TokenLifetime *int `json:"token_lifetime,omitempty" url:"token_lifetime,omitempty"`
	// Prevents tokens from having a set lifetime when `true` (takes precedence over `token_lifetime` values)
	InfiniteTokenLifetime *bool `json:"infinite_token_lifetime,omitempty" url:"infinite_token_lifetime,omitempty"`
	// Period (in seconds) for which refresh tokens will remain valid without use
	IdleTokenLifetime *int `json:"idle_token_lifetime,omitempty" url:"idle_token_lifetime,omitempty"`
	// Prevents tokens from expiring without use when `true` (takes precedence over `idle_token_lifetime` values)
	InfiniteIdleTokenLifetime *bool `json:"infinite_idle_token_lifetime,omitempty" url:"infinite_idle_token_lifetime,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientRefreshTokenConfiguration) GetRotationType() RefreshTokenRotationTypeEnum {
	if c == nil {
		return ""
	}
	return c.RotationType
}

func (c *ClientRefreshTokenConfiguration) GetExpirationType() RefreshTokenExpirationTypeEnum {
	if c == nil {
		return ""
	}
	return c.ExpirationType
}

func (c *ClientRefreshTokenConfiguration) GetLeeway() *int {
	if c == nil {
		return nil
	}
	return c.Leeway
}

func (c *ClientRefreshTokenConfiguration) GetTokenLifetime() *int {
	if c == nil {
		return nil
	}
	return c.TokenLifetime
}

func (c *ClientRefreshTokenConfiguration) GetInfiniteTokenLifetime() *bool {
	if c == nil {
		return nil
	}
	return c.InfiniteTokenLifetime
}

func (c *ClientRefreshTokenConfiguration) GetIdleTokenLifetime() *int {
	if c == nil {
		return nil
	}
	return c.IdleTokenLifetime
}

func (c *ClientRefreshTokenConfiguration) GetInfiniteIdleTokenLifetime() *bool {
	if c == nil {
		return nil
	}
	return c.InfiniteIdleTokenLifetime
}

func (c *ClientRefreshTokenConfiguration) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientRefreshTokenConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientRefreshTokenConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientRefreshTokenConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientRefreshTokenConfiguration) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientSessionTransferAllowedAuthenticationMethodsEnum string

const (
	ClientSessionTransferAllowedAuthenticationMethodsEnumCookie ClientSessionTransferAllowedAuthenticationMethodsEnum = "cookie"
	ClientSessionTransferAllowedAuthenticationMethodsEnumQuery  ClientSessionTransferAllowedAuthenticationMethodsEnum = "query"
)

func NewClientSessionTransferAllowedAuthenticationMethodsEnumFromString(s string) (ClientSessionTransferAllowedAuthenticationMethodsEnum, error) {
	switch s {
	case "cookie":
		return ClientSessionTransferAllowedAuthenticationMethodsEnumCookie, nil
	case "query":
		return ClientSessionTransferAllowedAuthenticationMethodsEnumQuery, nil
	}
	var t ClientSessionTransferAllowedAuthenticationMethodsEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientSessionTransferAllowedAuthenticationMethodsEnum) Ptr() *ClientSessionTransferAllowedAuthenticationMethodsEnum {
	return &c
}

// Native to Web SSO Configuration
type ClientSessionTransferConfiguration struct {
	// Indicates whether an app can issue a session_token through Token Exchange. If set to 'false', the app will not be able to issue a session_token.
	CanCreateSessionTransferToken *bool `json:"can_create_session_transfer_token,omitempty" url:"can_create_session_transfer_token,omitempty"`
	// Indicates whether an app can create a session from a session_token received via indicated methods.
	AllowedAuthenticationMethods []ClientSessionTransferAllowedAuthenticationMethodsEnum `json:"allowed_authentication_methods,omitempty" url:"allowed_authentication_methods,omitempty"`
	EnforceDeviceBinding         *ClientSessionTransferDeviceBindingEnum                 `json:"enforce_device_binding,omitempty" url:"enforce_device_binding,omitempty"`
	// Indicates whether Refresh Tokens are allowed to be issued when authenticating with a session_transfer_token.
	AllowRefreshToken *bool `json:"allow_refresh_token,omitempty" url:"allow_refresh_token,omitempty"`
	// Indicates whether Refresh Tokens created during a native-to-web session are tied to that session's lifetime. This determines if such refresh tokens should be automatically revoked when their corresponding sessions are.
	EnforceOnlineRefreshTokens *bool `json:"enforce_online_refresh_tokens,omitempty" url:"enforce_online_refresh_tokens,omitempty"`
	// Indicates whether revoking the parent Refresh Token that initiated a Native to Web flow and was used to issue a Session Transfer Token should trigger a cascade revocation affecting its dependent child entities.
	EnforceCascadeRevocation *bool `json:"enforce_cascade_revocation,omitempty" url:"enforce_cascade_revocation,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientSessionTransferConfiguration) GetCanCreateSessionTransferToken() *bool {
	if c == nil {
		return nil
	}
	return c.CanCreateSessionTransferToken
}

func (c *ClientSessionTransferConfiguration) GetAllowedAuthenticationMethods() []ClientSessionTransferAllowedAuthenticationMethodsEnum {
	if c == nil {
		return nil
	}
	return c.AllowedAuthenticationMethods
}

func (c *ClientSessionTransferConfiguration) GetEnforceDeviceBinding() *ClientSessionTransferDeviceBindingEnum {
	if c == nil {
		return nil
	}
	return c.EnforceDeviceBinding
}

func (c *ClientSessionTransferConfiguration) GetAllowRefreshToken() *bool {
	if c == nil {
		return nil
	}
	return c.AllowRefreshToken
}

func (c *ClientSessionTransferConfiguration) GetEnforceOnlineRefreshTokens() *bool {
	if c == nil {
		return nil
	}
	return c.EnforceOnlineRefreshTokens
}

func (c *ClientSessionTransferConfiguration) GetEnforceCascadeRevocation() *bool {
	if c == nil {
		return nil
	}
	return c.EnforceCascadeRevocation
}

func (c *ClientSessionTransferConfiguration) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientSessionTransferConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientSessionTransferConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientSessionTransferConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientSessionTransferConfiguration) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates whether device binding security should be enforced for the app. If set to 'ip', the app will enforce device binding by IP, meaning that consumption of session_token must be done from the same IP of the issuer. Likewise, if set to 'asn', device binding is enforced by ASN, meaning consumption of session_token must be done from the same ASN as the issuer. If set to 'null', device binding is not enforced.
type ClientSessionTransferDeviceBindingEnum string

const (
	ClientSessionTransferDeviceBindingEnumIP   ClientSessionTransferDeviceBindingEnum = "ip"
	ClientSessionTransferDeviceBindingEnumAsn  ClientSessionTransferDeviceBindingEnum = "asn"
	ClientSessionTransferDeviceBindingEnumNone ClientSessionTransferDeviceBindingEnum = "none"
)

func NewClientSessionTransferDeviceBindingEnumFromString(s string) (ClientSessionTransferDeviceBindingEnum, error) {
	switch s {
	case "ip":
		return ClientSessionTransferDeviceBindingEnumIP, nil
	case "asn":
		return ClientSessionTransferDeviceBindingEnumAsn, nil
	case "none":
		return ClientSessionTransferDeviceBindingEnumNone, nil
	}
	var t ClientSessionTransferDeviceBindingEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientSessionTransferDeviceBindingEnum) Ptr() *ClientSessionTransferDeviceBindingEnum {
	return &c
}

// JWT-secured Authorization Requests (JAR) settings.
type ClientSignedRequestObjectWithCredentialID struct {
	// Indicates whether the JAR requests are mandatory
	Required    *bool           `json:"required,omitempty" url:"required,omitempty"`
	Credentials []*CredentialID `json:"credentials,omitempty" url:"credentials,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientSignedRequestObjectWithCredentialID) GetRequired() *bool {
	if c == nil {
		return nil
	}
	return c.Required
}

func (c *ClientSignedRequestObjectWithCredentialID) GetCredentials() []*CredentialID {
	if c == nil {
		return nil
	}
	return c.Credentials
}

func (c *ClientSignedRequestObjectWithCredentialID) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientSignedRequestObjectWithCredentialID) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientSignedRequestObjectWithCredentialID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientSignedRequestObjectWithCredentialID(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientSignedRequestObjectWithCredentialID) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// JWT-secured Authorization Requests (JAR) settings.
type ClientSignedRequestObjectWithPublicKey struct {
	// Indicates whether the JAR requests are mandatory
	Required    *bool                  `json:"required,omitempty" url:"required,omitempty"`
	Credentials []*PublicKeyCredential `json:"credentials,omitempty" url:"credentials,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientSignedRequestObjectWithPublicKey) GetRequired() *bool {
	if c == nil {
		return nil
	}
	return c.Required
}

func (c *ClientSignedRequestObjectWithPublicKey) GetCredentials() []*PublicKeyCredential {
	if c == nil {
		return nil
	}
	return c.Credentials
}

func (c *ClientSignedRequestObjectWithPublicKey) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientSignedRequestObjectWithPublicKey) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientSignedRequestObjectWithPublicKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientSignedRequestObjectWithPublicKey(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientSignedRequestObjectWithPublicKey) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientSigningKey struct {
	// Signing certificate public key and chain in PKCS#7 (.P7B) format.
	Pkcs7 *string `json:"pkcs7,omitempty" url:"pkcs7,omitempty"`
	// Signing certificate public key in X.509 (.CER) format.
	Cert *string `json:"cert,omitempty" url:"cert,omitempty"`
	// Subject name for this certificate in the format `/CN={domain}`.
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *ClientSigningKey) GetPkcs7() *string {
	if c == nil {
		return nil
	}
	return c.Pkcs7
}

func (c *ClientSigningKey) GetCert() *string {
	if c == nil {
		return nil
	}
	return c.Cert
}

func (c *ClientSigningKey) GetSubject() *string {
	if c == nil {
		return nil
	}
	return c.Subject
}

func (c *ClientSigningKey) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *ClientSigningKey) UnmarshalJSON(data []byte) error {
	type embed ClientSigningKey
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientSigningKey(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientSigningKey) MarshalJSON() ([]byte, error) {
	type embed ClientSigningKey
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *ClientSigningKey) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Signing certificates associated with this client.
type ClientSigningKeys = []*ClientSigningKey

// Defines the requested authentication method for the token endpoint. Can be `none` (public client without a client secret), `client_secret_post` (client uses HTTP POST parameters), or `client_secret_basic` (client uses HTTP Basic).
type ClientTokenEndpointAuthMethodEnum string

const (
	ClientTokenEndpointAuthMethodEnumNone              ClientTokenEndpointAuthMethodEnum = "none"
	ClientTokenEndpointAuthMethodEnumClientSecretPost  ClientTokenEndpointAuthMethodEnum = "client_secret_post"
	ClientTokenEndpointAuthMethodEnumClientSecretBasic ClientTokenEndpointAuthMethodEnum = "client_secret_basic"
)

func NewClientTokenEndpointAuthMethodEnumFromString(s string) (ClientTokenEndpointAuthMethodEnum, error) {
	switch s {
	case "none":
		return ClientTokenEndpointAuthMethodEnumNone, nil
	case "client_secret_post":
		return ClientTokenEndpointAuthMethodEnumClientSecretPost, nil
	case "client_secret_basic":
		return ClientTokenEndpointAuthMethodEnumClientSecretBasic, nil
	}
	var t ClientTokenEndpointAuthMethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientTokenEndpointAuthMethodEnum) Ptr() *ClientTokenEndpointAuthMethodEnum {
	return &c
}

// Defines the requested authentication method for the token endpoint. Can be `none` (public client without a client secret), `client_secret_post` (client uses HTTP POST parameters), or `client_secret_basic` (client uses HTTP Basic).
type ClientTokenEndpointAuthMethodOrNullEnum = *string

type CreateClientResponseContent struct {
	// ID of this client.
	ClientID *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// Name of the tenant this client belongs to.
	Tenant *string `json:"tenant,omitempty" url:"tenant,omitempty"`
	// Name of this client (min length: 1 character, does not allow `<` or `>`).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Free text description of this client (max length: 140 characters).
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Whether this is your global 'All Applications' client representing legacy tenant settings (true) or a regular client (false).
	Global *bool `json:"global,omitempty" url:"global,omitempty"`
	// Client secret (which you must not make public).
	ClientSecret *string `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	// Type of client used to determine which settings are applicable. Can be `spa`, `native`, `non_interactive`, or `regular_web`.
	AppType *string `json:"app_type,omitempty" url:"app_type,omitempty"`
	// URL of the logo to display for this client. Recommended size is 150x150 pixels.
	LogoURI *string `json:"logo_uri,omitempty" url:"logo_uri,omitempty"`
	// Whether this client a first party client (true) or not (false).
	IsFirstParty *bool `json:"is_first_party,omitempty" url:"is_first_party,omitempty"`
	// Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false).
	OidcConformant *bool `json:"oidc_conformant,omitempty" url:"oidc_conformant,omitempty"`
	// Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication.
	Callbacks []string `json:"callbacks,omitempty" url:"callbacks,omitempty"`
	// Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs.
	AllowedOrigins []string `json:"allowed_origins,omitempty" url:"allowed_origins,omitempty"`
	// Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>.
	WebOrigins []string `json:"web_origins,omitempty" url:"web_origins,omitempty"`
	// List of audiences/realms for SAML protocol. Used by the wsfed addon.
	ClientAliases []string `json:"client_aliases,omitempty" url:"client_aliases,omitempty"`
	// List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed.
	AllowedClients []string `json:"allowed_clients,omitempty" url:"allowed_clients,omitempty"`
	// Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains.
	AllowedLogoutURLs []string                             `json:"allowed_logout_urls,omitempty" url:"allowed_logout_urls,omitempty"`
	SessionTransfer   *ClientSessionTransferConfiguration  `json:"session_transfer,omitempty" url:"session_transfer,omitempty"`
	OidcLogout        *ClientOidcBackchannelLogoutSettings `json:"oidc_logout,omitempty" url:"oidc_logout,omitempty"`
	// List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, and `urn:ietf:params:oauth:grant-type:device_code`.
	GrantTypes       []string                `json:"grant_types,omitempty" url:"grant_types,omitempty"`
	JwtConfiguration *ClientJwtConfiguration `json:"jwt_configuration,omitempty" url:"jwt_configuration,omitempty"`
	SigningKeys      *ClientSigningKeys      `json:"signing_keys,omitempty" url:"signing_keys,omitempty"`
	EncryptionKey    *ClientEncryptionKey    `json:"encryption_key,omitempty" url:"encryption_key,omitempty"`
	// Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false).
	SSO *bool `json:"sso,omitempty" url:"sso,omitempty"`
	// Whether Single Sign On is disabled (true) or enabled (true). Defaults to true.
	SSODisabled *bool `json:"sso_disabled,omitempty" url:"sso_disabled,omitempty"`
	// Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false).
	CrossOriginAuthentication *bool `json:"cross_origin_authentication,omitempty" url:"cross_origin_authentication,omitempty"`
	// URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page.
	CrossOriginLoc *string `json:"cross_origin_loc,omitempty" url:"cross_origin_loc,omitempty"`
	// Whether a custom login page is to be used (true) or the default provided login page (false).
	CustomLoginPageOn *bool `json:"custom_login_page_on,omitempty" url:"custom_login_page_on,omitempty"`
	// The content (HTML, CSS, JS) of the custom login page.
	CustomLoginPage *string `json:"custom_login_page,omitempty" url:"custom_login_page,omitempty"`
	// The content (HTML, CSS, JS) of the custom login page. (Used on Previews)
	CustomLoginPagePreview *string `json:"custom_login_page_preview,omitempty" url:"custom_login_page_preview,omitempty"`
	// HTML form template to be used for WS-Federation.
	FormTemplate            *string                            `json:"form_template,omitempty" url:"form_template,omitempty"`
	Addons                  *ClientAddons                      `json:"addons,omitempty" url:"addons,omitempty"`
	TokenEndpointAuthMethod *ClientTokenEndpointAuthMethodEnum `json:"token_endpoint_auth_method,omitempty" url:"token_endpoint_auth_method,omitempty"`
	ClientMetadata          *ClientMetadata                    `json:"client_metadata,omitempty" url:"client_metadata,omitempty"`
	Mobile                  *ClientMobile                      `json:"mobile,omitempty" url:"mobile,omitempty"`
	// Initiate login uri, must be https
	InitiateLoginURI            *string                                `json:"initiate_login_uri,omitempty" url:"initiate_login_uri,omitempty"`
	RefreshToken                *ClientRefreshTokenConfiguration       `json:"refresh_token,omitempty" url:"refresh_token,omitempty"`
	DefaultOrganization         *ClientDefaultOrganization             `json:"default_organization,omitempty" url:"default_organization,omitempty"`
	OrganizationUsage           *ClientOrganizationUsageEnum           `json:"organization_usage,omitempty" url:"organization_usage,omitempty"`
	OrganizationRequireBehavior *ClientOrganizationRequireBehaviorEnum `json:"organization_require_behavior,omitempty" url:"organization_require_behavior,omitempty"`
	ClientAuthenticationMethods *ClientAuthenticationMethod            `json:"client_authentication_methods,omitempty" url:"client_authentication_methods,omitempty"`
	// Makes the use of Pushed Authorization Requests mandatory for this client
	RequirePushedAuthorizationRequests *bool `json:"require_pushed_authorization_requests,omitempty" url:"require_pushed_authorization_requests,omitempty"`
	// Makes the use of Proof-of-Possession mandatory for this client
	RequireProofOfPossession *bool                                      `json:"require_proof_of_possession,omitempty" url:"require_proof_of_possession,omitempty"`
	SignedRequestObject      *ClientSignedRequestObjectWithCredentialID `json:"signed_request_object,omitempty" url:"signed_request_object,omitempty"`
	ComplianceLevel          *ClientComplianceLevelEnum                 `json:"compliance_level,omitempty" url:"compliance_level,omitempty"`
	// Specifies how long, in seconds, a Pushed Authorization Request URI remains valid
	ParRequestExpiry *int        `json:"par_request_expiry,omitempty" url:"par_request_expiry,omitempty"`
	TokenQuota       *TokenQuota `json:"token_quota,omitempty" url:"token_quota,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *CreateClientResponseContent) GetClientID() *string {
	if c == nil {
		return nil
	}
	return c.ClientID
}

func (c *CreateClientResponseContent) GetTenant() *string {
	if c == nil {
		return nil
	}
	return c.Tenant
}

func (c *CreateClientResponseContent) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateClientResponseContent) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateClientResponseContent) GetGlobal() *bool {
	if c == nil {
		return nil
	}
	return c.Global
}

func (c *CreateClientResponseContent) GetClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientSecret
}

func (c *CreateClientResponseContent) GetAppType() *string {
	if c == nil {
		return nil
	}
	return c.AppType
}

func (c *CreateClientResponseContent) GetLogoURI() *string {
	if c == nil {
		return nil
	}
	return c.LogoURI
}

func (c *CreateClientResponseContent) GetIsFirstParty() *bool {
	if c == nil {
		return nil
	}
	return c.IsFirstParty
}

func (c *CreateClientResponseContent) GetOidcConformant() *bool {
	if c == nil {
		return nil
	}
	return c.OidcConformant
}

func (c *CreateClientResponseContent) GetCallbacks() []string {
	if c == nil {
		return nil
	}
	return c.Callbacks
}

func (c *CreateClientResponseContent) GetAllowedOrigins() []string {
	if c == nil {
		return nil
	}
	return c.AllowedOrigins
}

func (c *CreateClientResponseContent) GetWebOrigins() []string {
	if c == nil {
		return nil
	}
	return c.WebOrigins
}

func (c *CreateClientResponseContent) GetClientAliases() []string {
	if c == nil {
		return nil
	}
	return c.ClientAliases
}

func (c *CreateClientResponseContent) GetAllowedClients() []string {
	if c == nil {
		return nil
	}
	return c.AllowedClients
}

func (c *CreateClientResponseContent) GetAllowedLogoutURLs() []string {
	if c == nil {
		return nil
	}
	return c.AllowedLogoutURLs
}

func (c *CreateClientResponseContent) GetSessionTransfer() *ClientSessionTransferConfiguration {
	if c == nil {
		return nil
	}
	return c.SessionTransfer
}

func (c *CreateClientResponseContent) GetOidcLogout() *ClientOidcBackchannelLogoutSettings {
	if c == nil {
		return nil
	}
	return c.OidcLogout
}

func (c *CreateClientResponseContent) GetGrantTypes() []string {
	if c == nil {
		return nil
	}
	return c.GrantTypes
}

func (c *CreateClientResponseContent) GetJwtConfiguration() *ClientJwtConfiguration {
	if c == nil {
		return nil
	}
	return c.JwtConfiguration
}

func (c *CreateClientResponseContent) GetSigningKeys() *ClientSigningKeys {
	if c == nil {
		return nil
	}
	return c.SigningKeys
}

func (c *CreateClientResponseContent) GetEncryptionKey() *ClientEncryptionKey {
	if c == nil {
		return nil
	}
	return c.EncryptionKey
}

func (c *CreateClientResponseContent) GetSSO() *bool {
	if c == nil {
		return nil
	}
	return c.SSO
}

func (c *CreateClientResponseContent) GetSSODisabled() *bool {
	if c == nil {
		return nil
	}
	return c.SSODisabled
}

func (c *CreateClientResponseContent) GetCrossOriginAuthentication() *bool {
	if c == nil {
		return nil
	}
	return c.CrossOriginAuthentication
}

func (c *CreateClientResponseContent) GetCrossOriginLoc() *string {
	if c == nil {
		return nil
	}
	return c.CrossOriginLoc
}

func (c *CreateClientResponseContent) GetCustomLoginPageOn() *bool {
	if c == nil {
		return nil
	}
	return c.CustomLoginPageOn
}

func (c *CreateClientResponseContent) GetCustomLoginPage() *string {
	if c == nil {
		return nil
	}
	return c.CustomLoginPage
}

func (c *CreateClientResponseContent) GetCustomLoginPagePreview() *string {
	if c == nil {
		return nil
	}
	return c.CustomLoginPagePreview
}

func (c *CreateClientResponseContent) GetFormTemplate() *string {
	if c == nil {
		return nil
	}
	return c.FormTemplate
}

func (c *CreateClientResponseContent) GetAddons() *ClientAddons {
	if c == nil {
		return nil
	}
	return c.Addons
}

func (c *CreateClientResponseContent) GetTokenEndpointAuthMethod() *ClientTokenEndpointAuthMethodEnum {
	if c == nil {
		return nil
	}
	return c.TokenEndpointAuthMethod
}

func (c *CreateClientResponseContent) GetClientMetadata() *ClientMetadata {
	if c == nil {
		return nil
	}
	return c.ClientMetadata
}

func (c *CreateClientResponseContent) GetMobile() *ClientMobile {
	if c == nil {
		return nil
	}
	return c.Mobile
}

func (c *CreateClientResponseContent) GetInitiateLoginURI() *string {
	if c == nil {
		return nil
	}
	return c.InitiateLoginURI
}

func (c *CreateClientResponseContent) GetRefreshToken() *ClientRefreshTokenConfiguration {
	if c == nil {
		return nil
	}
	return c.RefreshToken
}

func (c *CreateClientResponseContent) GetDefaultOrganization() *ClientDefaultOrganization {
	if c == nil {
		return nil
	}
	return c.DefaultOrganization
}

func (c *CreateClientResponseContent) GetOrganizationUsage() *ClientOrganizationUsageEnum {
	if c == nil {
		return nil
	}
	return c.OrganizationUsage
}

func (c *CreateClientResponseContent) GetOrganizationRequireBehavior() *ClientOrganizationRequireBehaviorEnum {
	if c == nil {
		return nil
	}
	return c.OrganizationRequireBehavior
}

func (c *CreateClientResponseContent) GetClientAuthenticationMethods() *ClientAuthenticationMethod {
	if c == nil {
		return nil
	}
	return c.ClientAuthenticationMethods
}

func (c *CreateClientResponseContent) GetRequirePushedAuthorizationRequests() *bool {
	if c == nil {
		return nil
	}
	return c.RequirePushedAuthorizationRequests
}

func (c *CreateClientResponseContent) GetRequireProofOfPossession() *bool {
	if c == nil {
		return nil
	}
	return c.RequireProofOfPossession
}

func (c *CreateClientResponseContent) GetSignedRequestObject() *ClientSignedRequestObjectWithCredentialID {
	if c == nil {
		return nil
	}
	return c.SignedRequestObject
}

func (c *CreateClientResponseContent) GetComplianceLevel() *ClientComplianceLevelEnum {
	if c == nil {
		return nil
	}
	return c.ComplianceLevel
}

func (c *CreateClientResponseContent) GetParRequestExpiry() *int {
	if c == nil {
		return nil
	}
	return c.ParRequestExpiry
}

func (c *CreateClientResponseContent) GetTokenQuota() *TokenQuota {
	if c == nil {
		return nil
	}
	return c.TokenQuota
}

func (c *CreateClientResponseContent) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *CreateClientResponseContent) UnmarshalJSON(data []byte) error {
	type embed CreateClientResponseContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateClientResponseContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateClientResponseContent) MarshalJSON() ([]byte, error) {
	type embed CreateClientResponseContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, c.ExtraProperties)
}

func (c *CreateClientResponseContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialID struct {
	// Credential ID
	ID string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CredentialID) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CredentialID) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialID) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialID(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialID) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type GetClientResponseContent struct {
	// ID of this client.
	ClientID *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// Name of the tenant this client belongs to.
	Tenant *string `json:"tenant,omitempty" url:"tenant,omitempty"`
	// Name of this client (min length: 1 character, does not allow `<` or `>`).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Free text description of this client (max length: 140 characters).
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Whether this is your global 'All Applications' client representing legacy tenant settings (true) or a regular client (false).
	Global *bool `json:"global,omitempty" url:"global,omitempty"`
	// Client secret (which you must not make public).
	ClientSecret *string `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	// Type of client used to determine which settings are applicable. Can be `spa`, `native`, `non_interactive`, or `regular_web`.
	AppType *string `json:"app_type,omitempty" url:"app_type,omitempty"`
	// URL of the logo to display for this client. Recommended size is 150x150 pixels.
	LogoURI *string `json:"logo_uri,omitempty" url:"logo_uri,omitempty"`
	// Whether this client a first party client (true) or not (false).
	IsFirstParty *bool `json:"is_first_party,omitempty" url:"is_first_party,omitempty"`
	// Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false).
	OidcConformant *bool `json:"oidc_conformant,omitempty" url:"oidc_conformant,omitempty"`
	// Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication.
	Callbacks []string `json:"callbacks,omitempty" url:"callbacks,omitempty"`
	// Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs.
	AllowedOrigins []string `json:"allowed_origins,omitempty" url:"allowed_origins,omitempty"`
	// Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>.
	WebOrigins []string `json:"web_origins,omitempty" url:"web_origins,omitempty"`
	// List of audiences/realms for SAML protocol. Used by the wsfed addon.
	ClientAliases []string `json:"client_aliases,omitempty" url:"client_aliases,omitempty"`
	// List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed.
	AllowedClients []string `json:"allowed_clients,omitempty" url:"allowed_clients,omitempty"`
	// Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains.
	AllowedLogoutURLs []string                             `json:"allowed_logout_urls,omitempty" url:"allowed_logout_urls,omitempty"`
	SessionTransfer   *ClientSessionTransferConfiguration  `json:"session_transfer,omitempty" url:"session_transfer,omitempty"`
	OidcLogout        *ClientOidcBackchannelLogoutSettings `json:"oidc_logout,omitempty" url:"oidc_logout,omitempty"`
	// List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, and `urn:ietf:params:oauth:grant-type:device_code`.
	GrantTypes       []string                `json:"grant_types,omitempty" url:"grant_types,omitempty"`
	JwtConfiguration *ClientJwtConfiguration `json:"jwt_configuration,omitempty" url:"jwt_configuration,omitempty"`
	SigningKeys      *ClientSigningKeys      `json:"signing_keys,omitempty" url:"signing_keys,omitempty"`
	EncryptionKey    *ClientEncryptionKey    `json:"encryption_key,omitempty" url:"encryption_key,omitempty"`
	// Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false).
	SSO *bool `json:"sso,omitempty" url:"sso,omitempty"`
	// Whether Single Sign On is disabled (true) or enabled (true). Defaults to true.
	SSODisabled *bool `json:"sso_disabled,omitempty" url:"sso_disabled,omitempty"`
	// Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false).
	CrossOriginAuthentication *bool `json:"cross_origin_authentication,omitempty" url:"cross_origin_authentication,omitempty"`
	// URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page.
	CrossOriginLoc *string `json:"cross_origin_loc,omitempty" url:"cross_origin_loc,omitempty"`
	// Whether a custom login page is to be used (true) or the default provided login page (false).
	CustomLoginPageOn *bool `json:"custom_login_page_on,omitempty" url:"custom_login_page_on,omitempty"`
	// The content (HTML, CSS, JS) of the custom login page.
	CustomLoginPage *string `json:"custom_login_page,omitempty" url:"custom_login_page,omitempty"`
	// The content (HTML, CSS, JS) of the custom login page. (Used on Previews)
	CustomLoginPagePreview *string `json:"custom_login_page_preview,omitempty" url:"custom_login_page_preview,omitempty"`
	// HTML form template to be used for WS-Federation.
	FormTemplate            *string                            `json:"form_template,omitempty" url:"form_template,omitempty"`
	Addons                  *ClientAddons                      `json:"addons,omitempty" url:"addons,omitempty"`
	TokenEndpointAuthMethod *ClientTokenEndpointAuthMethodEnum `json:"token_endpoint_auth_method,omitempty" url:"token_endpoint_auth_method,omitempty"`
	ClientMetadata          *ClientMetadata                    `json:"client_metadata,omitempty" url:"client_metadata,omitempty"`
	Mobile                  *ClientMobile                      `json:"mobile,omitempty" url:"mobile,omitempty"`
	// Initiate login uri, must be https
	InitiateLoginURI            *string                                `json:"initiate_login_uri,omitempty" url:"initiate_login_uri,omitempty"`
	RefreshToken                *ClientRefreshTokenConfiguration       `json:"refresh_token,omitempty" url:"refresh_token,omitempty"`
	DefaultOrganization         *ClientDefaultOrganization             `json:"default_organization,omitempty" url:"default_organization,omitempty"`
	OrganizationUsage           *ClientOrganizationUsageEnum           `json:"organization_usage,omitempty" url:"organization_usage,omitempty"`
	OrganizationRequireBehavior *ClientOrganizationRequireBehaviorEnum `json:"organization_require_behavior,omitempty" url:"organization_require_behavior,omitempty"`
	ClientAuthenticationMethods *ClientAuthenticationMethod            `json:"client_authentication_methods,omitempty" url:"client_authentication_methods,omitempty"`
	// Makes the use of Pushed Authorization Requests mandatory for this client
	RequirePushedAuthorizationRequests *bool `json:"require_pushed_authorization_requests,omitempty" url:"require_pushed_authorization_requests,omitempty"`
	// Makes the use of Proof-of-Possession mandatory for this client
	RequireProofOfPossession *bool                                      `json:"require_proof_of_possession,omitempty" url:"require_proof_of_possession,omitempty"`
	SignedRequestObject      *ClientSignedRequestObjectWithCredentialID `json:"signed_request_object,omitempty" url:"signed_request_object,omitempty"`
	ComplianceLevel          *ClientComplianceLevelEnum                 `json:"compliance_level,omitempty" url:"compliance_level,omitempty"`
	// Specifies how long, in seconds, a Pushed Authorization Request URI remains valid
	ParRequestExpiry *int        `json:"par_request_expiry,omitempty" url:"par_request_expiry,omitempty"`
	TokenQuota       *TokenQuota `json:"token_quota,omitempty" url:"token_quota,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (g *GetClientResponseContent) GetClientID() *string {
	if g == nil {
		return nil
	}
	return g.ClientID
}

func (g *GetClientResponseContent) GetTenant() *string {
	if g == nil {
		return nil
	}
	return g.Tenant
}

func (g *GetClientResponseContent) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GetClientResponseContent) GetDescription() *string {
	if g == nil {
		return nil
	}
	return g.Description
}

func (g *GetClientResponseContent) GetGlobal() *bool {
	if g == nil {
		return nil
	}
	return g.Global
}

func (g *GetClientResponseContent) GetClientSecret() *string {
	if g == nil {
		return nil
	}
	return g.ClientSecret
}

func (g *GetClientResponseContent) GetAppType() *string {
	if g == nil {
		return nil
	}
	return g.AppType
}

func (g *GetClientResponseContent) GetLogoURI() *string {
	if g == nil {
		return nil
	}
	return g.LogoURI
}

func (g *GetClientResponseContent) GetIsFirstParty() *bool {
	if g == nil {
		return nil
	}
	return g.IsFirstParty
}

func (g *GetClientResponseContent) GetOidcConformant() *bool {
	if g == nil {
		return nil
	}
	return g.OidcConformant
}

func (g *GetClientResponseContent) GetCallbacks() []string {
	if g == nil {
		return nil
	}
	return g.Callbacks
}

func (g *GetClientResponseContent) GetAllowedOrigins() []string {
	if g == nil {
		return nil
	}
	return g.AllowedOrigins
}

func (g *GetClientResponseContent) GetWebOrigins() []string {
	if g == nil {
		return nil
	}
	return g.WebOrigins
}

func (g *GetClientResponseContent) GetClientAliases() []string {
	if g == nil {
		return nil
	}
	return g.ClientAliases
}

func (g *GetClientResponseContent) GetAllowedClients() []string {
	if g == nil {
		return nil
	}
	return g.AllowedClients
}

func (g *GetClientResponseContent) GetAllowedLogoutURLs() []string {
	if g == nil {
		return nil
	}
	return g.AllowedLogoutURLs
}

func (g *GetClientResponseContent) GetSessionTransfer() *ClientSessionTransferConfiguration {
	if g == nil {
		return nil
	}
	return g.SessionTransfer
}

func (g *GetClientResponseContent) GetOidcLogout() *ClientOidcBackchannelLogoutSettings {
	if g == nil {
		return nil
	}
	return g.OidcLogout
}

func (g *GetClientResponseContent) GetGrantTypes() []string {
	if g == nil {
		return nil
	}
	return g.GrantTypes
}

func (g *GetClientResponseContent) GetJwtConfiguration() *ClientJwtConfiguration {
	if g == nil {
		return nil
	}
	return g.JwtConfiguration
}

func (g *GetClientResponseContent) GetSigningKeys() *ClientSigningKeys {
	if g == nil {
		return nil
	}
	return g.SigningKeys
}

func (g *GetClientResponseContent) GetEncryptionKey() *ClientEncryptionKey {
	if g == nil {
		return nil
	}
	return g.EncryptionKey
}

func (g *GetClientResponseContent) GetSSO() *bool {
	if g == nil {
		return nil
	}
	return g.SSO
}

func (g *GetClientResponseContent) GetSSODisabled() *bool {
	if g == nil {
		return nil
	}
	return g.SSODisabled
}

func (g *GetClientResponseContent) GetCrossOriginAuthentication() *bool {
	if g == nil {
		return nil
	}
	return g.CrossOriginAuthentication
}

func (g *GetClientResponseContent) GetCrossOriginLoc() *string {
	if g == nil {
		return nil
	}
	return g.CrossOriginLoc
}

func (g *GetClientResponseContent) GetCustomLoginPageOn() *bool {
	if g == nil {
		return nil
	}
	return g.CustomLoginPageOn
}

func (g *GetClientResponseContent) GetCustomLoginPage() *string {
	if g == nil {
		return nil
	}
	return g.CustomLoginPage
}

func (g *GetClientResponseContent) GetCustomLoginPagePreview() *string {
	if g == nil {
		return nil
	}
	return g.CustomLoginPagePreview
}

func (g *GetClientResponseContent) GetFormTemplate() *string {
	if g == nil {
		return nil
	}
	return g.FormTemplate
}

func (g *GetClientResponseContent) GetAddons() *ClientAddons {
	if g == nil {
		return nil
	}
	return g.Addons
}

func (g *GetClientResponseContent) GetTokenEndpointAuthMethod() *ClientTokenEndpointAuthMethodEnum {
	if g == nil {
		return nil
	}
	return g.TokenEndpointAuthMethod
}

func (g *GetClientResponseContent) GetClientMetadata() *ClientMetadata {
	if g == nil {
		return nil
	}
	return g.ClientMetadata
}

func (g *GetClientResponseContent) GetMobile() *ClientMobile {
	if g == nil {
		return nil
	}
	return g.Mobile
}

func (g *GetClientResponseContent) GetInitiateLoginURI() *string {
	if g == nil {
		return nil
	}
	return g.InitiateLoginURI
}

func (g *GetClientResponseContent) GetRefreshToken() *ClientRefreshTokenConfiguration {
	if g == nil {
		return nil
	}
	return g.RefreshToken
}

func (g *GetClientResponseContent) GetDefaultOrganization() *ClientDefaultOrganization {
	if g == nil {
		return nil
	}
	return g.DefaultOrganization
}

func (g *GetClientResponseContent) GetOrganizationUsage() *ClientOrganizationUsageEnum {
	if g == nil {
		return nil
	}
	return g.OrganizationUsage
}

func (g *GetClientResponseContent) GetOrganizationRequireBehavior() *ClientOrganizationRequireBehaviorEnum {
	if g == nil {
		return nil
	}
	return g.OrganizationRequireBehavior
}

func (g *GetClientResponseContent) GetClientAuthenticationMethods() *ClientAuthenticationMethod {
	if g == nil {
		return nil
	}
	return g.ClientAuthenticationMethods
}

func (g *GetClientResponseContent) GetRequirePushedAuthorizationRequests() *bool {
	if g == nil {
		return nil
	}
	return g.RequirePushedAuthorizationRequests
}

func (g *GetClientResponseContent) GetRequireProofOfPossession() *bool {
	if g == nil {
		return nil
	}
	return g.RequireProofOfPossession
}

func (g *GetClientResponseContent) GetSignedRequestObject() *ClientSignedRequestObjectWithCredentialID {
	if g == nil {
		return nil
	}
	return g.SignedRequestObject
}

func (g *GetClientResponseContent) GetComplianceLevel() *ClientComplianceLevelEnum {
	if g == nil {
		return nil
	}
	return g.ComplianceLevel
}

func (g *GetClientResponseContent) GetParRequestExpiry() *int {
	if g == nil {
		return nil
	}
	return g.ParRequestExpiry
}

func (g *GetClientResponseContent) GetTokenQuota() *TokenQuota {
	if g == nil {
		return nil
	}
	return g.TokenQuota
}

func (g *GetClientResponseContent) GetExtraProperties() map[string]interface{} {
	return g.ExtraProperties
}

func (g *GetClientResponseContent) UnmarshalJSON(data []byte) error {
	type embed GetClientResponseContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GetClientResponseContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.ExtraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetClientResponseContent) MarshalJSON() ([]byte, error) {
	type embed GetClientResponseContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, g.ExtraProperties)
}

func (g *GetClientResponseContent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListClientsOffsetPaginatedResponseContent struct {
	Start   *float64  `json:"start,omitempty" url:"start,omitempty"`
	Limit   *float64  `json:"limit,omitempty" url:"limit,omitempty"`
	Total   *float64  `json:"total,omitempty" url:"total,omitempty"`
	Clients []*Client `json:"clients,omitempty" url:"clients,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListClientsOffsetPaginatedResponseContent) GetStart() *float64 {
	if l == nil {
		return nil
	}
	return l.Start
}

func (l *ListClientsOffsetPaginatedResponseContent) GetLimit() *float64 {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListClientsOffsetPaginatedResponseContent) GetTotal() *float64 {
	if l == nil {
		return nil
	}
	return l.Total
}

func (l *ListClientsOffsetPaginatedResponseContent) GetClients() []*Client {
	if l == nil {
		return nil
	}
	return l.Clients
}

func (l *ListClientsOffsetPaginatedResponseContent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListClientsOffsetPaginatedResponseContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ListClientsOffsetPaginatedResponseContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListClientsOffsetPaginatedResponseContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListClientsOffsetPaginatedResponseContent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Configure native social settings
type NativeSocialLogin struct {
	Apple    *NativeSocialLoginApple    `json:"apple,omitempty" url:"apple,omitempty"`
	Facebook *NativeSocialLoginFacebook `json:"facebook,omitempty" url:"facebook,omitempty"`
	Google   *NativeSocialLoginGoogle   `json:"google,omitempty" url:"google,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NativeSocialLogin) GetApple() *NativeSocialLoginApple {
	if n == nil {
		return nil
	}
	return n.Apple
}

func (n *NativeSocialLogin) GetFacebook() *NativeSocialLoginFacebook {
	if n == nil {
		return nil
	}
	return n.Facebook
}

func (n *NativeSocialLogin) GetGoogle() *NativeSocialLoginGoogle {
	if n == nil {
		return nil
	}
	return n.Google
}

func (n *NativeSocialLogin) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NativeSocialLogin) UnmarshalJSON(data []byte) error {
	type unmarshaler NativeSocialLogin
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NativeSocialLogin(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NativeSocialLogin) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Native Social Login support for the Apple connection
type NativeSocialLoginApple struct {
	// Determine whether or not to allow signing in natively using an Apple authorization code
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NativeSocialLoginApple) GetEnabled() *bool {
	if n == nil {
		return nil
	}
	return n.Enabled
}

func (n *NativeSocialLoginApple) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NativeSocialLoginApple) UnmarshalJSON(data []byte) error {
	type unmarshaler NativeSocialLoginApple
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NativeSocialLoginApple(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NativeSocialLoginApple) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Native Social Login support for the Facebook connection
type NativeSocialLoginFacebook struct {
	// Determine whether or not to allow signing in natively using Facebook
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NativeSocialLoginFacebook) GetEnabled() *bool {
	if n == nil {
		return nil
	}
	return n.Enabled
}

func (n *NativeSocialLoginFacebook) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NativeSocialLoginFacebook) UnmarshalJSON(data []byte) error {
	type unmarshaler NativeSocialLoginFacebook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NativeSocialLoginFacebook(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NativeSocialLoginFacebook) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Native Social Login support for the google-oauth2 connection
type NativeSocialLoginGoogle struct {
	// Determine whether or not to allow signing in natively using a Google ID token
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NativeSocialLoginGoogle) GetEnabled() *bool {
	if n == nil {
		return nil
	}
	return n.Enabled
}

func (n *NativeSocialLoginGoogle) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NativeSocialLoginGoogle) UnmarshalJSON(data []byte) error {
	type unmarshaler NativeSocialLoginGoogle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NativeSocialLoginGoogle(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NativeSocialLoginGoogle) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Defines `private_key_jwt` client authentication method. If this property is defined, the client is enabled to use the Private Key JWT authentication method.
type PrivateKeyJwt struct {
	Credentials PrivateKeyJwtCredentials `json:"credentials" url:"credentials"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PrivateKeyJwt) GetCredentials() PrivateKeyJwtCredentials {
	if p == nil {
		return nil
	}
	return p.Credentials
}

func (p *PrivateKeyJwt) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PrivateKeyJwt) UnmarshalJSON(data []byte) error {
	type unmarshaler PrivateKeyJwt
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PrivateKeyJwt(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PrivateKeyJwt) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A list of unique and previously created credential IDs enabled on the client for Private Key JWT authentication.
type PrivateKeyJwtCredentials = []*CredentialID

type PublicKeyCredential struct {
	CredentialType PublicKeyCredentialTypeEnum `json:"credential_type" url:"credential_type"`
	// Friendly name for a credential.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped.
	Pem string                            `json:"pem" url:"pem"`
	Alg *PublicKeyCredentialAlgorithmEnum `json:"alg,omitempty" url:"alg,omitempty"`
	// Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. Applies to `public_key` credential type.
	ParseExpiryFromCert *bool `json:"parse_expiry_from_cert,omitempty" url:"parse_expiry_from_cert,omitempty"`
	// The ISO 8601 formatted date representing the expiration of the credential. If not specified (not recommended), the credential never expires. Applies to `public_key` credential type.
	ExpiresAt *time.Time `json:"expires_at,omitempty" url:"expires_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PublicKeyCredential) GetName() *string {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PublicKeyCredential) GetPem() string {
	if p == nil {
		return ""
	}
	return p.Pem
}

func (p *PublicKeyCredential) GetAlg() *PublicKeyCredentialAlgorithmEnum {
	if p == nil {
		return nil
	}
	return p.Alg
}

func (p *PublicKeyCredential) GetParseExpiryFromCert() *bool {
	if p == nil {
		return nil
	}
	return p.ParseExpiryFromCert
}

func (p *PublicKeyCredential) GetExpiresAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ExpiresAt
}

func (p *PublicKeyCredential) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PublicKeyCredential) UnmarshalJSON(data []byte) error {
	type embed PublicKeyCredential
	var unmarshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expires_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PublicKeyCredential(unmarshaler.embed)
	p.ExpiresAt = unmarshaler.ExpiresAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PublicKeyCredential) MarshalJSON() ([]byte, error) {
	type embed PublicKeyCredential
	var marshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expires_at,omitempty"`
	}{
		embed:     embed(*p),
		ExpiresAt: internal.NewOptionalDateTime(p.ExpiresAt),
	}
	return json.Marshal(marshaler)
}

func (p *PublicKeyCredential) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Credential type. Supported types: public_key.
type PublicKeyCredentialTypeEnum = string

// Refresh token expiration types, one of: expiring, non-expiring
type RefreshTokenExpirationTypeEnum string

const (
	RefreshTokenExpirationTypeEnumExpiring    RefreshTokenExpirationTypeEnum = "expiring"
	RefreshTokenExpirationTypeEnumNonExpiring RefreshTokenExpirationTypeEnum = "non-expiring"
)

func NewRefreshTokenExpirationTypeEnumFromString(s string) (RefreshTokenExpirationTypeEnum, error) {
	switch s {
	case "expiring":
		return RefreshTokenExpirationTypeEnumExpiring, nil
	case "non-expiring":
		return RefreshTokenExpirationTypeEnumNonExpiring, nil
	}
	var t RefreshTokenExpirationTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RefreshTokenExpirationTypeEnum) Ptr() *RefreshTokenExpirationTypeEnum {
	return &r
}

// Refresh token rotation types, one of: rotating, non-rotating
type RefreshTokenRotationTypeEnum string

const (
	RefreshTokenRotationTypeEnumRotating    RefreshTokenRotationTypeEnum = "rotating"
	RefreshTokenRotationTypeEnumNonRotating RefreshTokenRotationTypeEnum = "non-rotating"
)

func NewRefreshTokenRotationTypeEnumFromString(s string) (RefreshTokenRotationTypeEnum, error) {
	switch s {
	case "rotating":
		return RefreshTokenRotationTypeEnumRotating, nil
	case "non-rotating":
		return RefreshTokenRotationTypeEnumNonRotating, nil
	}
	var t RefreshTokenRotationTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RefreshTokenRotationTypeEnum) Ptr() *RefreshTokenRotationTypeEnum {
	return &r
}

type RotateClientSecretResponseContent struct {
	// ID of this client.
	ClientID *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// Name of the tenant this client belongs to.
	Tenant *string `json:"tenant,omitempty" url:"tenant,omitempty"`
	// Name of this client (min length: 1 character, does not allow `<` or `>`).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Free text description of this client (max length: 140 characters).
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Whether this is your global 'All Applications' client representing legacy tenant settings (true) or a regular client (false).
	Global *bool `json:"global,omitempty" url:"global,omitempty"`
	// Client secret (which you must not make public).
	ClientSecret *string `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	// Type of client used to determine which settings are applicable. Can be `spa`, `native`, `non_interactive`, or `regular_web`.
	AppType *string `json:"app_type,omitempty" url:"app_type,omitempty"`
	// URL of the logo to display for this client. Recommended size is 150x150 pixels.
	LogoURI *string `json:"logo_uri,omitempty" url:"logo_uri,omitempty"`
	// Whether this client a first party client (true) or not (false).
	IsFirstParty *bool `json:"is_first_party,omitempty" url:"is_first_party,omitempty"`
	// Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false).
	OidcConformant *bool `json:"oidc_conformant,omitempty" url:"oidc_conformant,omitempty"`
	// Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication.
	Callbacks []string `json:"callbacks,omitempty" url:"callbacks,omitempty"`
	// Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs.
	AllowedOrigins []string `json:"allowed_origins,omitempty" url:"allowed_origins,omitempty"`
	// Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>.
	WebOrigins []string `json:"web_origins,omitempty" url:"web_origins,omitempty"`
	// List of audiences/realms for SAML protocol. Used by the wsfed addon.
	ClientAliases []string `json:"client_aliases,omitempty" url:"client_aliases,omitempty"`
	// List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed.
	AllowedClients []string `json:"allowed_clients,omitempty" url:"allowed_clients,omitempty"`
	// Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains.
	AllowedLogoutURLs []string                             `json:"allowed_logout_urls,omitempty" url:"allowed_logout_urls,omitempty"`
	SessionTransfer   *ClientSessionTransferConfiguration  `json:"session_transfer,omitempty" url:"session_transfer,omitempty"`
	OidcLogout        *ClientOidcBackchannelLogoutSettings `json:"oidc_logout,omitempty" url:"oidc_logout,omitempty"`
	// List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, and `urn:ietf:params:oauth:grant-type:device_code`.
	GrantTypes       []string                `json:"grant_types,omitempty" url:"grant_types,omitempty"`
	JwtConfiguration *ClientJwtConfiguration `json:"jwt_configuration,omitempty" url:"jwt_configuration,omitempty"`
	SigningKeys      *ClientSigningKeys      `json:"signing_keys,omitempty" url:"signing_keys,omitempty"`
	EncryptionKey    *ClientEncryptionKey    `json:"encryption_key,omitempty" url:"encryption_key,omitempty"`
	// Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false).
	SSO *bool `json:"sso,omitempty" url:"sso,omitempty"`
	// Whether Single Sign On is disabled (true) or enabled (true). Defaults to true.
	SSODisabled *bool `json:"sso_disabled,omitempty" url:"sso_disabled,omitempty"`
	// Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false).
	CrossOriginAuthentication *bool `json:"cross_origin_authentication,omitempty" url:"cross_origin_authentication,omitempty"`
	// URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page.
	CrossOriginLoc *string `json:"cross_origin_loc,omitempty" url:"cross_origin_loc,omitempty"`
	// Whether a custom login page is to be used (true) or the default provided login page (false).
	CustomLoginPageOn *bool `json:"custom_login_page_on,omitempty" url:"custom_login_page_on,omitempty"`
	// The content (HTML, CSS, JS) of the custom login page.
	CustomLoginPage *string `json:"custom_login_page,omitempty" url:"custom_login_page,omitempty"`
	// The content (HTML, CSS, JS) of the custom login page. (Used on Previews)
	CustomLoginPagePreview *string `json:"custom_login_page_preview,omitempty" url:"custom_login_page_preview,omitempty"`
	// HTML form template to be used for WS-Federation.
	FormTemplate            *string                            `json:"form_template,omitempty" url:"form_template,omitempty"`
	Addons                  *ClientAddons                      `json:"addons,omitempty" url:"addons,omitempty"`
	TokenEndpointAuthMethod *ClientTokenEndpointAuthMethodEnum `json:"token_endpoint_auth_method,omitempty" url:"token_endpoint_auth_method,omitempty"`
	ClientMetadata          *ClientMetadata                    `json:"client_metadata,omitempty" url:"client_metadata,omitempty"`
	Mobile                  *ClientMobile                      `json:"mobile,omitempty" url:"mobile,omitempty"`
	// Initiate login uri, must be https
	InitiateLoginURI            *string                                `json:"initiate_login_uri,omitempty" url:"initiate_login_uri,omitempty"`
	RefreshToken                *ClientRefreshTokenConfiguration       `json:"refresh_token,omitempty" url:"refresh_token,omitempty"`
	DefaultOrganization         *ClientDefaultOrganization             `json:"default_organization,omitempty" url:"default_organization,omitempty"`
	OrganizationUsage           *ClientOrganizationUsageEnum           `json:"organization_usage,omitempty" url:"organization_usage,omitempty"`
	OrganizationRequireBehavior *ClientOrganizationRequireBehaviorEnum `json:"organization_require_behavior,omitempty" url:"organization_require_behavior,omitempty"`
	ClientAuthenticationMethods *ClientAuthenticationMethod            `json:"client_authentication_methods,omitempty" url:"client_authentication_methods,omitempty"`
	// Makes the use of Pushed Authorization Requests mandatory for this client
	RequirePushedAuthorizationRequests *bool `json:"require_pushed_authorization_requests,omitempty" url:"require_pushed_authorization_requests,omitempty"`
	// Makes the use of Proof-of-Possession mandatory for this client
	RequireProofOfPossession *bool                                      `json:"require_proof_of_possession,omitempty" url:"require_proof_of_possession,omitempty"`
	SignedRequestObject      *ClientSignedRequestObjectWithCredentialID `json:"signed_request_object,omitempty" url:"signed_request_object,omitempty"`
	ComplianceLevel          *ClientComplianceLevelEnum                 `json:"compliance_level,omitempty" url:"compliance_level,omitempty"`
	// Specifies how long, in seconds, a Pushed Authorization Request URI remains valid
	ParRequestExpiry *int        `json:"par_request_expiry,omitempty" url:"par_request_expiry,omitempty"`
	TokenQuota       *TokenQuota `json:"token_quota,omitempty" url:"token_quota,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (r *RotateClientSecretResponseContent) GetClientID() *string {
	if r == nil {
		return nil
	}
	return r.ClientID
}

func (r *RotateClientSecretResponseContent) GetTenant() *string {
	if r == nil {
		return nil
	}
	return r.Tenant
}

func (r *RotateClientSecretResponseContent) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RotateClientSecretResponseContent) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RotateClientSecretResponseContent) GetGlobal() *bool {
	if r == nil {
		return nil
	}
	return r.Global
}

func (r *RotateClientSecretResponseContent) GetClientSecret() *string {
	if r == nil {
		return nil
	}
	return r.ClientSecret
}

func (r *RotateClientSecretResponseContent) GetAppType() *string {
	if r == nil {
		return nil
	}
	return r.AppType
}

func (r *RotateClientSecretResponseContent) GetLogoURI() *string {
	if r == nil {
		return nil
	}
	return r.LogoURI
}

func (r *RotateClientSecretResponseContent) GetIsFirstParty() *bool {
	if r == nil {
		return nil
	}
	return r.IsFirstParty
}

func (r *RotateClientSecretResponseContent) GetOidcConformant() *bool {
	if r == nil {
		return nil
	}
	return r.OidcConformant
}

func (r *RotateClientSecretResponseContent) GetCallbacks() []string {
	if r == nil {
		return nil
	}
	return r.Callbacks
}

func (r *RotateClientSecretResponseContent) GetAllowedOrigins() []string {
	if r == nil {
		return nil
	}
	return r.AllowedOrigins
}

func (r *RotateClientSecretResponseContent) GetWebOrigins() []string {
	if r == nil {
		return nil
	}
	return r.WebOrigins
}

func (r *RotateClientSecretResponseContent) GetClientAliases() []string {
	if r == nil {
		return nil
	}
	return r.ClientAliases
}

func (r *RotateClientSecretResponseContent) GetAllowedClients() []string {
	if r == nil {
		return nil
	}
	return r.AllowedClients
}

func (r *RotateClientSecretResponseContent) GetAllowedLogoutURLs() []string {
	if r == nil {
		return nil
	}
	return r.AllowedLogoutURLs
}

func (r *RotateClientSecretResponseContent) GetSessionTransfer() *ClientSessionTransferConfiguration {
	if r == nil {
		return nil
	}
	return r.SessionTransfer
}

func (r *RotateClientSecretResponseContent) GetOidcLogout() *ClientOidcBackchannelLogoutSettings {
	if r == nil {
		return nil
	}
	return r.OidcLogout
}

func (r *RotateClientSecretResponseContent) GetGrantTypes() []string {
	if r == nil {
		return nil
	}
	return r.GrantTypes
}

func (r *RotateClientSecretResponseContent) GetJwtConfiguration() *ClientJwtConfiguration {
	if r == nil {
		return nil
	}
	return r.JwtConfiguration
}

func (r *RotateClientSecretResponseContent) GetSigningKeys() *ClientSigningKeys {
	if r == nil {
		return nil
	}
	return r.SigningKeys
}

func (r *RotateClientSecretResponseContent) GetEncryptionKey() *ClientEncryptionKey {
	if r == nil {
		return nil
	}
	return r.EncryptionKey
}

func (r *RotateClientSecretResponseContent) GetSSO() *bool {
	if r == nil {
		return nil
	}
	return r.SSO
}

func (r *RotateClientSecretResponseContent) GetSSODisabled() *bool {
	if r == nil {
		return nil
	}
	return r.SSODisabled
}

func (r *RotateClientSecretResponseContent) GetCrossOriginAuthentication() *bool {
	if r == nil {
		return nil
	}
	return r.CrossOriginAuthentication
}

func (r *RotateClientSecretResponseContent) GetCrossOriginLoc() *string {
	if r == nil {
		return nil
	}
	return r.CrossOriginLoc
}

func (r *RotateClientSecretResponseContent) GetCustomLoginPageOn() *bool {
	if r == nil {
		return nil
	}
	return r.CustomLoginPageOn
}

func (r *RotateClientSecretResponseContent) GetCustomLoginPage() *string {
	if r == nil {
		return nil
	}
	return r.CustomLoginPage
}

func (r *RotateClientSecretResponseContent) GetCustomLoginPagePreview() *string {
	if r == nil {
		return nil
	}
	return r.CustomLoginPagePreview
}

func (r *RotateClientSecretResponseContent) GetFormTemplate() *string {
	if r == nil {
		return nil
	}
	return r.FormTemplate
}

func (r *RotateClientSecretResponseContent) GetAddons() *ClientAddons {
	if r == nil {
		return nil
	}
	return r.Addons
}

func (r *RotateClientSecretResponseContent) GetTokenEndpointAuthMethod() *ClientTokenEndpointAuthMethodEnum {
	if r == nil {
		return nil
	}
	return r.TokenEndpointAuthMethod
}

func (r *RotateClientSecretResponseContent) GetClientMetadata() *ClientMetadata {
	if r == nil {
		return nil
	}
	return r.ClientMetadata
}

func (r *RotateClientSecretResponseContent) GetMobile() *ClientMobile {
	if r == nil {
		return nil
	}
	return r.Mobile
}

func (r *RotateClientSecretResponseContent) GetInitiateLoginURI() *string {
	if r == nil {
		return nil
	}
	return r.InitiateLoginURI
}

func (r *RotateClientSecretResponseContent) GetRefreshToken() *ClientRefreshTokenConfiguration {
	if r == nil {
		return nil
	}
	return r.RefreshToken
}

func (r *RotateClientSecretResponseContent) GetDefaultOrganization() *ClientDefaultOrganization {
	if r == nil {
		return nil
	}
	return r.DefaultOrganization
}

func (r *RotateClientSecretResponseContent) GetOrganizationUsage() *ClientOrganizationUsageEnum {
	if r == nil {
		return nil
	}
	return r.OrganizationUsage
}

func (r *RotateClientSecretResponseContent) GetOrganizationRequireBehavior() *ClientOrganizationRequireBehaviorEnum {
	if r == nil {
		return nil
	}
	return r.OrganizationRequireBehavior
}

func (r *RotateClientSecretResponseContent) GetClientAuthenticationMethods() *ClientAuthenticationMethod {
	if r == nil {
		return nil
	}
	return r.ClientAuthenticationMethods
}

func (r *RotateClientSecretResponseContent) GetRequirePushedAuthorizationRequests() *bool {
	if r == nil {
		return nil
	}
	return r.RequirePushedAuthorizationRequests
}

func (r *RotateClientSecretResponseContent) GetRequireProofOfPossession() *bool {
	if r == nil {
		return nil
	}
	return r.RequireProofOfPossession
}

func (r *RotateClientSecretResponseContent) GetSignedRequestObject() *ClientSignedRequestObjectWithCredentialID {
	if r == nil {
		return nil
	}
	return r.SignedRequestObject
}

func (r *RotateClientSecretResponseContent) GetComplianceLevel() *ClientComplianceLevelEnum {
	if r == nil {
		return nil
	}
	return r.ComplianceLevel
}

func (r *RotateClientSecretResponseContent) GetParRequestExpiry() *int {
	if r == nil {
		return nil
	}
	return r.ParRequestExpiry
}

func (r *RotateClientSecretResponseContent) GetTokenQuota() *TokenQuota {
	if r == nil {
		return nil
	}
	return r.TokenQuota
}

func (r *RotateClientSecretResponseContent) GetExtraProperties() map[string]interface{} {
	return r.ExtraProperties
}

func (r *RotateClientSecretResponseContent) UnmarshalJSON(data []byte) error {
	type embed RotateClientSecretResponseContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RotateClientSecretResponseContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.ExtraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RotateClientSecretResponseContent) MarshalJSON() ([]byte, error) {
	type embed RotateClientSecretResponseContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, r.ExtraProperties)
}

func (r *RotateClientSecretResponseContent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type UpdateClientResponseContent struct {
	// ID of this client.
	ClientID *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// Name of the tenant this client belongs to.
	Tenant *string `json:"tenant,omitempty" url:"tenant,omitempty"`
	// Name of this client (min length: 1 character, does not allow `<` or `>`).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Free text description of this client (max length: 140 characters).
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Whether this is your global 'All Applications' client representing legacy tenant settings (true) or a regular client (false).
	Global *bool `json:"global,omitempty" url:"global,omitempty"`
	// Client secret (which you must not make public).
	ClientSecret *string `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	// Type of client used to determine which settings are applicable. Can be `spa`, `native`, `non_interactive`, or `regular_web`.
	AppType *string `json:"app_type,omitempty" url:"app_type,omitempty"`
	// URL of the logo to display for this client. Recommended size is 150x150 pixels.
	LogoURI *string `json:"logo_uri,omitempty" url:"logo_uri,omitempty"`
	// Whether this client a first party client (true) or not (false).
	IsFirstParty *bool `json:"is_first_party,omitempty" url:"is_first_party,omitempty"`
	// Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false).
	OidcConformant *bool `json:"oidc_conformant,omitempty" url:"oidc_conformant,omitempty"`
	// Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication.
	Callbacks []string `json:"callbacks,omitempty" url:"callbacks,omitempty"`
	// Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs.
	AllowedOrigins []string `json:"allowed_origins,omitempty" url:"allowed_origins,omitempty"`
	// Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>.
	WebOrigins []string `json:"web_origins,omitempty" url:"web_origins,omitempty"`
	// List of audiences/realms for SAML protocol. Used by the wsfed addon.
	ClientAliases []string `json:"client_aliases,omitempty" url:"client_aliases,omitempty"`
	// List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed.
	AllowedClients []string `json:"allowed_clients,omitempty" url:"allowed_clients,omitempty"`
	// Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains.
	AllowedLogoutURLs []string                             `json:"allowed_logout_urls,omitempty" url:"allowed_logout_urls,omitempty"`
	SessionTransfer   *ClientSessionTransferConfiguration  `json:"session_transfer,omitempty" url:"session_transfer,omitempty"`
	OidcLogout        *ClientOidcBackchannelLogoutSettings `json:"oidc_logout,omitempty" url:"oidc_logout,omitempty"`
	// List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, and `urn:ietf:params:oauth:grant-type:device_code`.
	GrantTypes       []string                `json:"grant_types,omitempty" url:"grant_types,omitempty"`
	JwtConfiguration *ClientJwtConfiguration `json:"jwt_configuration,omitempty" url:"jwt_configuration,omitempty"`
	SigningKeys      *ClientSigningKeys      `json:"signing_keys,omitempty" url:"signing_keys,omitempty"`
	EncryptionKey    *ClientEncryptionKey    `json:"encryption_key,omitempty" url:"encryption_key,omitempty"`
	// Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false).
	SSO *bool `json:"sso,omitempty" url:"sso,omitempty"`
	// Whether Single Sign On is disabled (true) or enabled (true). Defaults to true.
	SSODisabled *bool `json:"sso_disabled,omitempty" url:"sso_disabled,omitempty"`
	// Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false).
	CrossOriginAuthentication *bool `json:"cross_origin_authentication,omitempty" url:"cross_origin_authentication,omitempty"`
	// URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page.
	CrossOriginLoc *string `json:"cross_origin_loc,omitempty" url:"cross_origin_loc,omitempty"`
	// Whether a custom login page is to be used (true) or the default provided login page (false).
	CustomLoginPageOn *bool `json:"custom_login_page_on,omitempty" url:"custom_login_page_on,omitempty"`
	// The content (HTML, CSS, JS) of the custom login page.
	CustomLoginPage *string `json:"custom_login_page,omitempty" url:"custom_login_page,omitempty"`
	// The content (HTML, CSS, JS) of the custom login page. (Used on Previews)
	CustomLoginPagePreview *string `json:"custom_login_page_preview,omitempty" url:"custom_login_page_preview,omitempty"`
	// HTML form template to be used for WS-Federation.
	FormTemplate            *string                            `json:"form_template,omitempty" url:"form_template,omitempty"`
	Addons                  *ClientAddons                      `json:"addons,omitempty" url:"addons,omitempty"`
	TokenEndpointAuthMethod *ClientTokenEndpointAuthMethodEnum `json:"token_endpoint_auth_method,omitempty" url:"token_endpoint_auth_method,omitempty"`
	ClientMetadata          *ClientMetadata                    `json:"client_metadata,omitempty" url:"client_metadata,omitempty"`
	Mobile                  *ClientMobile                      `json:"mobile,omitempty" url:"mobile,omitempty"`
	// Initiate login uri, must be https
	InitiateLoginURI            *string                                `json:"initiate_login_uri,omitempty" url:"initiate_login_uri,omitempty"`
	RefreshToken                *ClientRefreshTokenConfiguration       `json:"refresh_token,omitempty" url:"refresh_token,omitempty"`
	DefaultOrganization         *ClientDefaultOrganization             `json:"default_organization,omitempty" url:"default_organization,omitempty"`
	OrganizationUsage           *ClientOrganizationUsageEnum           `json:"organization_usage,omitempty" url:"organization_usage,omitempty"`
	OrganizationRequireBehavior *ClientOrganizationRequireBehaviorEnum `json:"organization_require_behavior,omitempty" url:"organization_require_behavior,omitempty"`
	ClientAuthenticationMethods *ClientAuthenticationMethod            `json:"client_authentication_methods,omitempty" url:"client_authentication_methods,omitempty"`
	// Makes the use of Pushed Authorization Requests mandatory for this client
	RequirePushedAuthorizationRequests *bool `json:"require_pushed_authorization_requests,omitempty" url:"require_pushed_authorization_requests,omitempty"`
	// Makes the use of Proof-of-Possession mandatory for this client
	RequireProofOfPossession *bool                                      `json:"require_proof_of_possession,omitempty" url:"require_proof_of_possession,omitempty"`
	SignedRequestObject      *ClientSignedRequestObjectWithCredentialID `json:"signed_request_object,omitempty" url:"signed_request_object,omitempty"`
	ComplianceLevel          *ClientComplianceLevelEnum                 `json:"compliance_level,omitempty" url:"compliance_level,omitempty"`
	// Specifies how long, in seconds, a Pushed Authorization Request URI remains valid
	ParRequestExpiry *int        `json:"par_request_expiry,omitempty" url:"par_request_expiry,omitempty"`
	TokenQuota       *TokenQuota `json:"token_quota,omitempty" url:"token_quota,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (u *UpdateClientResponseContent) GetClientID() *string {
	if u == nil {
		return nil
	}
	return u.ClientID
}

func (u *UpdateClientResponseContent) GetTenant() *string {
	if u == nil {
		return nil
	}
	return u.Tenant
}

func (u *UpdateClientResponseContent) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateClientResponseContent) GetDescription() *string {
	if u == nil {
		return nil
	}
	return u.Description
}

func (u *UpdateClientResponseContent) GetGlobal() *bool {
	if u == nil {
		return nil
	}
	return u.Global
}

func (u *UpdateClientResponseContent) GetClientSecret() *string {
	if u == nil {
		return nil
	}
	return u.ClientSecret
}

func (u *UpdateClientResponseContent) GetAppType() *string {
	if u == nil {
		return nil
	}
	return u.AppType
}

func (u *UpdateClientResponseContent) GetLogoURI() *string {
	if u == nil {
		return nil
	}
	return u.LogoURI
}

func (u *UpdateClientResponseContent) GetIsFirstParty() *bool {
	if u == nil {
		return nil
	}
	return u.IsFirstParty
}

func (u *UpdateClientResponseContent) GetOidcConformant() *bool {
	if u == nil {
		return nil
	}
	return u.OidcConformant
}

func (u *UpdateClientResponseContent) GetCallbacks() []string {
	if u == nil {
		return nil
	}
	return u.Callbacks
}

func (u *UpdateClientResponseContent) GetAllowedOrigins() []string {
	if u == nil {
		return nil
	}
	return u.AllowedOrigins
}

func (u *UpdateClientResponseContent) GetWebOrigins() []string {
	if u == nil {
		return nil
	}
	return u.WebOrigins
}

func (u *UpdateClientResponseContent) GetClientAliases() []string {
	if u == nil {
		return nil
	}
	return u.ClientAliases
}

func (u *UpdateClientResponseContent) GetAllowedClients() []string {
	if u == nil {
		return nil
	}
	return u.AllowedClients
}

func (u *UpdateClientResponseContent) GetAllowedLogoutURLs() []string {
	if u == nil {
		return nil
	}
	return u.AllowedLogoutURLs
}

func (u *UpdateClientResponseContent) GetSessionTransfer() *ClientSessionTransferConfiguration {
	if u == nil {
		return nil
	}
	return u.SessionTransfer
}

func (u *UpdateClientResponseContent) GetOidcLogout() *ClientOidcBackchannelLogoutSettings {
	if u == nil {
		return nil
	}
	return u.OidcLogout
}

func (u *UpdateClientResponseContent) GetGrantTypes() []string {
	if u == nil {
		return nil
	}
	return u.GrantTypes
}

func (u *UpdateClientResponseContent) GetJwtConfiguration() *ClientJwtConfiguration {
	if u == nil {
		return nil
	}
	return u.JwtConfiguration
}

func (u *UpdateClientResponseContent) GetSigningKeys() *ClientSigningKeys {
	if u == nil {
		return nil
	}
	return u.SigningKeys
}

func (u *UpdateClientResponseContent) GetEncryptionKey() *ClientEncryptionKey {
	if u == nil {
		return nil
	}
	return u.EncryptionKey
}

func (u *UpdateClientResponseContent) GetSSO() *bool {
	if u == nil {
		return nil
	}
	return u.SSO
}

func (u *UpdateClientResponseContent) GetSSODisabled() *bool {
	if u == nil {
		return nil
	}
	return u.SSODisabled
}

func (u *UpdateClientResponseContent) GetCrossOriginAuthentication() *bool {
	if u == nil {
		return nil
	}
	return u.CrossOriginAuthentication
}

func (u *UpdateClientResponseContent) GetCrossOriginLoc() *string {
	if u == nil {
		return nil
	}
	return u.CrossOriginLoc
}

func (u *UpdateClientResponseContent) GetCustomLoginPageOn() *bool {
	if u == nil {
		return nil
	}
	return u.CustomLoginPageOn
}

func (u *UpdateClientResponseContent) GetCustomLoginPage() *string {
	if u == nil {
		return nil
	}
	return u.CustomLoginPage
}

func (u *UpdateClientResponseContent) GetCustomLoginPagePreview() *string {
	if u == nil {
		return nil
	}
	return u.CustomLoginPagePreview
}

func (u *UpdateClientResponseContent) GetFormTemplate() *string {
	if u == nil {
		return nil
	}
	return u.FormTemplate
}

func (u *UpdateClientResponseContent) GetAddons() *ClientAddons {
	if u == nil {
		return nil
	}
	return u.Addons
}

func (u *UpdateClientResponseContent) GetTokenEndpointAuthMethod() *ClientTokenEndpointAuthMethodEnum {
	if u == nil {
		return nil
	}
	return u.TokenEndpointAuthMethod
}

func (u *UpdateClientResponseContent) GetClientMetadata() *ClientMetadata {
	if u == nil {
		return nil
	}
	return u.ClientMetadata
}

func (u *UpdateClientResponseContent) GetMobile() *ClientMobile {
	if u == nil {
		return nil
	}
	return u.Mobile
}

func (u *UpdateClientResponseContent) GetInitiateLoginURI() *string {
	if u == nil {
		return nil
	}
	return u.InitiateLoginURI
}

func (u *UpdateClientResponseContent) GetRefreshToken() *ClientRefreshTokenConfiguration {
	if u == nil {
		return nil
	}
	return u.RefreshToken
}

func (u *UpdateClientResponseContent) GetDefaultOrganization() *ClientDefaultOrganization {
	if u == nil {
		return nil
	}
	return u.DefaultOrganization
}

func (u *UpdateClientResponseContent) GetOrganizationUsage() *ClientOrganizationUsageEnum {
	if u == nil {
		return nil
	}
	return u.OrganizationUsage
}

func (u *UpdateClientResponseContent) GetOrganizationRequireBehavior() *ClientOrganizationRequireBehaviorEnum {
	if u == nil {
		return nil
	}
	return u.OrganizationRequireBehavior
}

func (u *UpdateClientResponseContent) GetClientAuthenticationMethods() *ClientAuthenticationMethod {
	if u == nil {
		return nil
	}
	return u.ClientAuthenticationMethods
}

func (u *UpdateClientResponseContent) GetRequirePushedAuthorizationRequests() *bool {
	if u == nil {
		return nil
	}
	return u.RequirePushedAuthorizationRequests
}

func (u *UpdateClientResponseContent) GetRequireProofOfPossession() *bool {
	if u == nil {
		return nil
	}
	return u.RequireProofOfPossession
}

func (u *UpdateClientResponseContent) GetSignedRequestObject() *ClientSignedRequestObjectWithCredentialID {
	if u == nil {
		return nil
	}
	return u.SignedRequestObject
}

func (u *UpdateClientResponseContent) GetComplianceLevel() *ClientComplianceLevelEnum {
	if u == nil {
		return nil
	}
	return u.ComplianceLevel
}

func (u *UpdateClientResponseContent) GetParRequestExpiry() *int {
	if u == nil {
		return nil
	}
	return u.ParRequestExpiry
}

func (u *UpdateClientResponseContent) GetTokenQuota() *TokenQuota {
	if u == nil {
		return nil
	}
	return u.TokenQuota
}

func (u *UpdateClientResponseContent) GetExtraProperties() map[string]interface{} {
	return u.ExtraProperties
}

func (u *UpdateClientResponseContent) UnmarshalJSON(data []byte) error {
	type embed UpdateClientResponseContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateClientResponseContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.ExtraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateClientResponseContent) MarshalJSON() ([]byte, error) {
	type embed UpdateClientResponseContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, u.ExtraProperties)
}

func (u *UpdateClientResponseContent) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateClientRequestContent struct {
	// The name of the client. Must contain at least one character. Does not allow '<' or '>'.
	Name *string `json:"name,omitempty" url:"-"`
	// Free text description of the purpose of the Client. (Max character length: <code>140</code>)
	Description *string `json:"description,omitempty" url:"-"`
	// The secret used to sign tokens for the client
	ClientSecret *string `json:"client_secret,omitempty" url:"-"`
	// The URL of the client logo (recommended size: 150x150)
	LogoURI *string `json:"logo_uri,omitempty" url:"-"`
	// A set of URLs that are valid to call back from Auth0 when authenticating users
	Callbacks             []string                             `json:"callbacks,omitempty" url:"-"`
	OidcLogout            *ClientOidcBackchannelLogoutSettings `json:"oidc_logout,omitempty" url:"-"`
	OidcBackchannelLogout *ClientOidcBackchannelLogoutSettings `json:"oidc_backchannel_logout,omitempty" url:"-"`
	SessionTransfer       *ClientSessionTransferConfiguration  `json:"session_transfer,omitempty" url:"-"`
	// A set of URLs that represents valid origins for CORS
	AllowedOrigins []string `json:"allowed_origins,omitempty" url:"-"`
	// A set of URLs that represents valid web origins for use with web message response mode
	WebOrigins []string `json:"web_origins,omitempty" url:"-"`
	// A set of grant types that the client is authorized to use. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, and `urn:ietf:params:oauth:grant-type:device_code`.
	GrantTypes []string `json:"grant_types,omitempty" url:"-"`
	// List of audiences for SAML protocol
	ClientAliases []string `json:"client_aliases,omitempty" url:"-"`
	// Ids of clients that will be allowed to perform delegation requests. Clients that will be allowed to make delegation request. By default, all your clients will be allowed. This field allows you to specify specific clients
	AllowedClients []string `json:"allowed_clients,omitempty" url:"-"`
	// URLs that are valid to redirect to after logout from Auth0.
	AllowedLogoutURLs []string                `json:"allowed_logout_urls,omitempty" url:"-"`
	JwtConfiguration  *ClientJwtConfiguration `json:"jwt_configuration,omitempty" url:"-"`
	EncryptionKey     *ClientEncryptionKey    `json:"encryption_key,omitempty" url:"-"`
	// <code>true</code> to use Auth0 instead of the IdP to do Single Sign On, <code>false</code> otherwise (default: <code>false</code>)
	SSO *bool `json:"sso,omitempty" url:"-"`
	// <code>true</code> if this client can be used to make cross-origin authentication requests, <code>false</code> otherwise if cross origin is disabled
	CrossOriginAuthentication *bool `json:"cross_origin_authentication,omitempty" url:"-"`
	// URL for the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page.
	CrossOriginLoc *string `json:"cross_origin_loc,omitempty" url:"-"`
	// <code>true</code> to disable Single Sign On, <code>false</code> otherwise (default: <code>false</code>)
	SSODisabled *bool `json:"sso_disabled,omitempty" url:"-"`
	// <code>true</code> if the custom login page is to be used, <code>false</code> otherwise.
	CustomLoginPageOn       *bool                                    `json:"custom_login_page_on,omitempty" url:"-"`
	TokenEndpointAuthMethod *ClientTokenEndpointAuthMethodOrNullEnum `json:"token_endpoint_auth_method,omitempty" url:"-"`
	AppType                 *ClientAppTypeEnum                       `json:"app_type,omitempty" url:"-"`
	// Whether this client a first party client or not
	IsFirstParty *bool `json:"is_first_party,omitempty" url:"-"`
	// Whether this client will conform to strict OIDC specifications
	OidcConformant *bool `json:"oidc_conformant,omitempty" url:"-"`
	// The content (HTML, CSS, JS) of the custom login page
	CustomLoginPage        *string           `json:"custom_login_page,omitempty" url:"-"`
	CustomLoginPagePreview *string           `json:"custom_login_page_preview,omitempty" url:"-"`
	TokenQuota             *UpdateTokenQuota `json:"token_quota,omitempty" url:"-"`
	// Form template for WS-Federation protocol
	FormTemplate   *string         `json:"form_template,omitempty" url:"-"`
	Addons         *ClientAddons   `json:"addons,omitempty" url:"-"`
	ClientMetadata *ClientMetadata `json:"client_metadata,omitempty" url:"-"`
	Mobile         *ClientMobile   `json:"mobile,omitempty" url:"-"`
	// Initiate login uri, must be https
	InitiateLoginURI            *string                                     `json:"initiate_login_uri,omitempty" url:"-"`
	NativeSocialLogin           *NativeSocialLogin                          `json:"native_social_login,omitempty" url:"-"`
	RefreshToken                *ClientRefreshTokenConfiguration            `json:"refresh_token,omitempty" url:"-"`
	DefaultOrganization         *ClientDefaultOrganization                  `json:"default_organization,omitempty" url:"-"`
	OrganizationUsage           *ClientOrganizationUsagePatchEnum           `json:"organization_usage,omitempty" url:"-"`
	OrganizationRequireBehavior *ClientOrganizationRequireBehaviorPatchEnum `json:"organization_require_behavior,omitempty" url:"-"`
	ClientAuthenticationMethods *ClientAuthenticationMethod                 `json:"client_authentication_methods,omitempty" url:"-"`
	// Makes the use of Pushed Authorization Requests mandatory for this client
	RequirePushedAuthorizationRequests *bool `json:"require_pushed_authorization_requests,omitempty" url:"-"`
	// Makes the use of Proof-of-Possession mandatory for this client
	RequireProofOfPossession *bool                                      `json:"require_proof_of_possession,omitempty" url:"-"`
	SignedRequestObject      *ClientSignedRequestObjectWithCredentialID `json:"signed_request_object,omitempty" url:"-"`
	ComplianceLevel          *ClientComplianceLevelEnum                 `json:"compliance_level,omitempty" url:"-"`
	// Specifies how long, in seconds, a Pushed Authorization Request URI remains valid
	ParRequestExpiry *int `json:"par_request_expiry,omitempty" url:"-"`
}
