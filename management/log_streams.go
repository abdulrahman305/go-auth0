// Code generated by Fern. DO NOT EDIT.

package management

import (
	json "encoding/json"
	fmt "fmt"

	internal "github.com/auth0/go-auth0/v2/management/internal"
)

type CreateLogStreamDatadogRequestBody struct {
	// log stream name
	Name *string              `json:"name,omitempty" url:"name,omitempty"`
	Type LogStreamDatadogEnum `json:"type" url:"type"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter    `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig   `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamDatadogSink `json:"sink" url:"sink"`
	// The optional datetime (ISO 8601) to start streaming logs from
	StartFrom *string `json:"startFrom,omitempty" url:"startFrom,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLogStreamDatadogRequestBody) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLogStreamDatadogRequestBody) GetIsPriority() *bool {
	if c == nil {
		return nil
	}
	return c.IsPriority
}

func (c *CreateLogStreamDatadogRequestBody) GetFilters() []*LogStreamFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *CreateLogStreamDatadogRequestBody) GetPiiConfig() *LogStreamPiiConfig {
	if c == nil {
		return nil
	}
	return c.PiiConfig
}

func (c *CreateLogStreamDatadogRequestBody) GetSink() *LogStreamDatadogSink {
	if c == nil {
		return nil
	}
	return c.Sink
}

func (c *CreateLogStreamDatadogRequestBody) GetStartFrom() *string {
	if c == nil {
		return nil
	}
	return c.StartFrom
}

func (c *CreateLogStreamDatadogRequestBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLogStreamDatadogRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLogStreamDatadogRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLogStreamDatadogRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLogStreamDatadogRequestBody) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLogStreamEventBridgeRequestBody struct {
	// log stream name
	Name *string                  `json:"name,omitempty" url:"name,omitempty"`
	Type LogStreamEventBridgeEnum `json:"type" url:"type"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter        `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig       `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamEventBridgeSink `json:"sink" url:"sink"`
	// The optional datetime (ISO 8601) to start streaming logs from
	StartFrom *string `json:"startFrom,omitempty" url:"startFrom,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLogStreamEventBridgeRequestBody) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLogStreamEventBridgeRequestBody) GetIsPriority() *bool {
	if c == nil {
		return nil
	}
	return c.IsPriority
}

func (c *CreateLogStreamEventBridgeRequestBody) GetFilters() []*LogStreamFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *CreateLogStreamEventBridgeRequestBody) GetPiiConfig() *LogStreamPiiConfig {
	if c == nil {
		return nil
	}
	return c.PiiConfig
}

func (c *CreateLogStreamEventBridgeRequestBody) GetSink() *LogStreamEventBridgeSink {
	if c == nil {
		return nil
	}
	return c.Sink
}

func (c *CreateLogStreamEventBridgeRequestBody) GetStartFrom() *string {
	if c == nil {
		return nil
	}
	return c.StartFrom
}

func (c *CreateLogStreamEventBridgeRequestBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLogStreamEventBridgeRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLogStreamEventBridgeRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLogStreamEventBridgeRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLogStreamEventBridgeRequestBody) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLogStreamEventGridRequestBody struct {
	// log stream name
	Name *string                `json:"name,omitempty" url:"name,omitempty"`
	Type LogStreamEventGridEnum `json:"type" url:"type"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter      `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig     `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamEventGridSink `json:"sink" url:"sink"`
	// The optional datetime (ISO 8601) to start streaming logs from
	StartFrom *string `json:"startFrom,omitempty" url:"startFrom,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLogStreamEventGridRequestBody) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLogStreamEventGridRequestBody) GetIsPriority() *bool {
	if c == nil {
		return nil
	}
	return c.IsPriority
}

func (c *CreateLogStreamEventGridRequestBody) GetFilters() []*LogStreamFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *CreateLogStreamEventGridRequestBody) GetPiiConfig() *LogStreamPiiConfig {
	if c == nil {
		return nil
	}
	return c.PiiConfig
}

func (c *CreateLogStreamEventGridRequestBody) GetSink() *LogStreamEventGridSink {
	if c == nil {
		return nil
	}
	return c.Sink
}

func (c *CreateLogStreamEventGridRequestBody) GetStartFrom() *string {
	if c == nil {
		return nil
	}
	return c.StartFrom
}

func (c *CreateLogStreamEventGridRequestBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLogStreamEventGridRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLogStreamEventGridRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLogStreamEventGridRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLogStreamEventGridRequestBody) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLogStreamHTTPRequestBody struct {
	// log stream name
	Name *string           `json:"name,omitempty" url:"name,omitempty"`
	Type LogStreamHTTPEnum `json:"type" url:"type"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter  `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamHTTPSink  `json:"sink" url:"sink"`
	// The optional datetime (ISO 8601) to start streaming logs from
	StartFrom *string `json:"startFrom,omitempty" url:"startFrom,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLogStreamHTTPRequestBody) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLogStreamHTTPRequestBody) GetIsPriority() *bool {
	if c == nil {
		return nil
	}
	return c.IsPriority
}

func (c *CreateLogStreamHTTPRequestBody) GetFilters() []*LogStreamFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *CreateLogStreamHTTPRequestBody) GetPiiConfig() *LogStreamPiiConfig {
	if c == nil {
		return nil
	}
	return c.PiiConfig
}

func (c *CreateLogStreamHTTPRequestBody) GetSink() *LogStreamHTTPSink {
	if c == nil {
		return nil
	}
	return c.Sink
}

func (c *CreateLogStreamHTTPRequestBody) GetStartFrom() *string {
	if c == nil {
		return nil
	}
	return c.StartFrom
}

func (c *CreateLogStreamHTTPRequestBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLogStreamHTTPRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLogStreamHTTPRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLogStreamHTTPRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLogStreamHTTPRequestBody) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLogStreamMixpanelRequestBody struct {
	// log stream name
	Name *string               `json:"name,omitempty" url:"name,omitempty"`
	Type LogStreamMixpanelEnum `json:"type" url:"type"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter     `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig    `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamMixpanelSink `json:"sink" url:"sink"`
	// The optional datetime (ISO 8601) to start streaming logs from
	StartFrom *string `json:"startFrom,omitempty" url:"startFrom,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLogStreamMixpanelRequestBody) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLogStreamMixpanelRequestBody) GetIsPriority() *bool {
	if c == nil {
		return nil
	}
	return c.IsPriority
}

func (c *CreateLogStreamMixpanelRequestBody) GetFilters() []*LogStreamFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *CreateLogStreamMixpanelRequestBody) GetPiiConfig() *LogStreamPiiConfig {
	if c == nil {
		return nil
	}
	return c.PiiConfig
}

func (c *CreateLogStreamMixpanelRequestBody) GetSink() *LogStreamMixpanelSink {
	if c == nil {
		return nil
	}
	return c.Sink
}

func (c *CreateLogStreamMixpanelRequestBody) GetStartFrom() *string {
	if c == nil {
		return nil
	}
	return c.StartFrom
}

func (c *CreateLogStreamMixpanelRequestBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLogStreamMixpanelRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLogStreamMixpanelRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLogStreamMixpanelRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLogStreamMixpanelRequestBody) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLogStreamRequestContent struct {
	CreateLogStreamHTTPRequestBody        *CreateLogStreamHTTPRequestBody
	CreateLogStreamEventBridgeRequestBody *CreateLogStreamEventBridgeRequestBody
	CreateLogStreamEventGridRequestBody   *CreateLogStreamEventGridRequestBody
	CreateLogStreamDatadogRequestBody     *CreateLogStreamDatadogRequestBody
	CreateLogStreamSplunkRequestBody      *CreateLogStreamSplunkRequestBody
	CreateLogStreamSumoRequestBody        *CreateLogStreamSumoRequestBody
	CreateLogStreamSegmentRequestBody     *CreateLogStreamSegmentRequestBody
	CreateLogStreamMixpanelRequestBody    *CreateLogStreamMixpanelRequestBody

	typ string
}

func (c *CreateLogStreamRequestContent) GetCreateLogStreamHTTPRequestBody() *CreateLogStreamHTTPRequestBody {
	if c == nil {
		return nil
	}
	return c.CreateLogStreamHTTPRequestBody
}

func (c *CreateLogStreamRequestContent) GetCreateLogStreamEventBridgeRequestBody() *CreateLogStreamEventBridgeRequestBody {
	if c == nil {
		return nil
	}
	return c.CreateLogStreamEventBridgeRequestBody
}

func (c *CreateLogStreamRequestContent) GetCreateLogStreamEventGridRequestBody() *CreateLogStreamEventGridRequestBody {
	if c == nil {
		return nil
	}
	return c.CreateLogStreamEventGridRequestBody
}

func (c *CreateLogStreamRequestContent) GetCreateLogStreamDatadogRequestBody() *CreateLogStreamDatadogRequestBody {
	if c == nil {
		return nil
	}
	return c.CreateLogStreamDatadogRequestBody
}

func (c *CreateLogStreamRequestContent) GetCreateLogStreamSplunkRequestBody() *CreateLogStreamSplunkRequestBody {
	if c == nil {
		return nil
	}
	return c.CreateLogStreamSplunkRequestBody
}

func (c *CreateLogStreamRequestContent) GetCreateLogStreamSumoRequestBody() *CreateLogStreamSumoRequestBody {
	if c == nil {
		return nil
	}
	return c.CreateLogStreamSumoRequestBody
}

func (c *CreateLogStreamRequestContent) GetCreateLogStreamSegmentRequestBody() *CreateLogStreamSegmentRequestBody {
	if c == nil {
		return nil
	}
	return c.CreateLogStreamSegmentRequestBody
}

func (c *CreateLogStreamRequestContent) GetCreateLogStreamMixpanelRequestBody() *CreateLogStreamMixpanelRequestBody {
	if c == nil {
		return nil
	}
	return c.CreateLogStreamMixpanelRequestBody
}

func (c *CreateLogStreamRequestContent) UnmarshalJSON(data []byte) error {
	valueCreateLogStreamHTTPRequestBody := new(CreateLogStreamHTTPRequestBody)
	if err := json.Unmarshal(data, &valueCreateLogStreamHTTPRequestBody); err == nil {
		c.typ = "CreateLogStreamHTTPRequestBody"
		c.CreateLogStreamHTTPRequestBody = valueCreateLogStreamHTTPRequestBody
		return nil
	}
	valueCreateLogStreamEventBridgeRequestBody := new(CreateLogStreamEventBridgeRequestBody)
	if err := json.Unmarshal(data, &valueCreateLogStreamEventBridgeRequestBody); err == nil {
		c.typ = "CreateLogStreamEventBridgeRequestBody"
		c.CreateLogStreamEventBridgeRequestBody = valueCreateLogStreamEventBridgeRequestBody
		return nil
	}
	valueCreateLogStreamEventGridRequestBody := new(CreateLogStreamEventGridRequestBody)
	if err := json.Unmarshal(data, &valueCreateLogStreamEventGridRequestBody); err == nil {
		c.typ = "CreateLogStreamEventGridRequestBody"
		c.CreateLogStreamEventGridRequestBody = valueCreateLogStreamEventGridRequestBody
		return nil
	}
	valueCreateLogStreamDatadogRequestBody := new(CreateLogStreamDatadogRequestBody)
	if err := json.Unmarshal(data, &valueCreateLogStreamDatadogRequestBody); err == nil {
		c.typ = "CreateLogStreamDatadogRequestBody"
		c.CreateLogStreamDatadogRequestBody = valueCreateLogStreamDatadogRequestBody
		return nil
	}
	valueCreateLogStreamSplunkRequestBody := new(CreateLogStreamSplunkRequestBody)
	if err := json.Unmarshal(data, &valueCreateLogStreamSplunkRequestBody); err == nil {
		c.typ = "CreateLogStreamSplunkRequestBody"
		c.CreateLogStreamSplunkRequestBody = valueCreateLogStreamSplunkRequestBody
		return nil
	}
	valueCreateLogStreamSumoRequestBody := new(CreateLogStreamSumoRequestBody)
	if err := json.Unmarshal(data, &valueCreateLogStreamSumoRequestBody); err == nil {
		c.typ = "CreateLogStreamSumoRequestBody"
		c.CreateLogStreamSumoRequestBody = valueCreateLogStreamSumoRequestBody
		return nil
	}
	valueCreateLogStreamSegmentRequestBody := new(CreateLogStreamSegmentRequestBody)
	if err := json.Unmarshal(data, &valueCreateLogStreamSegmentRequestBody); err == nil {
		c.typ = "CreateLogStreamSegmentRequestBody"
		c.CreateLogStreamSegmentRequestBody = valueCreateLogStreamSegmentRequestBody
		return nil
	}
	valueCreateLogStreamMixpanelRequestBody := new(CreateLogStreamMixpanelRequestBody)
	if err := json.Unmarshal(data, &valueCreateLogStreamMixpanelRequestBody); err == nil {
		c.typ = "CreateLogStreamMixpanelRequestBody"
		c.CreateLogStreamMixpanelRequestBody = valueCreateLogStreamMixpanelRequestBody
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateLogStreamRequestContent) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateLogStreamHTTPRequestBody" || c.CreateLogStreamHTTPRequestBody != nil {
		return json.Marshal(c.CreateLogStreamHTTPRequestBody)
	}
	if c.typ == "CreateLogStreamEventBridgeRequestBody" || c.CreateLogStreamEventBridgeRequestBody != nil {
		return json.Marshal(c.CreateLogStreamEventBridgeRequestBody)
	}
	if c.typ == "CreateLogStreamEventGridRequestBody" || c.CreateLogStreamEventGridRequestBody != nil {
		return json.Marshal(c.CreateLogStreamEventGridRequestBody)
	}
	if c.typ == "CreateLogStreamDatadogRequestBody" || c.CreateLogStreamDatadogRequestBody != nil {
		return json.Marshal(c.CreateLogStreamDatadogRequestBody)
	}
	if c.typ == "CreateLogStreamSplunkRequestBody" || c.CreateLogStreamSplunkRequestBody != nil {
		return json.Marshal(c.CreateLogStreamSplunkRequestBody)
	}
	if c.typ == "CreateLogStreamSumoRequestBody" || c.CreateLogStreamSumoRequestBody != nil {
		return json.Marshal(c.CreateLogStreamSumoRequestBody)
	}
	if c.typ == "CreateLogStreamSegmentRequestBody" || c.CreateLogStreamSegmentRequestBody != nil {
		return json.Marshal(c.CreateLogStreamSegmentRequestBody)
	}
	if c.typ == "CreateLogStreamMixpanelRequestBody" || c.CreateLogStreamMixpanelRequestBody != nil {
		return json.Marshal(c.CreateLogStreamMixpanelRequestBody)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateLogStreamRequestContentVisitor interface {
	VisitCreateLogStreamHTTPRequestBody(*CreateLogStreamHTTPRequestBody) error
	VisitCreateLogStreamEventBridgeRequestBody(*CreateLogStreamEventBridgeRequestBody) error
	VisitCreateLogStreamEventGridRequestBody(*CreateLogStreamEventGridRequestBody) error
	VisitCreateLogStreamDatadogRequestBody(*CreateLogStreamDatadogRequestBody) error
	VisitCreateLogStreamSplunkRequestBody(*CreateLogStreamSplunkRequestBody) error
	VisitCreateLogStreamSumoRequestBody(*CreateLogStreamSumoRequestBody) error
	VisitCreateLogStreamSegmentRequestBody(*CreateLogStreamSegmentRequestBody) error
	VisitCreateLogStreamMixpanelRequestBody(*CreateLogStreamMixpanelRequestBody) error
}

func (c *CreateLogStreamRequestContent) Accept(visitor CreateLogStreamRequestContentVisitor) error {
	if c.typ == "CreateLogStreamHTTPRequestBody" || c.CreateLogStreamHTTPRequestBody != nil {
		return visitor.VisitCreateLogStreamHTTPRequestBody(c.CreateLogStreamHTTPRequestBody)
	}
	if c.typ == "CreateLogStreamEventBridgeRequestBody" || c.CreateLogStreamEventBridgeRequestBody != nil {
		return visitor.VisitCreateLogStreamEventBridgeRequestBody(c.CreateLogStreamEventBridgeRequestBody)
	}
	if c.typ == "CreateLogStreamEventGridRequestBody" || c.CreateLogStreamEventGridRequestBody != nil {
		return visitor.VisitCreateLogStreamEventGridRequestBody(c.CreateLogStreamEventGridRequestBody)
	}
	if c.typ == "CreateLogStreamDatadogRequestBody" || c.CreateLogStreamDatadogRequestBody != nil {
		return visitor.VisitCreateLogStreamDatadogRequestBody(c.CreateLogStreamDatadogRequestBody)
	}
	if c.typ == "CreateLogStreamSplunkRequestBody" || c.CreateLogStreamSplunkRequestBody != nil {
		return visitor.VisitCreateLogStreamSplunkRequestBody(c.CreateLogStreamSplunkRequestBody)
	}
	if c.typ == "CreateLogStreamSumoRequestBody" || c.CreateLogStreamSumoRequestBody != nil {
		return visitor.VisitCreateLogStreamSumoRequestBody(c.CreateLogStreamSumoRequestBody)
	}
	if c.typ == "CreateLogStreamSegmentRequestBody" || c.CreateLogStreamSegmentRequestBody != nil {
		return visitor.VisitCreateLogStreamSegmentRequestBody(c.CreateLogStreamSegmentRequestBody)
	}
	if c.typ == "CreateLogStreamMixpanelRequestBody" || c.CreateLogStreamMixpanelRequestBody != nil {
		return visitor.VisitCreateLogStreamMixpanelRequestBody(c.CreateLogStreamMixpanelRequestBody)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateLogStreamResponseContent struct {
	LogStreamHTTPResponseSchema        *LogStreamHTTPResponseSchema
	LogStreamEventBridgeResponseSchema *LogStreamEventBridgeResponseSchema
	LogStreamEventGridResponseSchema   *LogStreamEventGridResponseSchema
	LogStreamDatadogResponseSchema     *LogStreamDatadogResponseSchema
	LogStreamSplunkResponseSchema      *LogStreamSplunkResponseSchema
	LogStreamSumoResponseSchema        *LogStreamSumoResponseSchema
	LogStreamSegmentResponseSchema     *LogStreamSegmentResponseSchema
	LogStreamMixpanelResponseSchema    *LogStreamMixpanelResponseSchema

	typ string
}

func (c *CreateLogStreamResponseContent) GetLogStreamHTTPResponseSchema() *LogStreamHTTPResponseSchema {
	if c == nil {
		return nil
	}
	return c.LogStreamHTTPResponseSchema
}

func (c *CreateLogStreamResponseContent) GetLogStreamEventBridgeResponseSchema() *LogStreamEventBridgeResponseSchema {
	if c == nil {
		return nil
	}
	return c.LogStreamEventBridgeResponseSchema
}

func (c *CreateLogStreamResponseContent) GetLogStreamEventGridResponseSchema() *LogStreamEventGridResponseSchema {
	if c == nil {
		return nil
	}
	return c.LogStreamEventGridResponseSchema
}

func (c *CreateLogStreamResponseContent) GetLogStreamDatadogResponseSchema() *LogStreamDatadogResponseSchema {
	if c == nil {
		return nil
	}
	return c.LogStreamDatadogResponseSchema
}

func (c *CreateLogStreamResponseContent) GetLogStreamSplunkResponseSchema() *LogStreamSplunkResponseSchema {
	if c == nil {
		return nil
	}
	return c.LogStreamSplunkResponseSchema
}

func (c *CreateLogStreamResponseContent) GetLogStreamSumoResponseSchema() *LogStreamSumoResponseSchema {
	if c == nil {
		return nil
	}
	return c.LogStreamSumoResponseSchema
}

func (c *CreateLogStreamResponseContent) GetLogStreamSegmentResponseSchema() *LogStreamSegmentResponseSchema {
	if c == nil {
		return nil
	}
	return c.LogStreamSegmentResponseSchema
}

func (c *CreateLogStreamResponseContent) GetLogStreamMixpanelResponseSchema() *LogStreamMixpanelResponseSchema {
	if c == nil {
		return nil
	}
	return c.LogStreamMixpanelResponseSchema
}

func (c *CreateLogStreamResponseContent) UnmarshalJSON(data []byte) error {
	valueLogStreamHTTPResponseSchema := new(LogStreamHTTPResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamHTTPResponseSchema); err == nil {
		c.typ = "LogStreamHTTPResponseSchema"
		c.LogStreamHTTPResponseSchema = valueLogStreamHTTPResponseSchema
		return nil
	}
	valueLogStreamEventBridgeResponseSchema := new(LogStreamEventBridgeResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamEventBridgeResponseSchema); err == nil {
		c.typ = "LogStreamEventBridgeResponseSchema"
		c.LogStreamEventBridgeResponseSchema = valueLogStreamEventBridgeResponseSchema
		return nil
	}
	valueLogStreamEventGridResponseSchema := new(LogStreamEventGridResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamEventGridResponseSchema); err == nil {
		c.typ = "LogStreamEventGridResponseSchema"
		c.LogStreamEventGridResponseSchema = valueLogStreamEventGridResponseSchema
		return nil
	}
	valueLogStreamDatadogResponseSchema := new(LogStreamDatadogResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamDatadogResponseSchema); err == nil {
		c.typ = "LogStreamDatadogResponseSchema"
		c.LogStreamDatadogResponseSchema = valueLogStreamDatadogResponseSchema
		return nil
	}
	valueLogStreamSplunkResponseSchema := new(LogStreamSplunkResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSplunkResponseSchema); err == nil {
		c.typ = "LogStreamSplunkResponseSchema"
		c.LogStreamSplunkResponseSchema = valueLogStreamSplunkResponseSchema
		return nil
	}
	valueLogStreamSumoResponseSchema := new(LogStreamSumoResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSumoResponseSchema); err == nil {
		c.typ = "LogStreamSumoResponseSchema"
		c.LogStreamSumoResponseSchema = valueLogStreamSumoResponseSchema
		return nil
	}
	valueLogStreamSegmentResponseSchema := new(LogStreamSegmentResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSegmentResponseSchema); err == nil {
		c.typ = "LogStreamSegmentResponseSchema"
		c.LogStreamSegmentResponseSchema = valueLogStreamSegmentResponseSchema
		return nil
	}
	valueLogStreamMixpanelResponseSchema := new(LogStreamMixpanelResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamMixpanelResponseSchema); err == nil {
		c.typ = "LogStreamMixpanelResponseSchema"
		c.LogStreamMixpanelResponseSchema = valueLogStreamMixpanelResponseSchema
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateLogStreamResponseContent) MarshalJSON() ([]byte, error) {
	if c.typ == "LogStreamHTTPResponseSchema" || c.LogStreamHTTPResponseSchema != nil {
		return json.Marshal(c.LogStreamHTTPResponseSchema)
	}
	if c.typ == "LogStreamEventBridgeResponseSchema" || c.LogStreamEventBridgeResponseSchema != nil {
		return json.Marshal(c.LogStreamEventBridgeResponseSchema)
	}
	if c.typ == "LogStreamEventGridResponseSchema" || c.LogStreamEventGridResponseSchema != nil {
		return json.Marshal(c.LogStreamEventGridResponseSchema)
	}
	if c.typ == "LogStreamDatadogResponseSchema" || c.LogStreamDatadogResponseSchema != nil {
		return json.Marshal(c.LogStreamDatadogResponseSchema)
	}
	if c.typ == "LogStreamSplunkResponseSchema" || c.LogStreamSplunkResponseSchema != nil {
		return json.Marshal(c.LogStreamSplunkResponseSchema)
	}
	if c.typ == "LogStreamSumoResponseSchema" || c.LogStreamSumoResponseSchema != nil {
		return json.Marshal(c.LogStreamSumoResponseSchema)
	}
	if c.typ == "LogStreamSegmentResponseSchema" || c.LogStreamSegmentResponseSchema != nil {
		return json.Marshal(c.LogStreamSegmentResponseSchema)
	}
	if c.typ == "LogStreamMixpanelResponseSchema" || c.LogStreamMixpanelResponseSchema != nil {
		return json.Marshal(c.LogStreamMixpanelResponseSchema)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateLogStreamResponseContentVisitor interface {
	VisitLogStreamHTTPResponseSchema(*LogStreamHTTPResponseSchema) error
	VisitLogStreamEventBridgeResponseSchema(*LogStreamEventBridgeResponseSchema) error
	VisitLogStreamEventGridResponseSchema(*LogStreamEventGridResponseSchema) error
	VisitLogStreamDatadogResponseSchema(*LogStreamDatadogResponseSchema) error
	VisitLogStreamSplunkResponseSchema(*LogStreamSplunkResponseSchema) error
	VisitLogStreamSumoResponseSchema(*LogStreamSumoResponseSchema) error
	VisitLogStreamSegmentResponseSchema(*LogStreamSegmentResponseSchema) error
	VisitLogStreamMixpanelResponseSchema(*LogStreamMixpanelResponseSchema) error
}

func (c *CreateLogStreamResponseContent) Accept(visitor CreateLogStreamResponseContentVisitor) error {
	if c.typ == "LogStreamHTTPResponseSchema" || c.LogStreamHTTPResponseSchema != nil {
		return visitor.VisitLogStreamHTTPResponseSchema(c.LogStreamHTTPResponseSchema)
	}
	if c.typ == "LogStreamEventBridgeResponseSchema" || c.LogStreamEventBridgeResponseSchema != nil {
		return visitor.VisitLogStreamEventBridgeResponseSchema(c.LogStreamEventBridgeResponseSchema)
	}
	if c.typ == "LogStreamEventGridResponseSchema" || c.LogStreamEventGridResponseSchema != nil {
		return visitor.VisitLogStreamEventGridResponseSchema(c.LogStreamEventGridResponseSchema)
	}
	if c.typ == "LogStreamDatadogResponseSchema" || c.LogStreamDatadogResponseSchema != nil {
		return visitor.VisitLogStreamDatadogResponseSchema(c.LogStreamDatadogResponseSchema)
	}
	if c.typ == "LogStreamSplunkResponseSchema" || c.LogStreamSplunkResponseSchema != nil {
		return visitor.VisitLogStreamSplunkResponseSchema(c.LogStreamSplunkResponseSchema)
	}
	if c.typ == "LogStreamSumoResponseSchema" || c.LogStreamSumoResponseSchema != nil {
		return visitor.VisitLogStreamSumoResponseSchema(c.LogStreamSumoResponseSchema)
	}
	if c.typ == "LogStreamSegmentResponseSchema" || c.LogStreamSegmentResponseSchema != nil {
		return visitor.VisitLogStreamSegmentResponseSchema(c.LogStreamSegmentResponseSchema)
	}
	if c.typ == "LogStreamMixpanelResponseSchema" || c.LogStreamMixpanelResponseSchema != nil {
		return visitor.VisitLogStreamMixpanelResponseSchema(c.LogStreamMixpanelResponseSchema)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateLogStreamSegmentRequestBody struct {
	// log stream name
	Name *string              `json:"name,omitempty" url:"name,omitempty"`
	Type LogStreamSegmentEnum `json:"type" url:"type"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter            `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig           `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamSegmentSinkWriteKey `json:"sink" url:"sink"`
	// The optional datetime (ISO 8601) to start streaming logs from
	StartFrom *string `json:"startFrom,omitempty" url:"startFrom,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLogStreamSegmentRequestBody) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLogStreamSegmentRequestBody) GetIsPriority() *bool {
	if c == nil {
		return nil
	}
	return c.IsPriority
}

func (c *CreateLogStreamSegmentRequestBody) GetFilters() []*LogStreamFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *CreateLogStreamSegmentRequestBody) GetPiiConfig() *LogStreamPiiConfig {
	if c == nil {
		return nil
	}
	return c.PiiConfig
}

func (c *CreateLogStreamSegmentRequestBody) GetSink() *LogStreamSegmentSinkWriteKey {
	if c == nil {
		return nil
	}
	return c.Sink
}

func (c *CreateLogStreamSegmentRequestBody) GetStartFrom() *string {
	if c == nil {
		return nil
	}
	return c.StartFrom
}

func (c *CreateLogStreamSegmentRequestBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLogStreamSegmentRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLogStreamSegmentRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLogStreamSegmentRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLogStreamSegmentRequestBody) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLogStreamSplunkRequestBody struct {
	// log stream name
	Name *string             `json:"name,omitempty" url:"name,omitempty"`
	Type LogStreamSplunkEnum `json:"type" url:"type"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter   `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig  `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamSplunkSink `json:"sink" url:"sink"`
	// The optional datetime (ISO 8601) to start streaming logs from
	StartFrom *string `json:"startFrom,omitempty" url:"startFrom,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLogStreamSplunkRequestBody) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLogStreamSplunkRequestBody) GetIsPriority() *bool {
	if c == nil {
		return nil
	}
	return c.IsPriority
}

func (c *CreateLogStreamSplunkRequestBody) GetFilters() []*LogStreamFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *CreateLogStreamSplunkRequestBody) GetPiiConfig() *LogStreamPiiConfig {
	if c == nil {
		return nil
	}
	return c.PiiConfig
}

func (c *CreateLogStreamSplunkRequestBody) GetSink() *LogStreamSplunkSink {
	if c == nil {
		return nil
	}
	return c.Sink
}

func (c *CreateLogStreamSplunkRequestBody) GetStartFrom() *string {
	if c == nil {
		return nil
	}
	return c.StartFrom
}

func (c *CreateLogStreamSplunkRequestBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLogStreamSplunkRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLogStreamSplunkRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLogStreamSplunkRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLogStreamSplunkRequestBody) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLogStreamSumoRequestBody struct {
	// log stream name
	Name *string           `json:"name,omitempty" url:"name,omitempty"`
	Type LogStreamSumoEnum `json:"type" url:"type"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter  `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamSumoSink  `json:"sink" url:"sink"`
	// The optional datetime (ISO 8601) to start streaming logs from
	StartFrom *string `json:"startFrom,omitempty" url:"startFrom,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLogStreamSumoRequestBody) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLogStreamSumoRequestBody) GetIsPriority() *bool {
	if c == nil {
		return nil
	}
	return c.IsPriority
}

func (c *CreateLogStreamSumoRequestBody) GetFilters() []*LogStreamFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *CreateLogStreamSumoRequestBody) GetPiiConfig() *LogStreamPiiConfig {
	if c == nil {
		return nil
	}
	return c.PiiConfig
}

func (c *CreateLogStreamSumoRequestBody) GetSink() *LogStreamSumoSink {
	if c == nil {
		return nil
	}
	return c.Sink
}

func (c *CreateLogStreamSumoRequestBody) GetStartFrom() *string {
	if c == nil {
		return nil
	}
	return c.StartFrom
}

func (c *CreateLogStreamSumoRequestBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLogStreamSumoRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLogStreamSumoRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLogStreamSumoRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLogStreamSumoRequestBody) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type GetLogStreamResponseContent struct {
	LogStreamHTTPResponseSchema        *LogStreamHTTPResponseSchema
	LogStreamEventBridgeResponseSchema *LogStreamEventBridgeResponseSchema
	LogStreamEventGridResponseSchema   *LogStreamEventGridResponseSchema
	LogStreamDatadogResponseSchema     *LogStreamDatadogResponseSchema
	LogStreamSplunkResponseSchema      *LogStreamSplunkResponseSchema
	LogStreamSumoResponseSchema        *LogStreamSumoResponseSchema
	LogStreamSegmentResponseSchema     *LogStreamSegmentResponseSchema
	LogStreamMixpanelResponseSchema    *LogStreamMixpanelResponseSchema

	typ string
}

func (g *GetLogStreamResponseContent) GetLogStreamHTTPResponseSchema() *LogStreamHTTPResponseSchema {
	if g == nil {
		return nil
	}
	return g.LogStreamHTTPResponseSchema
}

func (g *GetLogStreamResponseContent) GetLogStreamEventBridgeResponseSchema() *LogStreamEventBridgeResponseSchema {
	if g == nil {
		return nil
	}
	return g.LogStreamEventBridgeResponseSchema
}

func (g *GetLogStreamResponseContent) GetLogStreamEventGridResponseSchema() *LogStreamEventGridResponseSchema {
	if g == nil {
		return nil
	}
	return g.LogStreamEventGridResponseSchema
}

func (g *GetLogStreamResponseContent) GetLogStreamDatadogResponseSchema() *LogStreamDatadogResponseSchema {
	if g == nil {
		return nil
	}
	return g.LogStreamDatadogResponseSchema
}

func (g *GetLogStreamResponseContent) GetLogStreamSplunkResponseSchema() *LogStreamSplunkResponseSchema {
	if g == nil {
		return nil
	}
	return g.LogStreamSplunkResponseSchema
}

func (g *GetLogStreamResponseContent) GetLogStreamSumoResponseSchema() *LogStreamSumoResponseSchema {
	if g == nil {
		return nil
	}
	return g.LogStreamSumoResponseSchema
}

func (g *GetLogStreamResponseContent) GetLogStreamSegmentResponseSchema() *LogStreamSegmentResponseSchema {
	if g == nil {
		return nil
	}
	return g.LogStreamSegmentResponseSchema
}

func (g *GetLogStreamResponseContent) GetLogStreamMixpanelResponseSchema() *LogStreamMixpanelResponseSchema {
	if g == nil {
		return nil
	}
	return g.LogStreamMixpanelResponseSchema
}

func (g *GetLogStreamResponseContent) UnmarshalJSON(data []byte) error {
	valueLogStreamHTTPResponseSchema := new(LogStreamHTTPResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamHTTPResponseSchema); err == nil {
		g.typ = "LogStreamHTTPResponseSchema"
		g.LogStreamHTTPResponseSchema = valueLogStreamHTTPResponseSchema
		return nil
	}
	valueLogStreamEventBridgeResponseSchema := new(LogStreamEventBridgeResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamEventBridgeResponseSchema); err == nil {
		g.typ = "LogStreamEventBridgeResponseSchema"
		g.LogStreamEventBridgeResponseSchema = valueLogStreamEventBridgeResponseSchema
		return nil
	}
	valueLogStreamEventGridResponseSchema := new(LogStreamEventGridResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamEventGridResponseSchema); err == nil {
		g.typ = "LogStreamEventGridResponseSchema"
		g.LogStreamEventGridResponseSchema = valueLogStreamEventGridResponseSchema
		return nil
	}
	valueLogStreamDatadogResponseSchema := new(LogStreamDatadogResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamDatadogResponseSchema); err == nil {
		g.typ = "LogStreamDatadogResponseSchema"
		g.LogStreamDatadogResponseSchema = valueLogStreamDatadogResponseSchema
		return nil
	}
	valueLogStreamSplunkResponseSchema := new(LogStreamSplunkResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSplunkResponseSchema); err == nil {
		g.typ = "LogStreamSplunkResponseSchema"
		g.LogStreamSplunkResponseSchema = valueLogStreamSplunkResponseSchema
		return nil
	}
	valueLogStreamSumoResponseSchema := new(LogStreamSumoResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSumoResponseSchema); err == nil {
		g.typ = "LogStreamSumoResponseSchema"
		g.LogStreamSumoResponseSchema = valueLogStreamSumoResponseSchema
		return nil
	}
	valueLogStreamSegmentResponseSchema := new(LogStreamSegmentResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSegmentResponseSchema); err == nil {
		g.typ = "LogStreamSegmentResponseSchema"
		g.LogStreamSegmentResponseSchema = valueLogStreamSegmentResponseSchema
		return nil
	}
	valueLogStreamMixpanelResponseSchema := new(LogStreamMixpanelResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamMixpanelResponseSchema); err == nil {
		g.typ = "LogStreamMixpanelResponseSchema"
		g.LogStreamMixpanelResponseSchema = valueLogStreamMixpanelResponseSchema
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetLogStreamResponseContent) MarshalJSON() ([]byte, error) {
	if g.typ == "LogStreamHTTPResponseSchema" || g.LogStreamHTTPResponseSchema != nil {
		return json.Marshal(g.LogStreamHTTPResponseSchema)
	}
	if g.typ == "LogStreamEventBridgeResponseSchema" || g.LogStreamEventBridgeResponseSchema != nil {
		return json.Marshal(g.LogStreamEventBridgeResponseSchema)
	}
	if g.typ == "LogStreamEventGridResponseSchema" || g.LogStreamEventGridResponseSchema != nil {
		return json.Marshal(g.LogStreamEventGridResponseSchema)
	}
	if g.typ == "LogStreamDatadogResponseSchema" || g.LogStreamDatadogResponseSchema != nil {
		return json.Marshal(g.LogStreamDatadogResponseSchema)
	}
	if g.typ == "LogStreamSplunkResponseSchema" || g.LogStreamSplunkResponseSchema != nil {
		return json.Marshal(g.LogStreamSplunkResponseSchema)
	}
	if g.typ == "LogStreamSumoResponseSchema" || g.LogStreamSumoResponseSchema != nil {
		return json.Marshal(g.LogStreamSumoResponseSchema)
	}
	if g.typ == "LogStreamSegmentResponseSchema" || g.LogStreamSegmentResponseSchema != nil {
		return json.Marshal(g.LogStreamSegmentResponseSchema)
	}
	if g.typ == "LogStreamMixpanelResponseSchema" || g.LogStreamMixpanelResponseSchema != nil {
		return json.Marshal(g.LogStreamMixpanelResponseSchema)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GetLogStreamResponseContentVisitor interface {
	VisitLogStreamHTTPResponseSchema(*LogStreamHTTPResponseSchema) error
	VisitLogStreamEventBridgeResponseSchema(*LogStreamEventBridgeResponseSchema) error
	VisitLogStreamEventGridResponseSchema(*LogStreamEventGridResponseSchema) error
	VisitLogStreamDatadogResponseSchema(*LogStreamDatadogResponseSchema) error
	VisitLogStreamSplunkResponseSchema(*LogStreamSplunkResponseSchema) error
	VisitLogStreamSumoResponseSchema(*LogStreamSumoResponseSchema) error
	VisitLogStreamSegmentResponseSchema(*LogStreamSegmentResponseSchema) error
	VisitLogStreamMixpanelResponseSchema(*LogStreamMixpanelResponseSchema) error
}

func (g *GetLogStreamResponseContent) Accept(visitor GetLogStreamResponseContentVisitor) error {
	if g.typ == "LogStreamHTTPResponseSchema" || g.LogStreamHTTPResponseSchema != nil {
		return visitor.VisitLogStreamHTTPResponseSchema(g.LogStreamHTTPResponseSchema)
	}
	if g.typ == "LogStreamEventBridgeResponseSchema" || g.LogStreamEventBridgeResponseSchema != nil {
		return visitor.VisitLogStreamEventBridgeResponseSchema(g.LogStreamEventBridgeResponseSchema)
	}
	if g.typ == "LogStreamEventGridResponseSchema" || g.LogStreamEventGridResponseSchema != nil {
		return visitor.VisitLogStreamEventGridResponseSchema(g.LogStreamEventGridResponseSchema)
	}
	if g.typ == "LogStreamDatadogResponseSchema" || g.LogStreamDatadogResponseSchema != nil {
		return visitor.VisitLogStreamDatadogResponseSchema(g.LogStreamDatadogResponseSchema)
	}
	if g.typ == "LogStreamSplunkResponseSchema" || g.LogStreamSplunkResponseSchema != nil {
		return visitor.VisitLogStreamSplunkResponseSchema(g.LogStreamSplunkResponseSchema)
	}
	if g.typ == "LogStreamSumoResponseSchema" || g.LogStreamSumoResponseSchema != nil {
		return visitor.VisitLogStreamSumoResponseSchema(g.LogStreamSumoResponseSchema)
	}
	if g.typ == "LogStreamSegmentResponseSchema" || g.LogStreamSegmentResponseSchema != nil {
		return visitor.VisitLogStreamSegmentResponseSchema(g.LogStreamSegmentResponseSchema)
	}
	if g.typ == "LogStreamMixpanelResponseSchema" || g.LogStreamMixpanelResponseSchema != nil {
		return visitor.VisitLogStreamMixpanelResponseSchema(g.LogStreamMixpanelResponseSchema)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type HTTPCustomHeader struct {
	// HTTP header name
	Header *string `json:"header,omitempty" url:"header,omitempty"`
	// HTTP header value
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (h *HTTPCustomHeader) GetHeader() *string {
	if h == nil {
		return nil
	}
	return h.Header
}

func (h *HTTPCustomHeader) GetValue() *string {
	if h == nil {
		return nil
	}
	return h.Value
}

func (h *HTTPCustomHeader) GetExtraProperties() map[string]interface{} {
	return h.ExtraProperties
}

func (h *HTTPCustomHeader) UnmarshalJSON(data []byte) error {
	type embed HTTPCustomHeader
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HTTPCustomHeader(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.ExtraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HTTPCustomHeader) MarshalJSON() ([]byte, error) {
	type embed HTTPCustomHeader
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, h.ExtraProperties)
}

func (h *HTTPCustomHeader) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type LogStreamDatadogEnum = string

// Datadog region
type LogStreamDatadogRegionEnum string

const (
	LogStreamDatadogRegionEnumUs  LogStreamDatadogRegionEnum = "us"
	LogStreamDatadogRegionEnumEu  LogStreamDatadogRegionEnum = "eu"
	LogStreamDatadogRegionEnumUs3 LogStreamDatadogRegionEnum = "us3"
	LogStreamDatadogRegionEnumUs5 LogStreamDatadogRegionEnum = "us5"
)

func NewLogStreamDatadogRegionEnumFromString(s string) (LogStreamDatadogRegionEnum, error) {
	switch s {
	case "us":
		return LogStreamDatadogRegionEnumUs, nil
	case "eu":
		return LogStreamDatadogRegionEnumEu, nil
	case "us3":
		return LogStreamDatadogRegionEnumUs3, nil
	case "us5":
		return LogStreamDatadogRegionEnumUs5, nil
	}
	var t LogStreamDatadogRegionEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogStreamDatadogRegionEnum) Ptr() *LogStreamDatadogRegionEnum {
	return &l
}

type LogStreamDatadogResponseSchema struct {
	// The id of the log stream
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// log stream name
	Name   *string               `json:"name,omitempty" url:"name,omitempty"`
	Status *LogStreamStatusEnum  `json:"status,omitempty" url:"status,omitempty"`
	Type   *LogStreamDatadogEnum `json:"type,omitempty" url:"type,omitempty"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter    `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig   `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamDatadogSink `json:"sink,omitempty" url:"sink,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *LogStreamDatadogResponseSchema) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LogStreamDatadogResponseSchema) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LogStreamDatadogResponseSchema) GetStatus() *LogStreamStatusEnum {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LogStreamDatadogResponseSchema) GetIsPriority() *bool {
	if l == nil {
		return nil
	}
	return l.IsPriority
}

func (l *LogStreamDatadogResponseSchema) GetFilters() []*LogStreamFilter {
	if l == nil {
		return nil
	}
	return l.Filters
}

func (l *LogStreamDatadogResponseSchema) GetPiiConfig() *LogStreamPiiConfig {
	if l == nil {
		return nil
	}
	return l.PiiConfig
}

func (l *LogStreamDatadogResponseSchema) GetSink() *LogStreamDatadogSink {
	if l == nil {
		return nil
	}
	return l.Sink
}

func (l *LogStreamDatadogResponseSchema) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *LogStreamDatadogResponseSchema) UnmarshalJSON(data []byte) error {
	type embed LogStreamDatadogResponseSchema
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LogStreamDatadogResponseSchema(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamDatadogResponseSchema) MarshalJSON() ([]byte, error) {
	type embed LogStreamDatadogResponseSchema
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *LogStreamDatadogResponseSchema) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamDatadogSink struct {
	// Datadog API Key
	DatadogAPIKey string                     `json:"datadogApiKey" url:"datadogApiKey"`
	DatadogRegion LogStreamDatadogRegionEnum `json:"datadogRegion" url:"datadogRegion"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamDatadogSink) GetDatadogAPIKey() string {
	if l == nil {
		return ""
	}
	return l.DatadogAPIKey
}

func (l *LogStreamDatadogSink) GetDatadogRegion() LogStreamDatadogRegionEnum {
	if l == nil {
		return ""
	}
	return l.DatadogRegion
}

func (l *LogStreamDatadogSink) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamDatadogSink) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamDatadogSink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamDatadogSink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamDatadogSink) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamEventBridgeEnum = string

type LogStreamEventBridgeResponseSchema struct {
	// The id of the log stream
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// log stream name
	Name   *string                   `json:"name,omitempty" url:"name,omitempty"`
	Status *LogStreamStatusEnum      `json:"status,omitempty" url:"status,omitempty"`
	Type   *LogStreamEventBridgeEnum `json:"type,omitempty" url:"type,omitempty"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter        `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig       `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamEventBridgeSink `json:"sink,omitempty" url:"sink,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *LogStreamEventBridgeResponseSchema) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LogStreamEventBridgeResponseSchema) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LogStreamEventBridgeResponseSchema) GetStatus() *LogStreamStatusEnum {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LogStreamEventBridgeResponseSchema) GetIsPriority() *bool {
	if l == nil {
		return nil
	}
	return l.IsPriority
}

func (l *LogStreamEventBridgeResponseSchema) GetFilters() []*LogStreamFilter {
	if l == nil {
		return nil
	}
	return l.Filters
}

func (l *LogStreamEventBridgeResponseSchema) GetPiiConfig() *LogStreamPiiConfig {
	if l == nil {
		return nil
	}
	return l.PiiConfig
}

func (l *LogStreamEventBridgeResponseSchema) GetSink() *LogStreamEventBridgeSink {
	if l == nil {
		return nil
	}
	return l.Sink
}

func (l *LogStreamEventBridgeResponseSchema) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *LogStreamEventBridgeResponseSchema) UnmarshalJSON(data []byte) error {
	type embed LogStreamEventBridgeResponseSchema
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LogStreamEventBridgeResponseSchema(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamEventBridgeResponseSchema) MarshalJSON() ([]byte, error) {
	type embed LogStreamEventBridgeResponseSchema
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *LogStreamEventBridgeResponseSchema) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamEventBridgeSink struct {
	// AWS account ID
	AwsAccountID string                             `json:"awsAccountId" url:"awsAccountId"`
	AwsRegion    LogStreamEventBridgeSinkRegionEnum `json:"awsRegion" url:"awsRegion"`
	// AWS EventBridge partner event source
	AwsPartnerEventSource *string `json:"awsPartnerEventSource,omitempty" url:"awsPartnerEventSource,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamEventBridgeSink) GetAwsAccountID() string {
	if l == nil {
		return ""
	}
	return l.AwsAccountID
}

func (l *LogStreamEventBridgeSink) GetAwsRegion() LogStreamEventBridgeSinkRegionEnum {
	if l == nil {
		return ""
	}
	return l.AwsRegion
}

func (l *LogStreamEventBridgeSink) GetAwsPartnerEventSource() *string {
	if l == nil {
		return nil
	}
	return l.AwsPartnerEventSource
}

func (l *LogStreamEventBridgeSink) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamEventBridgeSink) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamEventBridgeSink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamEventBridgeSink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamEventBridgeSink) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The region in which the EventBridge event source will be created
type LogStreamEventBridgeSinkRegionEnum string

const (
	LogStreamEventBridgeSinkRegionEnumApEast1      LogStreamEventBridgeSinkRegionEnum = "ap-east-1"
	LogStreamEventBridgeSinkRegionEnumApNortheast1 LogStreamEventBridgeSinkRegionEnum = "ap-northeast-1"
	LogStreamEventBridgeSinkRegionEnumApNortheast2 LogStreamEventBridgeSinkRegionEnum = "ap-northeast-2"
	LogStreamEventBridgeSinkRegionEnumApNortheast3 LogStreamEventBridgeSinkRegionEnum = "ap-northeast-3"
	LogStreamEventBridgeSinkRegionEnumApSouth1     LogStreamEventBridgeSinkRegionEnum = "ap-south-1"
	LogStreamEventBridgeSinkRegionEnumApSoutheast1 LogStreamEventBridgeSinkRegionEnum = "ap-southeast-1"
	LogStreamEventBridgeSinkRegionEnumApSoutheast2 LogStreamEventBridgeSinkRegionEnum = "ap-southeast-2"
	LogStreamEventBridgeSinkRegionEnumCaCentral1   LogStreamEventBridgeSinkRegionEnum = "ca-central-1"
	LogStreamEventBridgeSinkRegionEnumEuCentral1   LogStreamEventBridgeSinkRegionEnum = "eu-central-1"
	LogStreamEventBridgeSinkRegionEnumEuNorth1     LogStreamEventBridgeSinkRegionEnum = "eu-north-1"
	LogStreamEventBridgeSinkRegionEnumEuWest1      LogStreamEventBridgeSinkRegionEnum = "eu-west-1"
	LogStreamEventBridgeSinkRegionEnumEuWest2      LogStreamEventBridgeSinkRegionEnum = "eu-west-2"
	LogStreamEventBridgeSinkRegionEnumEuWest3      LogStreamEventBridgeSinkRegionEnum = "eu-west-3"
	LogStreamEventBridgeSinkRegionEnumMeSouth1     LogStreamEventBridgeSinkRegionEnum = "me-south-1"
	LogStreamEventBridgeSinkRegionEnumSaEast1      LogStreamEventBridgeSinkRegionEnum = "sa-east-1"
	LogStreamEventBridgeSinkRegionEnumUsGovEast1   LogStreamEventBridgeSinkRegionEnum = "us-gov-east-1"
	LogStreamEventBridgeSinkRegionEnumUsGovWest1   LogStreamEventBridgeSinkRegionEnum = "us-gov-west-1"
	LogStreamEventBridgeSinkRegionEnumUsEast1      LogStreamEventBridgeSinkRegionEnum = "us-east-1"
	LogStreamEventBridgeSinkRegionEnumUsEast2      LogStreamEventBridgeSinkRegionEnum = "us-east-2"
	LogStreamEventBridgeSinkRegionEnumUsWest1      LogStreamEventBridgeSinkRegionEnum = "us-west-1"
	LogStreamEventBridgeSinkRegionEnumUsWest2      LogStreamEventBridgeSinkRegionEnum = "us-west-2"
)

func NewLogStreamEventBridgeSinkRegionEnumFromString(s string) (LogStreamEventBridgeSinkRegionEnum, error) {
	switch s {
	case "ap-east-1":
		return LogStreamEventBridgeSinkRegionEnumApEast1, nil
	case "ap-northeast-1":
		return LogStreamEventBridgeSinkRegionEnumApNortheast1, nil
	case "ap-northeast-2":
		return LogStreamEventBridgeSinkRegionEnumApNortheast2, nil
	case "ap-northeast-3":
		return LogStreamEventBridgeSinkRegionEnumApNortheast3, nil
	case "ap-south-1":
		return LogStreamEventBridgeSinkRegionEnumApSouth1, nil
	case "ap-southeast-1":
		return LogStreamEventBridgeSinkRegionEnumApSoutheast1, nil
	case "ap-southeast-2":
		return LogStreamEventBridgeSinkRegionEnumApSoutheast2, nil
	case "ca-central-1":
		return LogStreamEventBridgeSinkRegionEnumCaCentral1, nil
	case "eu-central-1":
		return LogStreamEventBridgeSinkRegionEnumEuCentral1, nil
	case "eu-north-1":
		return LogStreamEventBridgeSinkRegionEnumEuNorth1, nil
	case "eu-west-1":
		return LogStreamEventBridgeSinkRegionEnumEuWest1, nil
	case "eu-west-2":
		return LogStreamEventBridgeSinkRegionEnumEuWest2, nil
	case "eu-west-3":
		return LogStreamEventBridgeSinkRegionEnumEuWest3, nil
	case "me-south-1":
		return LogStreamEventBridgeSinkRegionEnumMeSouth1, nil
	case "sa-east-1":
		return LogStreamEventBridgeSinkRegionEnumSaEast1, nil
	case "us-gov-east-1":
		return LogStreamEventBridgeSinkRegionEnumUsGovEast1, nil
	case "us-gov-west-1":
		return LogStreamEventBridgeSinkRegionEnumUsGovWest1, nil
	case "us-east-1":
		return LogStreamEventBridgeSinkRegionEnumUsEast1, nil
	case "us-east-2":
		return LogStreamEventBridgeSinkRegionEnumUsEast2, nil
	case "us-west-1":
		return LogStreamEventBridgeSinkRegionEnumUsWest1, nil
	case "us-west-2":
		return LogStreamEventBridgeSinkRegionEnumUsWest2, nil
	}
	var t LogStreamEventBridgeSinkRegionEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogStreamEventBridgeSinkRegionEnum) Ptr() *LogStreamEventBridgeSinkRegionEnum {
	return &l
}

type LogStreamEventGridEnum = string

// Azure Region Name
type LogStreamEventGridRegionEnum string

const (
	LogStreamEventGridRegionEnumAustraliacentral   LogStreamEventGridRegionEnum = "australiacentral"
	LogStreamEventGridRegionEnumAustraliaeast      LogStreamEventGridRegionEnum = "australiaeast"
	LogStreamEventGridRegionEnumAustraliasoutheast LogStreamEventGridRegionEnum = "australiasoutheast"
	LogStreamEventGridRegionEnumBrazilsouth        LogStreamEventGridRegionEnum = "brazilsouth"
	LogStreamEventGridRegionEnumCanadacentral      LogStreamEventGridRegionEnum = "canadacentral"
	LogStreamEventGridRegionEnumCanadaeast         LogStreamEventGridRegionEnum = "canadaeast"
	LogStreamEventGridRegionEnumCentralindia       LogStreamEventGridRegionEnum = "centralindia"
	LogStreamEventGridRegionEnumCentralus          LogStreamEventGridRegionEnum = "centralus"
	LogStreamEventGridRegionEnumEastasia           LogStreamEventGridRegionEnum = "eastasia"
	LogStreamEventGridRegionEnumEastus             LogStreamEventGridRegionEnum = "eastus"
	LogStreamEventGridRegionEnumEastus2            LogStreamEventGridRegionEnum = "eastus2"
	LogStreamEventGridRegionEnumFrancecentral      LogStreamEventGridRegionEnum = "francecentral"
	LogStreamEventGridRegionEnumGermanywestcentral LogStreamEventGridRegionEnum = "germanywestcentral"
	LogStreamEventGridRegionEnumJapaneast          LogStreamEventGridRegionEnum = "japaneast"
	LogStreamEventGridRegionEnumJapanwest          LogStreamEventGridRegionEnum = "japanwest"
	LogStreamEventGridRegionEnumKoreacentral       LogStreamEventGridRegionEnum = "koreacentral"
	LogStreamEventGridRegionEnumKoreasouth         LogStreamEventGridRegionEnum = "koreasouth"
	LogStreamEventGridRegionEnumNorthcentralus     LogStreamEventGridRegionEnum = "northcentralus"
	LogStreamEventGridRegionEnumNortheurope        LogStreamEventGridRegionEnum = "northeurope"
	LogStreamEventGridRegionEnumNorwayeast         LogStreamEventGridRegionEnum = "norwayeast"
	LogStreamEventGridRegionEnumSouthafricanorth   LogStreamEventGridRegionEnum = "southafricanorth"
	LogStreamEventGridRegionEnumSouthcentralus     LogStreamEventGridRegionEnum = "southcentralus"
	LogStreamEventGridRegionEnumSoutheastasia      LogStreamEventGridRegionEnum = "southeastasia"
	LogStreamEventGridRegionEnumSouthindia         LogStreamEventGridRegionEnum = "southindia"
	LogStreamEventGridRegionEnumSwedencentral      LogStreamEventGridRegionEnum = "swedencentral"
	LogStreamEventGridRegionEnumSwitzerlandnorth   LogStreamEventGridRegionEnum = "switzerlandnorth"
	LogStreamEventGridRegionEnumUaenorth           LogStreamEventGridRegionEnum = "uaenorth"
	LogStreamEventGridRegionEnumUksouth            LogStreamEventGridRegionEnum = "uksouth"
	LogStreamEventGridRegionEnumUkwest             LogStreamEventGridRegionEnum = "ukwest"
	LogStreamEventGridRegionEnumWestcentralus      LogStreamEventGridRegionEnum = "westcentralus"
	LogStreamEventGridRegionEnumWesteurope         LogStreamEventGridRegionEnum = "westeurope"
	LogStreamEventGridRegionEnumWestindia          LogStreamEventGridRegionEnum = "westindia"
	LogStreamEventGridRegionEnumWestus             LogStreamEventGridRegionEnum = "westus"
	LogStreamEventGridRegionEnumWestus2            LogStreamEventGridRegionEnum = "westus2"
)

func NewLogStreamEventGridRegionEnumFromString(s string) (LogStreamEventGridRegionEnum, error) {
	switch s {
	case "australiacentral":
		return LogStreamEventGridRegionEnumAustraliacentral, nil
	case "australiaeast":
		return LogStreamEventGridRegionEnumAustraliaeast, nil
	case "australiasoutheast":
		return LogStreamEventGridRegionEnumAustraliasoutheast, nil
	case "brazilsouth":
		return LogStreamEventGridRegionEnumBrazilsouth, nil
	case "canadacentral":
		return LogStreamEventGridRegionEnumCanadacentral, nil
	case "canadaeast":
		return LogStreamEventGridRegionEnumCanadaeast, nil
	case "centralindia":
		return LogStreamEventGridRegionEnumCentralindia, nil
	case "centralus":
		return LogStreamEventGridRegionEnumCentralus, nil
	case "eastasia":
		return LogStreamEventGridRegionEnumEastasia, nil
	case "eastus":
		return LogStreamEventGridRegionEnumEastus, nil
	case "eastus2":
		return LogStreamEventGridRegionEnumEastus2, nil
	case "francecentral":
		return LogStreamEventGridRegionEnumFrancecentral, nil
	case "germanywestcentral":
		return LogStreamEventGridRegionEnumGermanywestcentral, nil
	case "japaneast":
		return LogStreamEventGridRegionEnumJapaneast, nil
	case "japanwest":
		return LogStreamEventGridRegionEnumJapanwest, nil
	case "koreacentral":
		return LogStreamEventGridRegionEnumKoreacentral, nil
	case "koreasouth":
		return LogStreamEventGridRegionEnumKoreasouth, nil
	case "northcentralus":
		return LogStreamEventGridRegionEnumNorthcentralus, nil
	case "northeurope":
		return LogStreamEventGridRegionEnumNortheurope, nil
	case "norwayeast":
		return LogStreamEventGridRegionEnumNorwayeast, nil
	case "southafricanorth":
		return LogStreamEventGridRegionEnumSouthafricanorth, nil
	case "southcentralus":
		return LogStreamEventGridRegionEnumSouthcentralus, nil
	case "southeastasia":
		return LogStreamEventGridRegionEnumSoutheastasia, nil
	case "southindia":
		return LogStreamEventGridRegionEnumSouthindia, nil
	case "swedencentral":
		return LogStreamEventGridRegionEnumSwedencentral, nil
	case "switzerlandnorth":
		return LogStreamEventGridRegionEnumSwitzerlandnorth, nil
	case "uaenorth":
		return LogStreamEventGridRegionEnumUaenorth, nil
	case "uksouth":
		return LogStreamEventGridRegionEnumUksouth, nil
	case "ukwest":
		return LogStreamEventGridRegionEnumUkwest, nil
	case "westcentralus":
		return LogStreamEventGridRegionEnumWestcentralus, nil
	case "westeurope":
		return LogStreamEventGridRegionEnumWesteurope, nil
	case "westindia":
		return LogStreamEventGridRegionEnumWestindia, nil
	case "westus":
		return LogStreamEventGridRegionEnumWestus, nil
	case "westus2":
		return LogStreamEventGridRegionEnumWestus2, nil
	}
	var t LogStreamEventGridRegionEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogStreamEventGridRegionEnum) Ptr() *LogStreamEventGridRegionEnum {
	return &l
}

type LogStreamEventGridResponseSchema struct {
	// The id of the log stream
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// log stream name
	Name   *string                 `json:"name,omitempty" url:"name,omitempty"`
	Status *LogStreamStatusEnum    `json:"status,omitempty" url:"status,omitempty"`
	Type   *LogStreamEventGridEnum `json:"type,omitempty" url:"type,omitempty"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter      `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig     `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamEventGridSink `json:"sink,omitempty" url:"sink,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *LogStreamEventGridResponseSchema) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LogStreamEventGridResponseSchema) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LogStreamEventGridResponseSchema) GetStatus() *LogStreamStatusEnum {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LogStreamEventGridResponseSchema) GetIsPriority() *bool {
	if l == nil {
		return nil
	}
	return l.IsPriority
}

func (l *LogStreamEventGridResponseSchema) GetFilters() []*LogStreamFilter {
	if l == nil {
		return nil
	}
	return l.Filters
}

func (l *LogStreamEventGridResponseSchema) GetPiiConfig() *LogStreamPiiConfig {
	if l == nil {
		return nil
	}
	return l.PiiConfig
}

func (l *LogStreamEventGridResponseSchema) GetSink() *LogStreamEventGridSink {
	if l == nil {
		return nil
	}
	return l.Sink
}

func (l *LogStreamEventGridResponseSchema) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *LogStreamEventGridResponseSchema) UnmarshalJSON(data []byte) error {
	type embed LogStreamEventGridResponseSchema
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LogStreamEventGridResponseSchema(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamEventGridResponseSchema) MarshalJSON() ([]byte, error) {
	type embed LogStreamEventGridResponseSchema
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *LogStreamEventGridResponseSchema) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamEventGridSink struct {
	// Subscription ID
	AzureSubscriptionID string                       `json:"azureSubscriptionId" url:"azureSubscriptionId"`
	AzureRegion         LogStreamEventGridRegionEnum `json:"azureRegion" url:"azureRegion"`
	// Resource Group
	AzureResourceGroup string `json:"azureResourceGroup" url:"azureResourceGroup"`
	// Partner Topic
	AzurePartnerTopic *string `json:"azurePartnerTopic,omitempty" url:"azurePartnerTopic,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamEventGridSink) GetAzureSubscriptionID() string {
	if l == nil {
		return ""
	}
	return l.AzureSubscriptionID
}

func (l *LogStreamEventGridSink) GetAzureRegion() LogStreamEventGridRegionEnum {
	if l == nil {
		return ""
	}
	return l.AzureRegion
}

func (l *LogStreamEventGridSink) GetAzureResourceGroup() string {
	if l == nil {
		return ""
	}
	return l.AzureResourceGroup
}

func (l *LogStreamEventGridSink) GetAzurePartnerTopic() *string {
	if l == nil {
		return nil
	}
	return l.AzurePartnerTopic
}

func (l *LogStreamEventGridSink) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamEventGridSink) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamEventGridSink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamEventGridSink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamEventGridSink) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamFilter struct {
	Type *LogStreamFilterTypeEnum      `json:"type,omitempty" url:"type,omitempty"`
	Name *LogStreamFilterGroupNameEnum `json:"name,omitempty" url:"name,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *LogStreamFilter) GetName() *LogStreamFilterGroupNameEnum {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LogStreamFilter) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *LogStreamFilter) UnmarshalJSON(data []byte) error {
	type embed LogStreamFilter
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LogStreamFilter(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamFilter) MarshalJSON() ([]byte, error) {
	type embed LogStreamFilter
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *LogStreamFilter) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Category group name
type LogStreamFilterGroupNameEnum string

const (
	LogStreamFilterGroupNameEnumAuthLoginFail            LogStreamFilterGroupNameEnum = "auth.login.fail"
	LogStreamFilterGroupNameEnumAuthLoginNotification    LogStreamFilterGroupNameEnum = "auth.login.notification"
	LogStreamFilterGroupNameEnumAuthLoginSuccess         LogStreamFilterGroupNameEnum = "auth.login.success"
	LogStreamFilterGroupNameEnumAuthLogoutFail           LogStreamFilterGroupNameEnum = "auth.logout.fail"
	LogStreamFilterGroupNameEnumAuthLogoutSuccess        LogStreamFilterGroupNameEnum = "auth.logout.success"
	LogStreamFilterGroupNameEnumAuthSignupFail           LogStreamFilterGroupNameEnum = "auth.signup.fail"
	LogStreamFilterGroupNameEnumAuthSignupSuccess        LogStreamFilterGroupNameEnum = "auth.signup.success"
	LogStreamFilterGroupNameEnumAuthSilentAuthFail       LogStreamFilterGroupNameEnum = "auth.silent_auth.fail"
	LogStreamFilterGroupNameEnumAuthSilentAuthSuccess    LogStreamFilterGroupNameEnum = "auth.silent_auth.success"
	LogStreamFilterGroupNameEnumAuthTokenExchangeFail    LogStreamFilterGroupNameEnum = "auth.token_exchange.fail"
	LogStreamFilterGroupNameEnumAuthTokenExchangeSuccess LogStreamFilterGroupNameEnum = "auth.token_exchange.success"
	LogStreamFilterGroupNameEnumManagementFail           LogStreamFilterGroupNameEnum = "management.fail"
	LogStreamFilterGroupNameEnumManagementSuccess        LogStreamFilterGroupNameEnum = "management.success"
	LogStreamFilterGroupNameEnumSCIMEvent                LogStreamFilterGroupNameEnum = "scim.event"
	LogStreamFilterGroupNameEnumSystemNotification       LogStreamFilterGroupNameEnum = "system.notification"
	LogStreamFilterGroupNameEnumUserFail                 LogStreamFilterGroupNameEnum = "user.fail"
	LogStreamFilterGroupNameEnumUserNotification         LogStreamFilterGroupNameEnum = "user.notification"
	LogStreamFilterGroupNameEnumUserSuccess              LogStreamFilterGroupNameEnum = "user.success"
	LogStreamFilterGroupNameEnumActions                  LogStreamFilterGroupNameEnum = "actions"
	LogStreamFilterGroupNameEnumOther                    LogStreamFilterGroupNameEnum = "other"
)

func NewLogStreamFilterGroupNameEnumFromString(s string) (LogStreamFilterGroupNameEnum, error) {
	switch s {
	case "auth.login.fail":
		return LogStreamFilterGroupNameEnumAuthLoginFail, nil
	case "auth.login.notification":
		return LogStreamFilterGroupNameEnumAuthLoginNotification, nil
	case "auth.login.success":
		return LogStreamFilterGroupNameEnumAuthLoginSuccess, nil
	case "auth.logout.fail":
		return LogStreamFilterGroupNameEnumAuthLogoutFail, nil
	case "auth.logout.success":
		return LogStreamFilterGroupNameEnumAuthLogoutSuccess, nil
	case "auth.signup.fail":
		return LogStreamFilterGroupNameEnumAuthSignupFail, nil
	case "auth.signup.success":
		return LogStreamFilterGroupNameEnumAuthSignupSuccess, nil
	case "auth.silent_auth.fail":
		return LogStreamFilterGroupNameEnumAuthSilentAuthFail, nil
	case "auth.silent_auth.success":
		return LogStreamFilterGroupNameEnumAuthSilentAuthSuccess, nil
	case "auth.token_exchange.fail":
		return LogStreamFilterGroupNameEnumAuthTokenExchangeFail, nil
	case "auth.token_exchange.success":
		return LogStreamFilterGroupNameEnumAuthTokenExchangeSuccess, nil
	case "management.fail":
		return LogStreamFilterGroupNameEnumManagementFail, nil
	case "management.success":
		return LogStreamFilterGroupNameEnumManagementSuccess, nil
	case "scim.event":
		return LogStreamFilterGroupNameEnumSCIMEvent, nil
	case "system.notification":
		return LogStreamFilterGroupNameEnumSystemNotification, nil
	case "user.fail":
		return LogStreamFilterGroupNameEnumUserFail, nil
	case "user.notification":
		return LogStreamFilterGroupNameEnumUserNotification, nil
	case "user.success":
		return LogStreamFilterGroupNameEnumUserSuccess, nil
	case "actions":
		return LogStreamFilterGroupNameEnumActions, nil
	case "other":
		return LogStreamFilterGroupNameEnumOther, nil
	}
	var t LogStreamFilterGroupNameEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogStreamFilterGroupNameEnum) Ptr() *LogStreamFilterGroupNameEnum {
	return &l
}

// Filter type. Currently `category` is the only valid type.
type LogStreamFilterTypeEnum = string

// HTTP JSON format
type LogStreamHTTPContentFormatEnum string

const (
	LogStreamHTTPContentFormatEnumJsonarray  LogStreamHTTPContentFormatEnum = "JSONARRAY"
	LogStreamHTTPContentFormatEnumJsonlines  LogStreamHTTPContentFormatEnum = "JSONLINES"
	LogStreamHTTPContentFormatEnumJsonobject LogStreamHTTPContentFormatEnum = "JSONOBJECT"
)

func NewLogStreamHTTPContentFormatEnumFromString(s string) (LogStreamHTTPContentFormatEnum, error) {
	switch s {
	case "JSONARRAY":
		return LogStreamHTTPContentFormatEnumJsonarray, nil
	case "JSONLINES":
		return LogStreamHTTPContentFormatEnumJsonlines, nil
	case "JSONOBJECT":
		return LogStreamHTTPContentFormatEnumJsonobject, nil
	}
	var t LogStreamHTTPContentFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogStreamHTTPContentFormatEnum) Ptr() *LogStreamHTTPContentFormatEnum {
	return &l
}

type LogStreamHTTPEnum = string

type LogStreamHTTPResponseSchema struct {
	// The id of the log stream
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// log stream name
	Name   *string              `json:"name,omitempty" url:"name,omitempty"`
	Status *LogStreamStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	Type   *LogStreamHTTPEnum   `json:"type,omitempty" url:"type,omitempty"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter  `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamHTTPSink  `json:"sink,omitempty" url:"sink,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *LogStreamHTTPResponseSchema) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LogStreamHTTPResponseSchema) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LogStreamHTTPResponseSchema) GetStatus() *LogStreamStatusEnum {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LogStreamHTTPResponseSchema) GetIsPriority() *bool {
	if l == nil {
		return nil
	}
	return l.IsPriority
}

func (l *LogStreamHTTPResponseSchema) GetFilters() []*LogStreamFilter {
	if l == nil {
		return nil
	}
	return l.Filters
}

func (l *LogStreamHTTPResponseSchema) GetPiiConfig() *LogStreamPiiConfig {
	if l == nil {
		return nil
	}
	return l.PiiConfig
}

func (l *LogStreamHTTPResponseSchema) GetSink() *LogStreamHTTPSink {
	if l == nil {
		return nil
	}
	return l.Sink
}

func (l *LogStreamHTTPResponseSchema) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *LogStreamHTTPResponseSchema) UnmarshalJSON(data []byte) error {
	type embed LogStreamHTTPResponseSchema
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LogStreamHTTPResponseSchema(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamHTTPResponseSchema) MarshalJSON() ([]byte, error) {
	type embed LogStreamHTTPResponseSchema
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *LogStreamHTTPResponseSchema) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamHTTPSink struct {
	// HTTP Authorization header
	HTTPAuthorization *string                         `json:"httpAuthorization,omitempty" url:"httpAuthorization,omitempty"`
	HTTPContentFormat *LogStreamHTTPContentFormatEnum `json:"httpContentFormat,omitempty" url:"httpContentFormat,omitempty"`
	// HTTP Content-Type header
	HTTPContentType *string `json:"httpContentType,omitempty" url:"httpContentType,omitempty"`
	// HTTP endpoint
	HTTPEndpoint string `json:"httpEndpoint" url:"httpEndpoint"`
	// custom HTTP headers
	HTTPCustomHeaders []*HTTPCustomHeader `json:"httpCustomHeaders,omitempty" url:"httpCustomHeaders,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamHTTPSink) GetHTTPAuthorization() *string {
	if l == nil {
		return nil
	}
	return l.HTTPAuthorization
}

func (l *LogStreamHTTPSink) GetHTTPContentFormat() *LogStreamHTTPContentFormatEnum {
	if l == nil {
		return nil
	}
	return l.HTTPContentFormat
}

func (l *LogStreamHTTPSink) GetHTTPContentType() *string {
	if l == nil {
		return nil
	}
	return l.HTTPContentType
}

func (l *LogStreamHTTPSink) GetHTTPEndpoint() string {
	if l == nil {
		return ""
	}
	return l.HTTPEndpoint
}

func (l *LogStreamHTTPSink) GetHTTPCustomHeaders() []*HTTPCustomHeader {
	if l == nil {
		return nil
	}
	return l.HTTPCustomHeaders
}

func (l *LogStreamHTTPSink) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamHTTPSink) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamHTTPSink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamHTTPSink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamHTTPSink) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamMixpanelEnum = string

// Mixpanel Region
type LogStreamMixpanelRegionEnum string

const (
	LogStreamMixpanelRegionEnumUs LogStreamMixpanelRegionEnum = "us"
	LogStreamMixpanelRegionEnumEu LogStreamMixpanelRegionEnum = "eu"
)

func NewLogStreamMixpanelRegionEnumFromString(s string) (LogStreamMixpanelRegionEnum, error) {
	switch s {
	case "us":
		return LogStreamMixpanelRegionEnumUs, nil
	case "eu":
		return LogStreamMixpanelRegionEnumEu, nil
	}
	var t LogStreamMixpanelRegionEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogStreamMixpanelRegionEnum) Ptr() *LogStreamMixpanelRegionEnum {
	return &l
}

type LogStreamMixpanelResponseSchema struct {
	// The id of the log stream
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// log stream name
	Name   *string                `json:"name,omitempty" url:"name,omitempty"`
	Status *LogStreamStatusEnum   `json:"status,omitempty" url:"status,omitempty"`
	Type   *LogStreamMixpanelEnum `json:"type,omitempty" url:"type,omitempty"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter     `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig    `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamMixpanelSink `json:"sink,omitempty" url:"sink,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *LogStreamMixpanelResponseSchema) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LogStreamMixpanelResponseSchema) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LogStreamMixpanelResponseSchema) GetStatus() *LogStreamStatusEnum {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LogStreamMixpanelResponseSchema) GetIsPriority() *bool {
	if l == nil {
		return nil
	}
	return l.IsPriority
}

func (l *LogStreamMixpanelResponseSchema) GetFilters() []*LogStreamFilter {
	if l == nil {
		return nil
	}
	return l.Filters
}

func (l *LogStreamMixpanelResponseSchema) GetPiiConfig() *LogStreamPiiConfig {
	if l == nil {
		return nil
	}
	return l.PiiConfig
}

func (l *LogStreamMixpanelResponseSchema) GetSink() *LogStreamMixpanelSink {
	if l == nil {
		return nil
	}
	return l.Sink
}

func (l *LogStreamMixpanelResponseSchema) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *LogStreamMixpanelResponseSchema) UnmarshalJSON(data []byte) error {
	type embed LogStreamMixpanelResponseSchema
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LogStreamMixpanelResponseSchema(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamMixpanelResponseSchema) MarshalJSON() ([]byte, error) {
	type embed LogStreamMixpanelResponseSchema
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *LogStreamMixpanelResponseSchema) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamMixpanelSink struct {
	MixpanelRegion LogStreamMixpanelRegionEnum `json:"mixpanelRegion" url:"mixpanelRegion"`
	// Mixpanel Project Id
	MixpanelProjectID string `json:"mixpanelProjectId" url:"mixpanelProjectId"`
	// Mixpanel Service Account Username
	MixpanelServiceAccountUsername string `json:"mixpanelServiceAccountUsername" url:"mixpanelServiceAccountUsername"`
	// Mixpanel Service Account Password
	MixpanelServiceAccountPassword string `json:"mixpanelServiceAccountPassword" url:"mixpanelServiceAccountPassword"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamMixpanelSink) GetMixpanelRegion() LogStreamMixpanelRegionEnum {
	if l == nil {
		return ""
	}
	return l.MixpanelRegion
}

func (l *LogStreamMixpanelSink) GetMixpanelProjectID() string {
	if l == nil {
		return ""
	}
	return l.MixpanelProjectID
}

func (l *LogStreamMixpanelSink) GetMixpanelServiceAccountUsername() string {
	if l == nil {
		return ""
	}
	return l.MixpanelServiceAccountUsername
}

func (l *LogStreamMixpanelSink) GetMixpanelServiceAccountPassword() string {
	if l == nil {
		return ""
	}
	return l.MixpanelServiceAccountPassword
}

func (l *LogStreamMixpanelSink) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamMixpanelSink) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamMixpanelSink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamMixpanelSink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamMixpanelSink) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamMixpanelSinkPatch struct {
	MixpanelRegion LogStreamMixpanelRegionEnum `json:"mixpanelRegion" url:"mixpanelRegion"`
	// Mixpanel Project Id
	MixpanelProjectID string `json:"mixpanelProjectId" url:"mixpanelProjectId"`
	// Mixpanel Service Account Username
	MixpanelServiceAccountUsername string `json:"mixpanelServiceAccountUsername" url:"mixpanelServiceAccountUsername"`
	// Mixpanel Service Account Password
	MixpanelServiceAccountPassword *string `json:"mixpanelServiceAccountPassword,omitempty" url:"mixpanelServiceAccountPassword,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamMixpanelSinkPatch) GetMixpanelRegion() LogStreamMixpanelRegionEnum {
	if l == nil {
		return ""
	}
	return l.MixpanelRegion
}

func (l *LogStreamMixpanelSinkPatch) GetMixpanelProjectID() string {
	if l == nil {
		return ""
	}
	return l.MixpanelProjectID
}

func (l *LogStreamMixpanelSinkPatch) GetMixpanelServiceAccountUsername() string {
	if l == nil {
		return ""
	}
	return l.MixpanelServiceAccountUsername
}

func (l *LogStreamMixpanelSinkPatch) GetMixpanelServiceAccountPassword() *string {
	if l == nil {
		return nil
	}
	return l.MixpanelServiceAccountPassword
}

func (l *LogStreamMixpanelSinkPatch) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamMixpanelSinkPatch) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamMixpanelSinkPatch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamMixpanelSinkPatch(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamMixpanelSinkPatch) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamPiiAlgorithmEnum = string

type LogStreamPiiConfig struct {
	LogFields []LogStreamPiiLogFieldsEnum `json:"log_fields" url:"log_fields"`
	Method    *LogStreamPiiMethodEnum     `json:"method,omitempty" url:"method,omitempty"`
	Algorithm *LogStreamPiiAlgorithmEnum  `json:"algorithm,omitempty" url:"algorithm,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamPiiConfig) GetLogFields() []LogStreamPiiLogFieldsEnum {
	if l == nil {
		return nil
	}
	return l.LogFields
}

func (l *LogStreamPiiConfig) GetMethod() *LogStreamPiiMethodEnum {
	if l == nil {
		return nil
	}
	return l.Method
}

func (l *LogStreamPiiConfig) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamPiiConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamPiiConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamPiiConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamPiiConfig) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamPiiLogFieldsEnum string

const (
	LogStreamPiiLogFieldsEnumFirstName LogStreamPiiLogFieldsEnum = "first_name"
	LogStreamPiiLogFieldsEnumLastName  LogStreamPiiLogFieldsEnum = "last_name"
	LogStreamPiiLogFieldsEnumUsername  LogStreamPiiLogFieldsEnum = "username"
	LogStreamPiiLogFieldsEnumEmail     LogStreamPiiLogFieldsEnum = "email"
	LogStreamPiiLogFieldsEnumPhone     LogStreamPiiLogFieldsEnum = "phone"
	LogStreamPiiLogFieldsEnumAddress   LogStreamPiiLogFieldsEnum = "address"
)

func NewLogStreamPiiLogFieldsEnumFromString(s string) (LogStreamPiiLogFieldsEnum, error) {
	switch s {
	case "first_name":
		return LogStreamPiiLogFieldsEnumFirstName, nil
	case "last_name":
		return LogStreamPiiLogFieldsEnumLastName, nil
	case "username":
		return LogStreamPiiLogFieldsEnumUsername, nil
	case "email":
		return LogStreamPiiLogFieldsEnumEmail, nil
	case "phone":
		return LogStreamPiiLogFieldsEnumPhone, nil
	case "address":
		return LogStreamPiiLogFieldsEnumAddress, nil
	}
	var t LogStreamPiiLogFieldsEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogStreamPiiLogFieldsEnum) Ptr() *LogStreamPiiLogFieldsEnum {
	return &l
}

type LogStreamPiiMethodEnum string

const (
	LogStreamPiiMethodEnumMask LogStreamPiiMethodEnum = "mask"
	LogStreamPiiMethodEnumHash LogStreamPiiMethodEnum = "hash"
)

func NewLogStreamPiiMethodEnumFromString(s string) (LogStreamPiiMethodEnum, error) {
	switch s {
	case "mask":
		return LogStreamPiiMethodEnumMask, nil
	case "hash":
		return LogStreamPiiMethodEnumHash, nil
	}
	var t LogStreamPiiMethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogStreamPiiMethodEnum) Ptr() *LogStreamPiiMethodEnum {
	return &l
}

type LogStreamResponseSchema struct {
	LogStreamHTTPResponseSchema        *LogStreamHTTPResponseSchema
	LogStreamEventBridgeResponseSchema *LogStreamEventBridgeResponseSchema
	LogStreamEventGridResponseSchema   *LogStreamEventGridResponseSchema
	LogStreamDatadogResponseSchema     *LogStreamDatadogResponseSchema
	LogStreamSplunkResponseSchema      *LogStreamSplunkResponseSchema
	LogStreamSumoResponseSchema        *LogStreamSumoResponseSchema
	LogStreamSegmentResponseSchema     *LogStreamSegmentResponseSchema
	LogStreamMixpanelResponseSchema    *LogStreamMixpanelResponseSchema

	typ string
}

func (l *LogStreamResponseSchema) GetLogStreamHTTPResponseSchema() *LogStreamHTTPResponseSchema {
	if l == nil {
		return nil
	}
	return l.LogStreamHTTPResponseSchema
}

func (l *LogStreamResponseSchema) GetLogStreamEventBridgeResponseSchema() *LogStreamEventBridgeResponseSchema {
	if l == nil {
		return nil
	}
	return l.LogStreamEventBridgeResponseSchema
}

func (l *LogStreamResponseSchema) GetLogStreamEventGridResponseSchema() *LogStreamEventGridResponseSchema {
	if l == nil {
		return nil
	}
	return l.LogStreamEventGridResponseSchema
}

func (l *LogStreamResponseSchema) GetLogStreamDatadogResponseSchema() *LogStreamDatadogResponseSchema {
	if l == nil {
		return nil
	}
	return l.LogStreamDatadogResponseSchema
}

func (l *LogStreamResponseSchema) GetLogStreamSplunkResponseSchema() *LogStreamSplunkResponseSchema {
	if l == nil {
		return nil
	}
	return l.LogStreamSplunkResponseSchema
}

func (l *LogStreamResponseSchema) GetLogStreamSumoResponseSchema() *LogStreamSumoResponseSchema {
	if l == nil {
		return nil
	}
	return l.LogStreamSumoResponseSchema
}

func (l *LogStreamResponseSchema) GetLogStreamSegmentResponseSchema() *LogStreamSegmentResponseSchema {
	if l == nil {
		return nil
	}
	return l.LogStreamSegmentResponseSchema
}

func (l *LogStreamResponseSchema) GetLogStreamMixpanelResponseSchema() *LogStreamMixpanelResponseSchema {
	if l == nil {
		return nil
	}
	return l.LogStreamMixpanelResponseSchema
}

func (l *LogStreamResponseSchema) UnmarshalJSON(data []byte) error {
	valueLogStreamHTTPResponseSchema := new(LogStreamHTTPResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamHTTPResponseSchema); err == nil {
		l.typ = "LogStreamHTTPResponseSchema"
		l.LogStreamHTTPResponseSchema = valueLogStreamHTTPResponseSchema
		return nil
	}
	valueLogStreamEventBridgeResponseSchema := new(LogStreamEventBridgeResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamEventBridgeResponseSchema); err == nil {
		l.typ = "LogStreamEventBridgeResponseSchema"
		l.LogStreamEventBridgeResponseSchema = valueLogStreamEventBridgeResponseSchema
		return nil
	}
	valueLogStreamEventGridResponseSchema := new(LogStreamEventGridResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamEventGridResponseSchema); err == nil {
		l.typ = "LogStreamEventGridResponseSchema"
		l.LogStreamEventGridResponseSchema = valueLogStreamEventGridResponseSchema
		return nil
	}
	valueLogStreamDatadogResponseSchema := new(LogStreamDatadogResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamDatadogResponseSchema); err == nil {
		l.typ = "LogStreamDatadogResponseSchema"
		l.LogStreamDatadogResponseSchema = valueLogStreamDatadogResponseSchema
		return nil
	}
	valueLogStreamSplunkResponseSchema := new(LogStreamSplunkResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSplunkResponseSchema); err == nil {
		l.typ = "LogStreamSplunkResponseSchema"
		l.LogStreamSplunkResponseSchema = valueLogStreamSplunkResponseSchema
		return nil
	}
	valueLogStreamSumoResponseSchema := new(LogStreamSumoResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSumoResponseSchema); err == nil {
		l.typ = "LogStreamSumoResponseSchema"
		l.LogStreamSumoResponseSchema = valueLogStreamSumoResponseSchema
		return nil
	}
	valueLogStreamSegmentResponseSchema := new(LogStreamSegmentResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSegmentResponseSchema); err == nil {
		l.typ = "LogStreamSegmentResponseSchema"
		l.LogStreamSegmentResponseSchema = valueLogStreamSegmentResponseSchema
		return nil
	}
	valueLogStreamMixpanelResponseSchema := new(LogStreamMixpanelResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamMixpanelResponseSchema); err == nil {
		l.typ = "LogStreamMixpanelResponseSchema"
		l.LogStreamMixpanelResponseSchema = valueLogStreamMixpanelResponseSchema
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LogStreamResponseSchema) MarshalJSON() ([]byte, error) {
	if l.typ == "LogStreamHTTPResponseSchema" || l.LogStreamHTTPResponseSchema != nil {
		return json.Marshal(l.LogStreamHTTPResponseSchema)
	}
	if l.typ == "LogStreamEventBridgeResponseSchema" || l.LogStreamEventBridgeResponseSchema != nil {
		return json.Marshal(l.LogStreamEventBridgeResponseSchema)
	}
	if l.typ == "LogStreamEventGridResponseSchema" || l.LogStreamEventGridResponseSchema != nil {
		return json.Marshal(l.LogStreamEventGridResponseSchema)
	}
	if l.typ == "LogStreamDatadogResponseSchema" || l.LogStreamDatadogResponseSchema != nil {
		return json.Marshal(l.LogStreamDatadogResponseSchema)
	}
	if l.typ == "LogStreamSplunkResponseSchema" || l.LogStreamSplunkResponseSchema != nil {
		return json.Marshal(l.LogStreamSplunkResponseSchema)
	}
	if l.typ == "LogStreamSumoResponseSchema" || l.LogStreamSumoResponseSchema != nil {
		return json.Marshal(l.LogStreamSumoResponseSchema)
	}
	if l.typ == "LogStreamSegmentResponseSchema" || l.LogStreamSegmentResponseSchema != nil {
		return json.Marshal(l.LogStreamSegmentResponseSchema)
	}
	if l.typ == "LogStreamMixpanelResponseSchema" || l.LogStreamMixpanelResponseSchema != nil {
		return json.Marshal(l.LogStreamMixpanelResponseSchema)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LogStreamResponseSchemaVisitor interface {
	VisitLogStreamHTTPResponseSchema(*LogStreamHTTPResponseSchema) error
	VisitLogStreamEventBridgeResponseSchema(*LogStreamEventBridgeResponseSchema) error
	VisitLogStreamEventGridResponseSchema(*LogStreamEventGridResponseSchema) error
	VisitLogStreamDatadogResponseSchema(*LogStreamDatadogResponseSchema) error
	VisitLogStreamSplunkResponseSchema(*LogStreamSplunkResponseSchema) error
	VisitLogStreamSumoResponseSchema(*LogStreamSumoResponseSchema) error
	VisitLogStreamSegmentResponseSchema(*LogStreamSegmentResponseSchema) error
	VisitLogStreamMixpanelResponseSchema(*LogStreamMixpanelResponseSchema) error
}

func (l *LogStreamResponseSchema) Accept(visitor LogStreamResponseSchemaVisitor) error {
	if l.typ == "LogStreamHTTPResponseSchema" || l.LogStreamHTTPResponseSchema != nil {
		return visitor.VisitLogStreamHTTPResponseSchema(l.LogStreamHTTPResponseSchema)
	}
	if l.typ == "LogStreamEventBridgeResponseSchema" || l.LogStreamEventBridgeResponseSchema != nil {
		return visitor.VisitLogStreamEventBridgeResponseSchema(l.LogStreamEventBridgeResponseSchema)
	}
	if l.typ == "LogStreamEventGridResponseSchema" || l.LogStreamEventGridResponseSchema != nil {
		return visitor.VisitLogStreamEventGridResponseSchema(l.LogStreamEventGridResponseSchema)
	}
	if l.typ == "LogStreamDatadogResponseSchema" || l.LogStreamDatadogResponseSchema != nil {
		return visitor.VisitLogStreamDatadogResponseSchema(l.LogStreamDatadogResponseSchema)
	}
	if l.typ == "LogStreamSplunkResponseSchema" || l.LogStreamSplunkResponseSchema != nil {
		return visitor.VisitLogStreamSplunkResponseSchema(l.LogStreamSplunkResponseSchema)
	}
	if l.typ == "LogStreamSumoResponseSchema" || l.LogStreamSumoResponseSchema != nil {
		return visitor.VisitLogStreamSumoResponseSchema(l.LogStreamSumoResponseSchema)
	}
	if l.typ == "LogStreamSegmentResponseSchema" || l.LogStreamSegmentResponseSchema != nil {
		return visitor.VisitLogStreamSegmentResponseSchema(l.LogStreamSegmentResponseSchema)
	}
	if l.typ == "LogStreamMixpanelResponseSchema" || l.LogStreamMixpanelResponseSchema != nil {
		return visitor.VisitLogStreamMixpanelResponseSchema(l.LogStreamMixpanelResponseSchema)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LogStreamSegmentEnum = string

type LogStreamSegmentResponseSchema struct {
	// The id of the log stream
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// log stream name
	Name   *string               `json:"name,omitempty" url:"name,omitempty"`
	Status *LogStreamStatusEnum  `json:"status,omitempty" url:"status,omitempty"`
	Type   *LogStreamSegmentEnum `json:"type,omitempty" url:"type,omitempty"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter            `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig           `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamSegmentSinkWriteKey `json:"sink,omitempty" url:"sink,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *LogStreamSegmentResponseSchema) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LogStreamSegmentResponseSchema) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LogStreamSegmentResponseSchema) GetStatus() *LogStreamStatusEnum {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LogStreamSegmentResponseSchema) GetIsPriority() *bool {
	if l == nil {
		return nil
	}
	return l.IsPriority
}

func (l *LogStreamSegmentResponseSchema) GetFilters() []*LogStreamFilter {
	if l == nil {
		return nil
	}
	return l.Filters
}

func (l *LogStreamSegmentResponseSchema) GetPiiConfig() *LogStreamPiiConfig {
	if l == nil {
		return nil
	}
	return l.PiiConfig
}

func (l *LogStreamSegmentResponseSchema) GetSink() *LogStreamSegmentSinkWriteKey {
	if l == nil {
		return nil
	}
	return l.Sink
}

func (l *LogStreamSegmentResponseSchema) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *LogStreamSegmentResponseSchema) UnmarshalJSON(data []byte) error {
	type embed LogStreamSegmentResponseSchema
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LogStreamSegmentResponseSchema(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamSegmentResponseSchema) MarshalJSON() ([]byte, error) {
	type embed LogStreamSegmentResponseSchema
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *LogStreamSegmentResponseSchema) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamSegmentSink struct {
	// Segment write key
	SegmentWriteKey *string `json:"segmentWriteKey,omitempty" url:"segmentWriteKey,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamSegmentSink) GetSegmentWriteKey() *string {
	if l == nil {
		return nil
	}
	return l.SegmentWriteKey
}

func (l *LogStreamSegmentSink) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamSegmentSink) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamSegmentSink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamSegmentSink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamSegmentSink) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamSegmentSinkWriteKey struct {
	// Segment write key
	SegmentWriteKey string `json:"segmentWriteKey" url:"segmentWriteKey"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamSegmentSinkWriteKey) GetSegmentWriteKey() string {
	if l == nil {
		return ""
	}
	return l.SegmentWriteKey
}

func (l *LogStreamSegmentSinkWriteKey) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamSegmentSinkWriteKey) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamSegmentSinkWriteKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamSegmentSinkWriteKey(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamSegmentSinkWriteKey) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamSinkPatch struct {
	LogStreamHTTPSink          *LogStreamHTTPSink
	LogStreamDatadogSink       *LogStreamDatadogSink
	LogStreamSplunkSink        *LogStreamSplunkSink
	LogStreamSumoSink          *LogStreamSumoSink
	LogStreamSegmentSink       *LogStreamSegmentSink
	LogStreamMixpanelSinkPatch *LogStreamMixpanelSinkPatch

	typ string
}

func (l *LogStreamSinkPatch) GetLogStreamHTTPSink() *LogStreamHTTPSink {
	if l == nil {
		return nil
	}
	return l.LogStreamHTTPSink
}

func (l *LogStreamSinkPatch) GetLogStreamDatadogSink() *LogStreamDatadogSink {
	if l == nil {
		return nil
	}
	return l.LogStreamDatadogSink
}

func (l *LogStreamSinkPatch) GetLogStreamSplunkSink() *LogStreamSplunkSink {
	if l == nil {
		return nil
	}
	return l.LogStreamSplunkSink
}

func (l *LogStreamSinkPatch) GetLogStreamSumoSink() *LogStreamSumoSink {
	if l == nil {
		return nil
	}
	return l.LogStreamSumoSink
}

func (l *LogStreamSinkPatch) GetLogStreamSegmentSink() *LogStreamSegmentSink {
	if l == nil {
		return nil
	}
	return l.LogStreamSegmentSink
}

func (l *LogStreamSinkPatch) GetLogStreamMixpanelSinkPatch() *LogStreamMixpanelSinkPatch {
	if l == nil {
		return nil
	}
	return l.LogStreamMixpanelSinkPatch
}

func (l *LogStreamSinkPatch) UnmarshalJSON(data []byte) error {
	valueLogStreamHTTPSink := new(LogStreamHTTPSink)
	if err := json.Unmarshal(data, &valueLogStreamHTTPSink); err == nil {
		l.typ = "LogStreamHTTPSink"
		l.LogStreamHTTPSink = valueLogStreamHTTPSink
		return nil
	}
	valueLogStreamDatadogSink := new(LogStreamDatadogSink)
	if err := json.Unmarshal(data, &valueLogStreamDatadogSink); err == nil {
		l.typ = "LogStreamDatadogSink"
		l.LogStreamDatadogSink = valueLogStreamDatadogSink
		return nil
	}
	valueLogStreamSplunkSink := new(LogStreamSplunkSink)
	if err := json.Unmarshal(data, &valueLogStreamSplunkSink); err == nil {
		l.typ = "LogStreamSplunkSink"
		l.LogStreamSplunkSink = valueLogStreamSplunkSink
		return nil
	}
	valueLogStreamSumoSink := new(LogStreamSumoSink)
	if err := json.Unmarshal(data, &valueLogStreamSumoSink); err == nil {
		l.typ = "LogStreamSumoSink"
		l.LogStreamSumoSink = valueLogStreamSumoSink
		return nil
	}
	valueLogStreamSegmentSink := new(LogStreamSegmentSink)
	if err := json.Unmarshal(data, &valueLogStreamSegmentSink); err == nil {
		l.typ = "LogStreamSegmentSink"
		l.LogStreamSegmentSink = valueLogStreamSegmentSink
		return nil
	}
	valueLogStreamMixpanelSinkPatch := new(LogStreamMixpanelSinkPatch)
	if err := json.Unmarshal(data, &valueLogStreamMixpanelSinkPatch); err == nil {
		l.typ = "LogStreamMixpanelSinkPatch"
		l.LogStreamMixpanelSinkPatch = valueLogStreamMixpanelSinkPatch
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LogStreamSinkPatch) MarshalJSON() ([]byte, error) {
	if l.typ == "LogStreamHTTPSink" || l.LogStreamHTTPSink != nil {
		return json.Marshal(l.LogStreamHTTPSink)
	}
	if l.typ == "LogStreamDatadogSink" || l.LogStreamDatadogSink != nil {
		return json.Marshal(l.LogStreamDatadogSink)
	}
	if l.typ == "LogStreamSplunkSink" || l.LogStreamSplunkSink != nil {
		return json.Marshal(l.LogStreamSplunkSink)
	}
	if l.typ == "LogStreamSumoSink" || l.LogStreamSumoSink != nil {
		return json.Marshal(l.LogStreamSumoSink)
	}
	if l.typ == "LogStreamSegmentSink" || l.LogStreamSegmentSink != nil {
		return json.Marshal(l.LogStreamSegmentSink)
	}
	if l.typ == "LogStreamMixpanelSinkPatch" || l.LogStreamMixpanelSinkPatch != nil {
		return json.Marshal(l.LogStreamMixpanelSinkPatch)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LogStreamSinkPatchVisitor interface {
	VisitLogStreamHTTPSink(*LogStreamHTTPSink) error
	VisitLogStreamDatadogSink(*LogStreamDatadogSink) error
	VisitLogStreamSplunkSink(*LogStreamSplunkSink) error
	VisitLogStreamSumoSink(*LogStreamSumoSink) error
	VisitLogStreamSegmentSink(*LogStreamSegmentSink) error
	VisitLogStreamMixpanelSinkPatch(*LogStreamMixpanelSinkPatch) error
}

func (l *LogStreamSinkPatch) Accept(visitor LogStreamSinkPatchVisitor) error {
	if l.typ == "LogStreamHTTPSink" || l.LogStreamHTTPSink != nil {
		return visitor.VisitLogStreamHTTPSink(l.LogStreamHTTPSink)
	}
	if l.typ == "LogStreamDatadogSink" || l.LogStreamDatadogSink != nil {
		return visitor.VisitLogStreamDatadogSink(l.LogStreamDatadogSink)
	}
	if l.typ == "LogStreamSplunkSink" || l.LogStreamSplunkSink != nil {
		return visitor.VisitLogStreamSplunkSink(l.LogStreamSplunkSink)
	}
	if l.typ == "LogStreamSumoSink" || l.LogStreamSumoSink != nil {
		return visitor.VisitLogStreamSumoSink(l.LogStreamSumoSink)
	}
	if l.typ == "LogStreamSegmentSink" || l.LogStreamSegmentSink != nil {
		return visitor.VisitLogStreamSegmentSink(l.LogStreamSegmentSink)
	}
	if l.typ == "LogStreamMixpanelSinkPatch" || l.LogStreamMixpanelSinkPatch != nil {
		return visitor.VisitLogStreamMixpanelSinkPatch(l.LogStreamMixpanelSinkPatch)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LogStreamSplunkEnum = string

type LogStreamSplunkResponseSchema struct {
	// The id of the log stream
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// log stream name
	Name   *string              `json:"name,omitempty" url:"name,omitempty"`
	Status *LogStreamStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	Type   *LogStreamSplunkEnum `json:"type,omitempty" url:"type,omitempty"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter   `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig  `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamSplunkSink `json:"sink,omitempty" url:"sink,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *LogStreamSplunkResponseSchema) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LogStreamSplunkResponseSchema) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LogStreamSplunkResponseSchema) GetStatus() *LogStreamStatusEnum {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LogStreamSplunkResponseSchema) GetIsPriority() *bool {
	if l == nil {
		return nil
	}
	return l.IsPriority
}

func (l *LogStreamSplunkResponseSchema) GetFilters() []*LogStreamFilter {
	if l == nil {
		return nil
	}
	return l.Filters
}

func (l *LogStreamSplunkResponseSchema) GetPiiConfig() *LogStreamPiiConfig {
	if l == nil {
		return nil
	}
	return l.PiiConfig
}

func (l *LogStreamSplunkResponseSchema) GetSink() *LogStreamSplunkSink {
	if l == nil {
		return nil
	}
	return l.Sink
}

func (l *LogStreamSplunkResponseSchema) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *LogStreamSplunkResponseSchema) UnmarshalJSON(data []byte) error {
	type embed LogStreamSplunkResponseSchema
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LogStreamSplunkResponseSchema(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamSplunkResponseSchema) MarshalJSON() ([]byte, error) {
	type embed LogStreamSplunkResponseSchema
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *LogStreamSplunkResponseSchema) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamSplunkSink struct {
	// Splunk URL Endpoint
	SplunkDomain string `json:"splunkDomain" url:"splunkDomain"`
	// Port
	SplunkPort string `json:"splunkPort" url:"splunkPort"`
	// Splunk token
	SplunkToken string `json:"splunkToken" url:"splunkToken"`
	// Verify TLS certificate
	SplunkSecure bool `json:"splunkSecure" url:"splunkSecure"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamSplunkSink) GetSplunkDomain() string {
	if l == nil {
		return ""
	}
	return l.SplunkDomain
}

func (l *LogStreamSplunkSink) GetSplunkPort() string {
	if l == nil {
		return ""
	}
	return l.SplunkPort
}

func (l *LogStreamSplunkSink) GetSplunkToken() string {
	if l == nil {
		return ""
	}
	return l.SplunkToken
}

func (l *LogStreamSplunkSink) GetSplunkSecure() bool {
	if l == nil {
		return false
	}
	return l.SplunkSecure
}

func (l *LogStreamSplunkSink) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamSplunkSink) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamSplunkSink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamSplunkSink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamSplunkSink) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The status of the log stream. Possible values: `active`, `paused`, `suspended`
type LogStreamStatusEnum string

const (
	LogStreamStatusEnumActive    LogStreamStatusEnum = "active"
	LogStreamStatusEnumPaused    LogStreamStatusEnum = "paused"
	LogStreamStatusEnumSuspended LogStreamStatusEnum = "suspended"
)

func NewLogStreamStatusEnumFromString(s string) (LogStreamStatusEnum, error) {
	switch s {
	case "active":
		return LogStreamStatusEnumActive, nil
	case "paused":
		return LogStreamStatusEnumPaused, nil
	case "suspended":
		return LogStreamStatusEnumSuspended, nil
	}
	var t LogStreamStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogStreamStatusEnum) Ptr() *LogStreamStatusEnum {
	return &l
}

type LogStreamSumoEnum = string

type LogStreamSumoResponseSchema struct {
	// The id of the log stream
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// log stream name
	Name   *string              `json:"name,omitempty" url:"name,omitempty"`
	Status *LogStreamStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	Type   *LogStreamSumoEnum   `json:"type,omitempty" url:"type,omitempty"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"isPriority,omitempty"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter  `json:"filters,omitempty" url:"filters,omitempty"`
	PiiConfig *LogStreamPiiConfig `json:"pii_config,omitempty" url:"pii_config,omitempty"`
	Sink      *LogStreamSumoSink  `json:"sink,omitempty" url:"sink,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *LogStreamSumoResponseSchema) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LogStreamSumoResponseSchema) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LogStreamSumoResponseSchema) GetStatus() *LogStreamStatusEnum {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LogStreamSumoResponseSchema) GetIsPriority() *bool {
	if l == nil {
		return nil
	}
	return l.IsPriority
}

func (l *LogStreamSumoResponseSchema) GetFilters() []*LogStreamFilter {
	if l == nil {
		return nil
	}
	return l.Filters
}

func (l *LogStreamSumoResponseSchema) GetPiiConfig() *LogStreamPiiConfig {
	if l == nil {
		return nil
	}
	return l.PiiConfig
}

func (l *LogStreamSumoResponseSchema) GetSink() *LogStreamSumoSink {
	if l == nil {
		return nil
	}
	return l.Sink
}

func (l *LogStreamSumoResponseSchema) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *LogStreamSumoResponseSchema) UnmarshalJSON(data []byte) error {
	type embed LogStreamSumoResponseSchema
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LogStreamSumoResponseSchema(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamSumoResponseSchema) MarshalJSON() ([]byte, error) {
	type embed LogStreamSumoResponseSchema
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, l.ExtraProperties)
}

func (l *LogStreamSumoResponseSchema) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogStreamSumoSink struct {
	// HTTP Source Address
	SumoSourceAddress string `json:"sumoSourceAddress" url:"sumoSourceAddress"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogStreamSumoSink) GetSumoSourceAddress() string {
	if l == nil {
		return ""
	}
	return l.SumoSourceAddress
}

func (l *LogStreamSumoSink) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogStreamSumoSink) UnmarshalJSON(data []byte) error {
	type unmarshaler LogStreamSumoSink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogStreamSumoSink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogStreamSumoSink) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type UpdateLogStreamResponseContent struct {
	LogStreamHTTPResponseSchema        *LogStreamHTTPResponseSchema
	LogStreamEventBridgeResponseSchema *LogStreamEventBridgeResponseSchema
	LogStreamEventGridResponseSchema   *LogStreamEventGridResponseSchema
	LogStreamDatadogResponseSchema     *LogStreamDatadogResponseSchema
	LogStreamSplunkResponseSchema      *LogStreamSplunkResponseSchema
	LogStreamSumoResponseSchema        *LogStreamSumoResponseSchema
	LogStreamSegmentResponseSchema     *LogStreamSegmentResponseSchema
	LogStreamMixpanelResponseSchema    *LogStreamMixpanelResponseSchema

	typ string
}

func (u *UpdateLogStreamResponseContent) GetLogStreamHTTPResponseSchema() *LogStreamHTTPResponseSchema {
	if u == nil {
		return nil
	}
	return u.LogStreamHTTPResponseSchema
}

func (u *UpdateLogStreamResponseContent) GetLogStreamEventBridgeResponseSchema() *LogStreamEventBridgeResponseSchema {
	if u == nil {
		return nil
	}
	return u.LogStreamEventBridgeResponseSchema
}

func (u *UpdateLogStreamResponseContent) GetLogStreamEventGridResponseSchema() *LogStreamEventGridResponseSchema {
	if u == nil {
		return nil
	}
	return u.LogStreamEventGridResponseSchema
}

func (u *UpdateLogStreamResponseContent) GetLogStreamDatadogResponseSchema() *LogStreamDatadogResponseSchema {
	if u == nil {
		return nil
	}
	return u.LogStreamDatadogResponseSchema
}

func (u *UpdateLogStreamResponseContent) GetLogStreamSplunkResponseSchema() *LogStreamSplunkResponseSchema {
	if u == nil {
		return nil
	}
	return u.LogStreamSplunkResponseSchema
}

func (u *UpdateLogStreamResponseContent) GetLogStreamSumoResponseSchema() *LogStreamSumoResponseSchema {
	if u == nil {
		return nil
	}
	return u.LogStreamSumoResponseSchema
}

func (u *UpdateLogStreamResponseContent) GetLogStreamSegmentResponseSchema() *LogStreamSegmentResponseSchema {
	if u == nil {
		return nil
	}
	return u.LogStreamSegmentResponseSchema
}

func (u *UpdateLogStreamResponseContent) GetLogStreamMixpanelResponseSchema() *LogStreamMixpanelResponseSchema {
	if u == nil {
		return nil
	}
	return u.LogStreamMixpanelResponseSchema
}

func (u *UpdateLogStreamResponseContent) UnmarshalJSON(data []byte) error {
	valueLogStreamHTTPResponseSchema := new(LogStreamHTTPResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamHTTPResponseSchema); err == nil {
		u.typ = "LogStreamHTTPResponseSchema"
		u.LogStreamHTTPResponseSchema = valueLogStreamHTTPResponseSchema
		return nil
	}
	valueLogStreamEventBridgeResponseSchema := new(LogStreamEventBridgeResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamEventBridgeResponseSchema); err == nil {
		u.typ = "LogStreamEventBridgeResponseSchema"
		u.LogStreamEventBridgeResponseSchema = valueLogStreamEventBridgeResponseSchema
		return nil
	}
	valueLogStreamEventGridResponseSchema := new(LogStreamEventGridResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamEventGridResponseSchema); err == nil {
		u.typ = "LogStreamEventGridResponseSchema"
		u.LogStreamEventGridResponseSchema = valueLogStreamEventGridResponseSchema
		return nil
	}
	valueLogStreamDatadogResponseSchema := new(LogStreamDatadogResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamDatadogResponseSchema); err == nil {
		u.typ = "LogStreamDatadogResponseSchema"
		u.LogStreamDatadogResponseSchema = valueLogStreamDatadogResponseSchema
		return nil
	}
	valueLogStreamSplunkResponseSchema := new(LogStreamSplunkResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSplunkResponseSchema); err == nil {
		u.typ = "LogStreamSplunkResponseSchema"
		u.LogStreamSplunkResponseSchema = valueLogStreamSplunkResponseSchema
		return nil
	}
	valueLogStreamSumoResponseSchema := new(LogStreamSumoResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSumoResponseSchema); err == nil {
		u.typ = "LogStreamSumoResponseSchema"
		u.LogStreamSumoResponseSchema = valueLogStreamSumoResponseSchema
		return nil
	}
	valueLogStreamSegmentResponseSchema := new(LogStreamSegmentResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamSegmentResponseSchema); err == nil {
		u.typ = "LogStreamSegmentResponseSchema"
		u.LogStreamSegmentResponseSchema = valueLogStreamSegmentResponseSchema
		return nil
	}
	valueLogStreamMixpanelResponseSchema := new(LogStreamMixpanelResponseSchema)
	if err := json.Unmarshal(data, &valueLogStreamMixpanelResponseSchema); err == nil {
		u.typ = "LogStreamMixpanelResponseSchema"
		u.LogStreamMixpanelResponseSchema = valueLogStreamMixpanelResponseSchema
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateLogStreamResponseContent) MarshalJSON() ([]byte, error) {
	if u.typ == "LogStreamHTTPResponseSchema" || u.LogStreamHTTPResponseSchema != nil {
		return json.Marshal(u.LogStreamHTTPResponseSchema)
	}
	if u.typ == "LogStreamEventBridgeResponseSchema" || u.LogStreamEventBridgeResponseSchema != nil {
		return json.Marshal(u.LogStreamEventBridgeResponseSchema)
	}
	if u.typ == "LogStreamEventGridResponseSchema" || u.LogStreamEventGridResponseSchema != nil {
		return json.Marshal(u.LogStreamEventGridResponseSchema)
	}
	if u.typ == "LogStreamDatadogResponseSchema" || u.LogStreamDatadogResponseSchema != nil {
		return json.Marshal(u.LogStreamDatadogResponseSchema)
	}
	if u.typ == "LogStreamSplunkResponseSchema" || u.LogStreamSplunkResponseSchema != nil {
		return json.Marshal(u.LogStreamSplunkResponseSchema)
	}
	if u.typ == "LogStreamSumoResponseSchema" || u.LogStreamSumoResponseSchema != nil {
		return json.Marshal(u.LogStreamSumoResponseSchema)
	}
	if u.typ == "LogStreamSegmentResponseSchema" || u.LogStreamSegmentResponseSchema != nil {
		return json.Marshal(u.LogStreamSegmentResponseSchema)
	}
	if u.typ == "LogStreamMixpanelResponseSchema" || u.LogStreamMixpanelResponseSchema != nil {
		return json.Marshal(u.LogStreamMixpanelResponseSchema)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateLogStreamResponseContentVisitor interface {
	VisitLogStreamHTTPResponseSchema(*LogStreamHTTPResponseSchema) error
	VisitLogStreamEventBridgeResponseSchema(*LogStreamEventBridgeResponseSchema) error
	VisitLogStreamEventGridResponseSchema(*LogStreamEventGridResponseSchema) error
	VisitLogStreamDatadogResponseSchema(*LogStreamDatadogResponseSchema) error
	VisitLogStreamSplunkResponseSchema(*LogStreamSplunkResponseSchema) error
	VisitLogStreamSumoResponseSchema(*LogStreamSumoResponseSchema) error
	VisitLogStreamSegmentResponseSchema(*LogStreamSegmentResponseSchema) error
	VisitLogStreamMixpanelResponseSchema(*LogStreamMixpanelResponseSchema) error
}

func (u *UpdateLogStreamResponseContent) Accept(visitor UpdateLogStreamResponseContentVisitor) error {
	if u.typ == "LogStreamHTTPResponseSchema" || u.LogStreamHTTPResponseSchema != nil {
		return visitor.VisitLogStreamHTTPResponseSchema(u.LogStreamHTTPResponseSchema)
	}
	if u.typ == "LogStreamEventBridgeResponseSchema" || u.LogStreamEventBridgeResponseSchema != nil {
		return visitor.VisitLogStreamEventBridgeResponseSchema(u.LogStreamEventBridgeResponseSchema)
	}
	if u.typ == "LogStreamEventGridResponseSchema" || u.LogStreamEventGridResponseSchema != nil {
		return visitor.VisitLogStreamEventGridResponseSchema(u.LogStreamEventGridResponseSchema)
	}
	if u.typ == "LogStreamDatadogResponseSchema" || u.LogStreamDatadogResponseSchema != nil {
		return visitor.VisitLogStreamDatadogResponseSchema(u.LogStreamDatadogResponseSchema)
	}
	if u.typ == "LogStreamSplunkResponseSchema" || u.LogStreamSplunkResponseSchema != nil {
		return visitor.VisitLogStreamSplunkResponseSchema(u.LogStreamSplunkResponseSchema)
	}
	if u.typ == "LogStreamSumoResponseSchema" || u.LogStreamSumoResponseSchema != nil {
		return visitor.VisitLogStreamSumoResponseSchema(u.LogStreamSumoResponseSchema)
	}
	if u.typ == "LogStreamSegmentResponseSchema" || u.LogStreamSegmentResponseSchema != nil {
		return visitor.VisitLogStreamSegmentResponseSchema(u.LogStreamSegmentResponseSchema)
	}
	if u.typ == "LogStreamMixpanelResponseSchema" || u.LogStreamMixpanelResponseSchema != nil {
		return visitor.VisitLogStreamMixpanelResponseSchema(u.LogStreamMixpanelResponseSchema)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateLogStreamRequestContent struct {
	// log stream name
	Name   *string              `json:"name,omitempty" url:"-"`
	Status *LogStreamStatusEnum `json:"status,omitempty" url:"-"`
	// True for priority log streams, false for non-priority
	IsPriority *bool `json:"isPriority,omitempty" url:"-"`
	// Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered.
	Filters   []*LogStreamFilter  `json:"filters,omitempty" url:"-"`
	PiiConfig *LogStreamPiiConfig `json:"pii_config,omitempty" url:"-"`
	Sink      *LogStreamSinkPatch `json:"sink,omitempty" url:"-"`
}
