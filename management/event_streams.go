// Code generated by Fern. DO NOT EDIT.

package management

import (
	json "encoding/json"
	fmt "fmt"
	time "time"

	internal "github.com/auth0/go-auth0/v2/management/internal"
)

type EventStreamsGetStatsRequest struct {
	// The RFC3339 start date for the stats query.
	DateFrom *string `json:"-" url:"date_from,omitempty"`
	// The RFC3339 end date for the stats query.
	DateTo *string `json:"-" url:"date_to,omitempty"`
}

type ListEventStreamsRequestParameters struct {
	// Optional Id from which to start selection.
	From *string `json:"-" url:"from,omitempty"`
	// Number of results per page. Defaults to 50.
	Take *int `json:"-" url:"take,omitempty"`
}

type CreateEventStreamTestEventRequestContent struct {
	EventType EventStreamTestEventTypeEnum `json:"event_type" url:"-"`
	Data      *TestEventDataContent        `json:"data,omitempty" url:"-"`
}

type CreateEventStreamActionRequestContent struct {
	// Name of the event stream.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// List of event types subscribed to in this stream.
	Subscriptions []*EventStreamSubscription    `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	Destination   *EventStreamActionDestination `json:"destination" url:"destination"`
	Status        *EventStreamStatusEnum        `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateEventStreamActionRequestContent) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateEventStreamActionRequestContent) GetSubscriptions() []*EventStreamSubscription {
	if c == nil {
		return nil
	}
	return c.Subscriptions
}

func (c *CreateEventStreamActionRequestContent) GetDestination() *EventStreamActionDestination {
	if c == nil {
		return nil
	}
	return c.Destination
}

func (c *CreateEventStreamActionRequestContent) GetStatus() *EventStreamStatusEnum {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CreateEventStreamActionRequestContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateEventStreamActionRequestContent) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateEventStreamActionRequestContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateEventStreamActionRequestContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEventStreamActionRequestContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEventStreamEventBridgeRequestContent struct {
	// Name of the event stream.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// List of event types subscribed to in this stream.
	Subscriptions []*EventStreamSubscription         `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	Destination   *EventStreamEventBridgeDestination `json:"destination" url:"destination"`
	Status        *EventStreamStatusEnum             `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateEventStreamEventBridgeRequestContent) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateEventStreamEventBridgeRequestContent) GetSubscriptions() []*EventStreamSubscription {
	if c == nil {
		return nil
	}
	return c.Subscriptions
}

func (c *CreateEventStreamEventBridgeRequestContent) GetDestination() *EventStreamEventBridgeDestination {
	if c == nil {
		return nil
	}
	return c.Destination
}

func (c *CreateEventStreamEventBridgeRequestContent) GetStatus() *EventStreamStatusEnum {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CreateEventStreamEventBridgeRequestContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateEventStreamEventBridgeRequestContent) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateEventStreamEventBridgeRequestContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateEventStreamEventBridgeRequestContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEventStreamEventBridgeRequestContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEventStreamResponseContent struct {
	EventStreamWebhookResponseContent     *EventStreamWebhookResponseContent
	EventStreamEventBridgeResponseContent *EventStreamEventBridgeResponseContent
	EventStreamActionResponseContent      *EventStreamActionResponseContent

	typ string
}

func (c *CreateEventStreamResponseContent) GetEventStreamWebhookResponseContent() *EventStreamWebhookResponseContent {
	if c == nil {
		return nil
	}
	return c.EventStreamWebhookResponseContent
}

func (c *CreateEventStreamResponseContent) GetEventStreamEventBridgeResponseContent() *EventStreamEventBridgeResponseContent {
	if c == nil {
		return nil
	}
	return c.EventStreamEventBridgeResponseContent
}

func (c *CreateEventStreamResponseContent) GetEventStreamActionResponseContent() *EventStreamActionResponseContent {
	if c == nil {
		return nil
	}
	return c.EventStreamActionResponseContent
}

func (c *CreateEventStreamResponseContent) UnmarshalJSON(data []byte) error {
	valueEventStreamWebhookResponseContent := new(EventStreamWebhookResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamWebhookResponseContent); err == nil {
		c.typ = "EventStreamWebhookResponseContent"
		c.EventStreamWebhookResponseContent = valueEventStreamWebhookResponseContent
		return nil
	}
	valueEventStreamEventBridgeResponseContent := new(EventStreamEventBridgeResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamEventBridgeResponseContent); err == nil {
		c.typ = "EventStreamEventBridgeResponseContent"
		c.EventStreamEventBridgeResponseContent = valueEventStreamEventBridgeResponseContent
		return nil
	}
	valueEventStreamActionResponseContent := new(EventStreamActionResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamActionResponseContent); err == nil {
		c.typ = "EventStreamActionResponseContent"
		c.EventStreamActionResponseContent = valueEventStreamActionResponseContent
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventStreamResponseContent) MarshalJSON() ([]byte, error) {
	if c.typ == "EventStreamWebhookResponseContent" || c.EventStreamWebhookResponseContent != nil {
		return json.Marshal(c.EventStreamWebhookResponseContent)
	}
	if c.typ == "EventStreamEventBridgeResponseContent" || c.EventStreamEventBridgeResponseContent != nil {
		return json.Marshal(c.EventStreamEventBridgeResponseContent)
	}
	if c.typ == "EventStreamActionResponseContent" || c.EventStreamActionResponseContent != nil {
		return json.Marshal(c.EventStreamActionResponseContent)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateEventStreamResponseContentVisitor interface {
	VisitEventStreamWebhookResponseContent(*EventStreamWebhookResponseContent) error
	VisitEventStreamEventBridgeResponseContent(*EventStreamEventBridgeResponseContent) error
	VisitEventStreamActionResponseContent(*EventStreamActionResponseContent) error
}

func (c *CreateEventStreamResponseContent) Accept(visitor CreateEventStreamResponseContentVisitor) error {
	if c.typ == "EventStreamWebhookResponseContent" || c.EventStreamWebhookResponseContent != nil {
		return visitor.VisitEventStreamWebhookResponseContent(c.EventStreamWebhookResponseContent)
	}
	if c.typ == "EventStreamEventBridgeResponseContent" || c.EventStreamEventBridgeResponseContent != nil {
		return visitor.VisitEventStreamEventBridgeResponseContent(c.EventStreamEventBridgeResponseContent)
	}
	if c.typ == "EventStreamActionResponseContent" || c.EventStreamActionResponseContent != nil {
		return visitor.VisitEventStreamActionResponseContent(c.EventStreamActionResponseContent)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Metadata about a specific attempt to deliver an event
type CreateEventStreamTestEventResponseContent struct {
	// Unique identifier for the delivery
	ID string `json:"id" url:"id"`
	// Unique identifier for the event stream.
	EventStreamID string                           `json:"event_stream_id" url:"event_stream_id"`
	Status        EventStreamDeliveryStatusEnum    `json:"status" url:"status"`
	EventType     EventStreamDeliveryEventTypeEnum `json:"event_type" url:"event_type"`
	// Results of delivery attempts
	Attempts []*EventStreamDeliveryAttempt `json:"attempts" url:"attempts"`
	Event    *EventStreamCloudEvent        `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateEventStreamTestEventResponseContent) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateEventStreamTestEventResponseContent) GetEventStreamID() string {
	if c == nil {
		return ""
	}
	return c.EventStreamID
}

func (c *CreateEventStreamTestEventResponseContent) GetEventType() EventStreamDeliveryEventTypeEnum {
	if c == nil {
		return ""
	}
	return c.EventType
}

func (c *CreateEventStreamTestEventResponseContent) GetAttempts() []*EventStreamDeliveryAttempt {
	if c == nil {
		return nil
	}
	return c.Attempts
}

func (c *CreateEventStreamTestEventResponseContent) GetEvent() *EventStreamCloudEvent {
	if c == nil {
		return nil
	}
	return c.Event
}

func (c *CreateEventStreamTestEventResponseContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateEventStreamTestEventResponseContent) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateEventStreamTestEventResponseContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateEventStreamTestEventResponseContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEventStreamTestEventResponseContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEventStreamWebHookRequestContent struct {
	// Name of the event stream.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// List of event types subscribed to in this stream.
	Subscriptions []*EventStreamSubscription     `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	Destination   *EventStreamWebhookDestination `json:"destination" url:"destination"`
	Status        *EventStreamStatusEnum         `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateEventStreamWebHookRequestContent) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateEventStreamWebHookRequestContent) GetSubscriptions() []*EventStreamSubscription {
	if c == nil {
		return nil
	}
	return c.Subscriptions
}

func (c *CreateEventStreamWebHookRequestContent) GetDestination() *EventStreamWebhookDestination {
	if c == nil {
		return nil
	}
	return c.Destination
}

func (c *CreateEventStreamWebHookRequestContent) GetStatus() *EventStreamStatusEnum {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CreateEventStreamWebHookRequestContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateEventStreamWebHookRequestContent) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateEventStreamWebHookRequestContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateEventStreamWebHookRequestContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEventStreamWebHookRequestContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configuration specific to an action destination.
type EventStreamActionConfiguration struct {
	// Action ID for the action destination.
	ActionID string `json:"action_id" url:"action_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamActionConfiguration) GetActionID() string {
	if e == nil {
		return ""
	}
	return e.ActionID
}

func (e *EventStreamActionConfiguration) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamActionConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamActionConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamActionConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamActionConfiguration) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamActionDestination struct {
	Type          EventStreamActionDestinationTypeEnum `json:"type" url:"type"`
	Configuration *EventStreamActionConfiguration      `json:"configuration" url:"configuration"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamActionDestination) GetConfiguration() *EventStreamActionConfiguration {
	if e == nil {
		return nil
	}
	return e.Configuration
}

func (e *EventStreamActionDestination) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamActionDestination) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamActionDestination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamActionDestination(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamActionDestination) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamActionDestinationTypeEnum = string

type EventStreamActionResponseContent struct {
	// Unique identifier for the event stream.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Name of the event stream.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// List of event types subscribed to in this stream.
	Subscriptions []*EventStreamSubscription    `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	Destination   *EventStreamActionDestination `json:"destination,omitempty" url:"destination,omitempty"`
	Status        *EventStreamStatusEnum        `json:"status,omitempty" url:"status,omitempty"`
	// Timestamp when the event stream was created.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Timestamp when the event stream was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamActionResponseContent) GetID() *string {
	if e == nil {
		return nil
	}
	return e.ID
}

func (e *EventStreamActionResponseContent) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EventStreamActionResponseContent) GetSubscriptions() []*EventStreamSubscription {
	if e == nil {
		return nil
	}
	return e.Subscriptions
}

func (e *EventStreamActionResponseContent) GetDestination() *EventStreamActionDestination {
	if e == nil {
		return nil
	}
	return e.Destination
}

func (e *EventStreamActionResponseContent) GetStatus() *EventStreamStatusEnum {
	if e == nil {
		return nil
	}
	return e.Status
}

func (e *EventStreamActionResponseContent) GetCreatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedAt
}

func (e *EventStreamActionResponseContent) GetUpdatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.UpdatedAt
}

func (e *EventStreamActionResponseContent) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamActionResponseContent) UnmarshalJSON(data []byte) error {
	type embed EventStreamActionResponseContent
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventStreamActionResponseContent(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	e.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamActionResponseContent) MarshalJSON() ([]byte, error) {
	type embed EventStreamActionResponseContent
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewOptionalDateTime(e.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EventStreamActionResponseContent) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamBucketInterval struct {
	// Time interval in seconds for each bucket.
	ScaleFactor int `json:"scale_factor" url:"scale_factor"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamBucketInterval) GetScaleFactor() int {
	if e == nil {
		return 0
	}
	return e.ScaleFactor
}

func (e *EventStreamBucketInterval) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamBucketInterval) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamBucketInterval
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamBucketInterval(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamBucketInterval) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamDestinationPatch struct {
	EventStreamWebhookDestination *EventStreamWebhookDestination
	EventStreamActionDestination  *EventStreamActionDestination

	typ string
}

func (e *EventStreamDestinationPatch) GetEventStreamWebhookDestination() *EventStreamWebhookDestination {
	if e == nil {
		return nil
	}
	return e.EventStreamWebhookDestination
}

func (e *EventStreamDestinationPatch) GetEventStreamActionDestination() *EventStreamActionDestination {
	if e == nil {
		return nil
	}
	return e.EventStreamActionDestination
}

func (e *EventStreamDestinationPatch) UnmarshalJSON(data []byte) error {
	valueEventStreamWebhookDestination := new(EventStreamWebhookDestination)
	if err := json.Unmarshal(data, &valueEventStreamWebhookDestination); err == nil {
		e.typ = "EventStreamWebhookDestination"
		e.EventStreamWebhookDestination = valueEventStreamWebhookDestination
		return nil
	}
	valueEventStreamActionDestination := new(EventStreamActionDestination)
	if err := json.Unmarshal(data, &valueEventStreamActionDestination); err == nil {
		e.typ = "EventStreamActionDestination"
		e.EventStreamActionDestination = valueEventStreamActionDestination
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventStreamDestinationPatch) MarshalJSON() ([]byte, error) {
	if e.typ == "EventStreamWebhookDestination" || e.EventStreamWebhookDestination != nil {
		return json.Marshal(e.EventStreamWebhookDestination)
	}
	if e.typ == "EventStreamActionDestination" || e.EventStreamActionDestination != nil {
		return json.Marshal(e.EventStreamActionDestination)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EventStreamDestinationPatchVisitor interface {
	VisitEventStreamWebhookDestination(*EventStreamWebhookDestination) error
	VisitEventStreamActionDestination(*EventStreamActionDestination) error
}

func (e *EventStreamDestinationPatch) Accept(visitor EventStreamDestinationPatchVisitor) error {
	if e.typ == "EventStreamWebhookDestination" || e.EventStreamWebhookDestination != nil {
		return visitor.VisitEventStreamWebhookDestination(e.EventStreamWebhookDestination)
	}
	if e.typ == "EventStreamActionDestination" || e.EventStreamActionDestination != nil {
		return visitor.VisitEventStreamActionDestination(e.EventStreamActionDestination)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// AWS Region for EventBridge destination.
type EventStreamEventBridgeAwsRegionEnum string

const (
	EventStreamEventBridgeAwsRegionEnumApEast1      EventStreamEventBridgeAwsRegionEnum = "ap-east-1"
	EventStreamEventBridgeAwsRegionEnumApNortheast1 EventStreamEventBridgeAwsRegionEnum = "ap-northeast-1"
	EventStreamEventBridgeAwsRegionEnumApNortheast2 EventStreamEventBridgeAwsRegionEnum = "ap-northeast-2"
	EventStreamEventBridgeAwsRegionEnumApNortheast3 EventStreamEventBridgeAwsRegionEnum = "ap-northeast-3"
	EventStreamEventBridgeAwsRegionEnumApSouth1     EventStreamEventBridgeAwsRegionEnum = "ap-south-1"
	EventStreamEventBridgeAwsRegionEnumApSoutheast1 EventStreamEventBridgeAwsRegionEnum = "ap-southeast-1"
	EventStreamEventBridgeAwsRegionEnumApSoutheast2 EventStreamEventBridgeAwsRegionEnum = "ap-southeast-2"
	EventStreamEventBridgeAwsRegionEnumCaCentral1   EventStreamEventBridgeAwsRegionEnum = "ca-central-1"
	EventStreamEventBridgeAwsRegionEnumCnNorth1     EventStreamEventBridgeAwsRegionEnum = "cn-north-1"
	EventStreamEventBridgeAwsRegionEnumCnNorthwest1 EventStreamEventBridgeAwsRegionEnum = "cn-northwest-1"
	EventStreamEventBridgeAwsRegionEnumEuCentral1   EventStreamEventBridgeAwsRegionEnum = "eu-central-1"
	EventStreamEventBridgeAwsRegionEnumEuNorth1     EventStreamEventBridgeAwsRegionEnum = "eu-north-1"
	EventStreamEventBridgeAwsRegionEnumEuWest1      EventStreamEventBridgeAwsRegionEnum = "eu-west-1"
	EventStreamEventBridgeAwsRegionEnumEuWest2      EventStreamEventBridgeAwsRegionEnum = "eu-west-2"
	EventStreamEventBridgeAwsRegionEnumEuWest3      EventStreamEventBridgeAwsRegionEnum = "eu-west-3"
	EventStreamEventBridgeAwsRegionEnumMeSouth1     EventStreamEventBridgeAwsRegionEnum = "me-south-1"
	EventStreamEventBridgeAwsRegionEnumSaEast1      EventStreamEventBridgeAwsRegionEnum = "sa-east-1"
	EventStreamEventBridgeAwsRegionEnumUsGovEast1   EventStreamEventBridgeAwsRegionEnum = "us-gov-east-1"
	EventStreamEventBridgeAwsRegionEnumUsGovWest1   EventStreamEventBridgeAwsRegionEnum = "us-gov-west-1"
	EventStreamEventBridgeAwsRegionEnumUsEast1      EventStreamEventBridgeAwsRegionEnum = "us-east-1"
	EventStreamEventBridgeAwsRegionEnumUsEast2      EventStreamEventBridgeAwsRegionEnum = "us-east-2"
	EventStreamEventBridgeAwsRegionEnumUsWest1      EventStreamEventBridgeAwsRegionEnum = "us-west-1"
	EventStreamEventBridgeAwsRegionEnumUsWest2      EventStreamEventBridgeAwsRegionEnum = "us-west-2"
)

func NewEventStreamEventBridgeAwsRegionEnumFromString(s string) (EventStreamEventBridgeAwsRegionEnum, error) {
	switch s {
	case "ap-east-1":
		return EventStreamEventBridgeAwsRegionEnumApEast1, nil
	case "ap-northeast-1":
		return EventStreamEventBridgeAwsRegionEnumApNortheast1, nil
	case "ap-northeast-2":
		return EventStreamEventBridgeAwsRegionEnumApNortheast2, nil
	case "ap-northeast-3":
		return EventStreamEventBridgeAwsRegionEnumApNortheast3, nil
	case "ap-south-1":
		return EventStreamEventBridgeAwsRegionEnumApSouth1, nil
	case "ap-southeast-1":
		return EventStreamEventBridgeAwsRegionEnumApSoutheast1, nil
	case "ap-southeast-2":
		return EventStreamEventBridgeAwsRegionEnumApSoutheast2, nil
	case "ca-central-1":
		return EventStreamEventBridgeAwsRegionEnumCaCentral1, nil
	case "cn-north-1":
		return EventStreamEventBridgeAwsRegionEnumCnNorth1, nil
	case "cn-northwest-1":
		return EventStreamEventBridgeAwsRegionEnumCnNorthwest1, nil
	case "eu-central-1":
		return EventStreamEventBridgeAwsRegionEnumEuCentral1, nil
	case "eu-north-1":
		return EventStreamEventBridgeAwsRegionEnumEuNorth1, nil
	case "eu-west-1":
		return EventStreamEventBridgeAwsRegionEnumEuWest1, nil
	case "eu-west-2":
		return EventStreamEventBridgeAwsRegionEnumEuWest2, nil
	case "eu-west-3":
		return EventStreamEventBridgeAwsRegionEnumEuWest3, nil
	case "me-south-1":
		return EventStreamEventBridgeAwsRegionEnumMeSouth1, nil
	case "sa-east-1":
		return EventStreamEventBridgeAwsRegionEnumSaEast1, nil
	case "us-gov-east-1":
		return EventStreamEventBridgeAwsRegionEnumUsGovEast1, nil
	case "us-gov-west-1":
		return EventStreamEventBridgeAwsRegionEnumUsGovWest1, nil
	case "us-east-1":
		return EventStreamEventBridgeAwsRegionEnumUsEast1, nil
	case "us-east-2":
		return EventStreamEventBridgeAwsRegionEnumUsEast2, nil
	case "us-west-1":
		return EventStreamEventBridgeAwsRegionEnumUsWest1, nil
	case "us-west-2":
		return EventStreamEventBridgeAwsRegionEnumUsWest2, nil
	}
	var t EventStreamEventBridgeAwsRegionEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventStreamEventBridgeAwsRegionEnum) Ptr() *EventStreamEventBridgeAwsRegionEnum {
	return &e
}

// Configuration specific to an eventbridge destination.
type EventStreamEventBridgeConfiguration struct {
	// AWS Account ID for EventBridge destination.
	AwsAccountID string                              `json:"aws_account_id" url:"aws_account_id"`
	AwsRegion    EventStreamEventBridgeAwsRegionEnum `json:"aws_region" url:"aws_region"`
	// AWS Partner Event Source for EventBridge destination.
	AwsPartnerEventSource *string `json:"aws_partner_event_source,omitempty" url:"aws_partner_event_source,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamEventBridgeConfiguration) GetAwsAccountID() string {
	if e == nil {
		return ""
	}
	return e.AwsAccountID
}

func (e *EventStreamEventBridgeConfiguration) GetAwsRegion() EventStreamEventBridgeAwsRegionEnum {
	if e == nil {
		return ""
	}
	return e.AwsRegion
}

func (e *EventStreamEventBridgeConfiguration) GetAwsPartnerEventSource() *string {
	if e == nil {
		return nil
	}
	return e.AwsPartnerEventSource
}

func (e *EventStreamEventBridgeConfiguration) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamEventBridgeConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamEventBridgeConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamEventBridgeConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamEventBridgeConfiguration) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamEventBridgeDestination struct {
	Type          EventStreamEventBridgeDestinationTypeEnum `json:"type" url:"type"`
	Configuration *EventStreamEventBridgeConfiguration      `json:"configuration" url:"configuration"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamEventBridgeDestination) GetConfiguration() *EventStreamEventBridgeConfiguration {
	if e == nil {
		return nil
	}
	return e.Configuration
}

func (e *EventStreamEventBridgeDestination) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamEventBridgeDestination) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamEventBridgeDestination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamEventBridgeDestination(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamEventBridgeDestination) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamEventBridgeDestinationTypeEnum = string

type EventStreamEventBridgeResponseContent struct {
	// Unique identifier for the event stream.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Name of the event stream.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// List of event types subscribed to in this stream.
	Subscriptions []*EventStreamSubscription         `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	Destination   *EventStreamEventBridgeDestination `json:"destination,omitempty" url:"destination,omitempty"`
	Status        *EventStreamStatusEnum             `json:"status,omitempty" url:"status,omitempty"`
	// Timestamp when the event stream was created.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Timestamp when the event stream was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamEventBridgeResponseContent) GetID() *string {
	if e == nil {
		return nil
	}
	return e.ID
}

func (e *EventStreamEventBridgeResponseContent) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EventStreamEventBridgeResponseContent) GetSubscriptions() []*EventStreamSubscription {
	if e == nil {
		return nil
	}
	return e.Subscriptions
}

func (e *EventStreamEventBridgeResponseContent) GetDestination() *EventStreamEventBridgeDestination {
	if e == nil {
		return nil
	}
	return e.Destination
}

func (e *EventStreamEventBridgeResponseContent) GetStatus() *EventStreamStatusEnum {
	if e == nil {
		return nil
	}
	return e.Status
}

func (e *EventStreamEventBridgeResponseContent) GetCreatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedAt
}

func (e *EventStreamEventBridgeResponseContent) GetUpdatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.UpdatedAt
}

func (e *EventStreamEventBridgeResponseContent) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamEventBridgeResponseContent) UnmarshalJSON(data []byte) error {
	type embed EventStreamEventBridgeResponseContent
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventStreamEventBridgeResponseContent(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	e.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamEventBridgeResponseContent) MarshalJSON() ([]byte, error) {
	type embed EventStreamEventBridgeResponseContent
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewOptionalDateTime(e.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EventStreamEventBridgeResponseContent) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamMetric struct {
	// Name of the metric.
	Name string `json:"name" url:"name"`
	// Total count for the entire window.
	WindowTotal float64 `json:"window_total" url:"window_total"`
	// Type of metric.
	Type string `json:"type" url:"type"`
	// Array of metric values for each bucket.
	Data []float64 `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamMetric) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EventStreamMetric) GetWindowTotal() float64 {
	if e == nil {
		return 0
	}
	return e.WindowTotal
}

func (e *EventStreamMetric) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EventStreamMetric) GetData() []float64 {
	if e == nil {
		return nil
	}
	return e.Data
}

func (e *EventStreamMetric) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamMetric) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamMetric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamMetric(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamMetric) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamResponseContent struct {
	EventStreamWebhookResponseContent     *EventStreamWebhookResponseContent
	EventStreamEventBridgeResponseContent *EventStreamEventBridgeResponseContent
	EventStreamActionResponseContent      *EventStreamActionResponseContent

	typ string
}

func (e *EventStreamResponseContent) GetEventStreamWebhookResponseContent() *EventStreamWebhookResponseContent {
	if e == nil {
		return nil
	}
	return e.EventStreamWebhookResponseContent
}

func (e *EventStreamResponseContent) GetEventStreamEventBridgeResponseContent() *EventStreamEventBridgeResponseContent {
	if e == nil {
		return nil
	}
	return e.EventStreamEventBridgeResponseContent
}

func (e *EventStreamResponseContent) GetEventStreamActionResponseContent() *EventStreamActionResponseContent {
	if e == nil {
		return nil
	}
	return e.EventStreamActionResponseContent
}

func (e *EventStreamResponseContent) UnmarshalJSON(data []byte) error {
	valueEventStreamWebhookResponseContent := new(EventStreamWebhookResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamWebhookResponseContent); err == nil {
		e.typ = "EventStreamWebhookResponseContent"
		e.EventStreamWebhookResponseContent = valueEventStreamWebhookResponseContent
		return nil
	}
	valueEventStreamEventBridgeResponseContent := new(EventStreamEventBridgeResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamEventBridgeResponseContent); err == nil {
		e.typ = "EventStreamEventBridgeResponseContent"
		e.EventStreamEventBridgeResponseContent = valueEventStreamEventBridgeResponseContent
		return nil
	}
	valueEventStreamActionResponseContent := new(EventStreamActionResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamActionResponseContent); err == nil {
		e.typ = "EventStreamActionResponseContent"
		e.EventStreamActionResponseContent = valueEventStreamActionResponseContent
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventStreamResponseContent) MarshalJSON() ([]byte, error) {
	if e.typ == "EventStreamWebhookResponseContent" || e.EventStreamWebhookResponseContent != nil {
		return json.Marshal(e.EventStreamWebhookResponseContent)
	}
	if e.typ == "EventStreamEventBridgeResponseContent" || e.EventStreamEventBridgeResponseContent != nil {
		return json.Marshal(e.EventStreamEventBridgeResponseContent)
	}
	if e.typ == "EventStreamActionResponseContent" || e.EventStreamActionResponseContent != nil {
		return json.Marshal(e.EventStreamActionResponseContent)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EventStreamResponseContentVisitor interface {
	VisitEventStreamWebhookResponseContent(*EventStreamWebhookResponseContent) error
	VisitEventStreamEventBridgeResponseContent(*EventStreamEventBridgeResponseContent) error
	VisitEventStreamActionResponseContent(*EventStreamActionResponseContent) error
}

func (e *EventStreamResponseContent) Accept(visitor EventStreamResponseContentVisitor) error {
	if e.typ == "EventStreamWebhookResponseContent" || e.EventStreamWebhookResponseContent != nil {
		return visitor.VisitEventStreamWebhookResponseContent(e.EventStreamWebhookResponseContent)
	}
	if e.typ == "EventStreamEventBridgeResponseContent" || e.EventStreamEventBridgeResponseContent != nil {
		return visitor.VisitEventStreamEventBridgeResponseContent(e.EventStreamEventBridgeResponseContent)
	}
	if e.typ == "EventStreamActionResponseContent" || e.EventStreamActionResponseContent != nil {
		return visitor.VisitEventStreamActionResponseContent(e.EventStreamActionResponseContent)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// Indicates whether the event stream is actively forwarding events.
type EventStreamStatusEnum string

const (
	EventStreamStatusEnumEnabled  EventStreamStatusEnum = "enabled"
	EventStreamStatusEnumDisabled EventStreamStatusEnum = "disabled"
)

func NewEventStreamStatusEnumFromString(s string) (EventStreamStatusEnum, error) {
	switch s {
	case "enabled":
		return EventStreamStatusEnumEnabled, nil
	case "disabled":
		return EventStreamStatusEnumDisabled, nil
	}
	var t EventStreamStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventStreamStatusEnum) Ptr() *EventStreamStatusEnum {
	return &e
}

// Event types
type EventStreamSubscription struct {
	EventType *string `json:"event_type,omitempty" url:"event_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamSubscription) GetEventType() *string {
	if e == nil {
		return nil
	}
	return e.EventType
}

func (e *EventStreamSubscription) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamSubscription) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamSubscription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamSubscription(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamSubscription) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The type of event this test event represents.
type EventStreamTestEventTypeEnum string

const (
	EventStreamTestEventTypeEnumUserCreated                    EventStreamTestEventTypeEnum = "user.created"
	EventStreamTestEventTypeEnumUserDeleted                    EventStreamTestEventTypeEnum = "user.deleted"
	EventStreamTestEventTypeEnumUserUpdated                    EventStreamTestEventTypeEnum = "user.updated"
	EventStreamTestEventTypeEnumOrganizationCreated            EventStreamTestEventTypeEnum = "organization.created"
	EventStreamTestEventTypeEnumOrganizationUpdated            EventStreamTestEventTypeEnum = "organization.updated"
	EventStreamTestEventTypeEnumOrganizationDeleted            EventStreamTestEventTypeEnum = "organization.deleted"
	EventStreamTestEventTypeEnumOrganizationMemberAdded        EventStreamTestEventTypeEnum = "organization.member.added"
	EventStreamTestEventTypeEnumOrganizationMemberDeleted      EventStreamTestEventTypeEnum = "organization.member.deleted"
	EventStreamTestEventTypeEnumOrganizationMemberRoleAssigned EventStreamTestEventTypeEnum = "organization.member.role.assigned"
	EventStreamTestEventTypeEnumOrganizationMemberRoleDeleted  EventStreamTestEventTypeEnum = "organization.member.role.deleted"
	EventStreamTestEventTypeEnumOrganizationConnectionAdded    EventStreamTestEventTypeEnum = "organization.connection.added"
	EventStreamTestEventTypeEnumOrganizationConnectionUpdated  EventStreamTestEventTypeEnum = "organization.connection.updated"
	EventStreamTestEventTypeEnumOrganizationConnectionRemoved  EventStreamTestEventTypeEnum = "organization.connection.removed"
)

func NewEventStreamTestEventTypeEnumFromString(s string) (EventStreamTestEventTypeEnum, error) {
	switch s {
	case "user.created":
		return EventStreamTestEventTypeEnumUserCreated, nil
	case "user.deleted":
		return EventStreamTestEventTypeEnumUserDeleted, nil
	case "user.updated":
		return EventStreamTestEventTypeEnumUserUpdated, nil
	case "organization.created":
		return EventStreamTestEventTypeEnumOrganizationCreated, nil
	case "organization.updated":
		return EventStreamTestEventTypeEnumOrganizationUpdated, nil
	case "organization.deleted":
		return EventStreamTestEventTypeEnumOrganizationDeleted, nil
	case "organization.member.added":
		return EventStreamTestEventTypeEnumOrganizationMemberAdded, nil
	case "organization.member.deleted":
		return EventStreamTestEventTypeEnumOrganizationMemberDeleted, nil
	case "organization.member.role.assigned":
		return EventStreamTestEventTypeEnumOrganizationMemberRoleAssigned, nil
	case "organization.member.role.deleted":
		return EventStreamTestEventTypeEnumOrganizationMemberRoleDeleted, nil
	case "organization.connection.added":
		return EventStreamTestEventTypeEnumOrganizationConnectionAdded, nil
	case "organization.connection.updated":
		return EventStreamTestEventTypeEnumOrganizationConnectionUpdated, nil
	case "organization.connection.removed":
		return EventStreamTestEventTypeEnumOrganizationConnectionRemoved, nil
	}
	var t EventStreamTestEventTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventStreamTestEventTypeEnum) Ptr() *EventStreamTestEventTypeEnum {
	return &e
}

type EventStreamWebhookAuthorizationResponse struct {
	EventStreamWebhookBasicAuth  *EventStreamWebhookBasicAuth
	EventStreamWebhookBearerAuth *EventStreamWebhookBearerAuth

	typ string
}

func (e *EventStreamWebhookAuthorizationResponse) GetEventStreamWebhookBasicAuth() *EventStreamWebhookBasicAuth {
	if e == nil {
		return nil
	}
	return e.EventStreamWebhookBasicAuth
}

func (e *EventStreamWebhookAuthorizationResponse) GetEventStreamWebhookBearerAuth() *EventStreamWebhookBearerAuth {
	if e == nil {
		return nil
	}
	return e.EventStreamWebhookBearerAuth
}

func (e *EventStreamWebhookAuthorizationResponse) UnmarshalJSON(data []byte) error {
	valueEventStreamWebhookBasicAuth := new(EventStreamWebhookBasicAuth)
	if err := json.Unmarshal(data, &valueEventStreamWebhookBasicAuth); err == nil {
		e.typ = "EventStreamWebhookBasicAuth"
		e.EventStreamWebhookBasicAuth = valueEventStreamWebhookBasicAuth
		return nil
	}
	valueEventStreamWebhookBearerAuth := new(EventStreamWebhookBearerAuth)
	if err := json.Unmarshal(data, &valueEventStreamWebhookBearerAuth); err == nil {
		e.typ = "EventStreamWebhookBearerAuth"
		e.EventStreamWebhookBearerAuth = valueEventStreamWebhookBearerAuth
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventStreamWebhookAuthorizationResponse) MarshalJSON() ([]byte, error) {
	if e.typ == "EventStreamWebhookBasicAuth" || e.EventStreamWebhookBasicAuth != nil {
		return json.Marshal(e.EventStreamWebhookBasicAuth)
	}
	if e.typ == "EventStreamWebhookBearerAuth" || e.EventStreamWebhookBearerAuth != nil {
		return json.Marshal(e.EventStreamWebhookBearerAuth)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EventStreamWebhookAuthorizationResponseVisitor interface {
	VisitEventStreamWebhookBasicAuth(*EventStreamWebhookBasicAuth) error
	VisitEventStreamWebhookBearerAuth(*EventStreamWebhookBearerAuth) error
}

func (e *EventStreamWebhookAuthorizationResponse) Accept(visitor EventStreamWebhookAuthorizationResponseVisitor) error {
	if e.typ == "EventStreamWebhookBasicAuth" || e.EventStreamWebhookBasicAuth != nil {
		return visitor.VisitEventStreamWebhookBasicAuth(e.EventStreamWebhookBasicAuth)
	}
	if e.typ == "EventStreamWebhookBearerAuth" || e.EventStreamWebhookBearerAuth != nil {
		return visitor.VisitEventStreamWebhookBearerAuth(e.EventStreamWebhookBearerAuth)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// Basic Authorization for HTTP requests (e.g., 'Basic credentials').
type EventStreamWebhookBasicAuth struct {
	Method EventStreamWebhookBasicAuthMethodEnum `json:"method" url:"method"`
	// Username
	Username string `json:"username" url:"username"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamWebhookBasicAuth) GetUsername() string {
	if e == nil {
		return ""
	}
	return e.Username
}

func (e *EventStreamWebhookBasicAuth) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamWebhookBasicAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamWebhookBasicAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamWebhookBasicAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamWebhookBasicAuth) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Type of authorization.
type EventStreamWebhookBasicAuthMethodEnum = string

// Bearer Authorization for HTTP requests (e.g., 'Bearer token').
type EventStreamWebhookBearerAuth struct {
	Method EventStreamWebhookBearerAuthMethodEnum `json:"method" url:"method"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamWebhookBearerAuth) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamWebhookBearerAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamWebhookBearerAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamWebhookBearerAuth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamWebhookBearerAuth) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Type of authorization.
type EventStreamWebhookBearerAuthMethodEnum = string

// Configuration specific to a webhook destination.
type EventStreamWebhookConfiguration struct {
	// Target HTTP endpoint URL.
	WebhookEndpoint      string                                   `json:"webhook_endpoint" url:"webhook_endpoint"`
	WebhookAuthorization *EventStreamWebhookAuthorizationResponse `json:"webhook_authorization" url:"webhook_authorization"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamWebhookConfiguration) GetWebhookEndpoint() string {
	if e == nil {
		return ""
	}
	return e.WebhookEndpoint
}

func (e *EventStreamWebhookConfiguration) GetWebhookAuthorization() *EventStreamWebhookAuthorizationResponse {
	if e == nil {
		return nil
	}
	return e.WebhookAuthorization
}

func (e *EventStreamWebhookConfiguration) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamWebhookConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamWebhookConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamWebhookConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamWebhookConfiguration) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamWebhookDestination struct {
	Type          EventStreamWebhookDestinationTypeEnum `json:"type" url:"type"`
	Configuration *EventStreamWebhookConfiguration      `json:"configuration" url:"configuration"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamWebhookDestination) GetConfiguration() *EventStreamWebhookConfiguration {
	if e == nil {
		return nil
	}
	return e.Configuration
}

func (e *EventStreamWebhookDestination) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamWebhookDestination) UnmarshalJSON(data []byte) error {
	type unmarshaler EventStreamWebhookDestination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventStreamWebhookDestination(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamWebhookDestination) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamWebhookDestinationTypeEnum = string

type EventStreamWebhookResponseContent struct {
	// Unique identifier for the event stream.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Name of the event stream.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// List of event types subscribed to in this stream.
	Subscriptions []*EventStreamSubscription     `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	Destination   *EventStreamWebhookDestination `json:"destination,omitempty" url:"destination,omitempty"`
	Status        *EventStreamStatusEnum         `json:"status,omitempty" url:"status,omitempty"`
	// Timestamp when the event stream was created.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Timestamp when the event stream was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamWebhookResponseContent) GetID() *string {
	if e == nil {
		return nil
	}
	return e.ID
}

func (e *EventStreamWebhookResponseContent) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EventStreamWebhookResponseContent) GetSubscriptions() []*EventStreamSubscription {
	if e == nil {
		return nil
	}
	return e.Subscriptions
}

func (e *EventStreamWebhookResponseContent) GetDestination() *EventStreamWebhookDestination {
	if e == nil {
		return nil
	}
	return e.Destination
}

func (e *EventStreamWebhookResponseContent) GetStatus() *EventStreamStatusEnum {
	if e == nil {
		return nil
	}
	return e.Status
}

func (e *EventStreamWebhookResponseContent) GetCreatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedAt
}

func (e *EventStreamWebhookResponseContent) GetUpdatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.UpdatedAt
}

func (e *EventStreamWebhookResponseContent) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamWebhookResponseContent) UnmarshalJSON(data []byte) error {
	type embed EventStreamWebhookResponseContent
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventStreamWebhookResponseContent(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	e.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamWebhookResponseContent) MarshalJSON() ([]byte, error) {
	type embed EventStreamWebhookResponseContent
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewOptionalDateTime(e.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EventStreamWebhookResponseContent) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventStreamWindow struct {
	// Start date of the time window.
	DateFrom time.Time `json:"date_from" url:"date_from"`
	// End date of the time window.
	DateTo         time.Time                  `json:"date_to" url:"date_to"`
	BucketInterval *EventStreamBucketInterval `json:"bucket_interval" url:"bucket_interval"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventStreamWindow) GetDateFrom() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.DateFrom
}

func (e *EventStreamWindow) GetDateTo() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.DateTo
}

func (e *EventStreamWindow) GetBucketInterval() *EventStreamBucketInterval {
	if e == nil {
		return nil
	}
	return e.BucketInterval
}

func (e *EventStreamWindow) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventStreamWindow) UnmarshalJSON(data []byte) error {
	type embed EventStreamWindow
	var unmarshaler = struct {
		embed
		DateFrom *internal.DateTime `json:"date_from"`
		DateTo   *internal.DateTime `json:"date_to"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventStreamWindow(unmarshaler.embed)
	e.DateFrom = unmarshaler.DateFrom.Time()
	e.DateTo = unmarshaler.DateTo.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventStreamWindow) MarshalJSON() ([]byte, error) {
	type embed EventStreamWindow
	var marshaler = struct {
		embed
		DateFrom *internal.DateTime `json:"date_from"`
		DateTo   *internal.DateTime `json:"date_to"`
	}{
		embed:    embed(*e),
		DateFrom: internal.NewDateTime(e.DateFrom),
		DateTo:   internal.NewDateTime(e.DateTo),
	}
	return json.Marshal(marshaler)
}

func (e *EventStreamWindow) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type GetEventStreamResponseContent struct {
	EventStreamWebhookResponseContent     *EventStreamWebhookResponseContent
	EventStreamEventBridgeResponseContent *EventStreamEventBridgeResponseContent
	EventStreamActionResponseContent      *EventStreamActionResponseContent

	typ string
}

func (g *GetEventStreamResponseContent) GetEventStreamWebhookResponseContent() *EventStreamWebhookResponseContent {
	if g == nil {
		return nil
	}
	return g.EventStreamWebhookResponseContent
}

func (g *GetEventStreamResponseContent) GetEventStreamEventBridgeResponseContent() *EventStreamEventBridgeResponseContent {
	if g == nil {
		return nil
	}
	return g.EventStreamEventBridgeResponseContent
}

func (g *GetEventStreamResponseContent) GetEventStreamActionResponseContent() *EventStreamActionResponseContent {
	if g == nil {
		return nil
	}
	return g.EventStreamActionResponseContent
}

func (g *GetEventStreamResponseContent) UnmarshalJSON(data []byte) error {
	valueEventStreamWebhookResponseContent := new(EventStreamWebhookResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamWebhookResponseContent); err == nil {
		g.typ = "EventStreamWebhookResponseContent"
		g.EventStreamWebhookResponseContent = valueEventStreamWebhookResponseContent
		return nil
	}
	valueEventStreamEventBridgeResponseContent := new(EventStreamEventBridgeResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamEventBridgeResponseContent); err == nil {
		g.typ = "EventStreamEventBridgeResponseContent"
		g.EventStreamEventBridgeResponseContent = valueEventStreamEventBridgeResponseContent
		return nil
	}
	valueEventStreamActionResponseContent := new(EventStreamActionResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamActionResponseContent); err == nil {
		g.typ = "EventStreamActionResponseContent"
		g.EventStreamActionResponseContent = valueEventStreamActionResponseContent
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetEventStreamResponseContent) MarshalJSON() ([]byte, error) {
	if g.typ == "EventStreamWebhookResponseContent" || g.EventStreamWebhookResponseContent != nil {
		return json.Marshal(g.EventStreamWebhookResponseContent)
	}
	if g.typ == "EventStreamEventBridgeResponseContent" || g.EventStreamEventBridgeResponseContent != nil {
		return json.Marshal(g.EventStreamEventBridgeResponseContent)
	}
	if g.typ == "EventStreamActionResponseContent" || g.EventStreamActionResponseContent != nil {
		return json.Marshal(g.EventStreamActionResponseContent)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GetEventStreamResponseContentVisitor interface {
	VisitEventStreamWebhookResponseContent(*EventStreamWebhookResponseContent) error
	VisitEventStreamEventBridgeResponseContent(*EventStreamEventBridgeResponseContent) error
	VisitEventStreamActionResponseContent(*EventStreamActionResponseContent) error
}

func (g *GetEventStreamResponseContent) Accept(visitor GetEventStreamResponseContentVisitor) error {
	if g.typ == "EventStreamWebhookResponseContent" || g.EventStreamWebhookResponseContent != nil {
		return visitor.VisitEventStreamWebhookResponseContent(g.EventStreamWebhookResponseContent)
	}
	if g.typ == "EventStreamEventBridgeResponseContent" || g.EventStreamEventBridgeResponseContent != nil {
		return visitor.VisitEventStreamEventBridgeResponseContent(g.EventStreamEventBridgeResponseContent)
	}
	if g.typ == "EventStreamActionResponseContent" || g.EventStreamActionResponseContent != nil {
		return visitor.VisitEventStreamActionResponseContent(g.EventStreamActionResponseContent)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GetEventStreamStatsResponseContent struct {
	// Unique identifier for the event stream.
	ID string `json:"id" url:"id"`
	// Name of the event stream.
	Name   string             `json:"name" url:"name"`
	Window *EventStreamWindow `json:"window" url:"window"`
	// Array of timestamp strings representing bucket boundaries.
	Buckets []time.Time `json:"buckets" url:"buckets"`
	// Array of metrics for the event stream.
	Metrics []*EventStreamMetric `json:"metrics" url:"metrics"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetEventStreamStatsResponseContent) GetID() string {
	if g == nil {
		return ""
	}
	return g.ID
}

func (g *GetEventStreamStatsResponseContent) GetName() string {
	if g == nil {
		return ""
	}
	return g.Name
}

func (g *GetEventStreamStatsResponseContent) GetWindow() *EventStreamWindow {
	if g == nil {
		return nil
	}
	return g.Window
}

func (g *GetEventStreamStatsResponseContent) GetBuckets() []time.Time {
	if g == nil {
		return nil
	}
	return g.Buckets
}

func (g *GetEventStreamStatsResponseContent) GetMetrics() []*EventStreamMetric {
	if g == nil {
		return nil
	}
	return g.Metrics
}

func (g *GetEventStreamStatsResponseContent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEventStreamStatsResponseContent) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEventStreamStatsResponseContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEventStreamStatsResponseContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetEventStreamStatsResponseContent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The raw payload of the test event.
type TestEventDataContent = map[string]interface{}

type UpdateEventStreamResponseContent struct {
	EventStreamWebhookResponseContent     *EventStreamWebhookResponseContent
	EventStreamEventBridgeResponseContent *EventStreamEventBridgeResponseContent
	EventStreamActionResponseContent      *EventStreamActionResponseContent

	typ string
}

func (u *UpdateEventStreamResponseContent) GetEventStreamWebhookResponseContent() *EventStreamWebhookResponseContent {
	if u == nil {
		return nil
	}
	return u.EventStreamWebhookResponseContent
}

func (u *UpdateEventStreamResponseContent) GetEventStreamEventBridgeResponseContent() *EventStreamEventBridgeResponseContent {
	if u == nil {
		return nil
	}
	return u.EventStreamEventBridgeResponseContent
}

func (u *UpdateEventStreamResponseContent) GetEventStreamActionResponseContent() *EventStreamActionResponseContent {
	if u == nil {
		return nil
	}
	return u.EventStreamActionResponseContent
}

func (u *UpdateEventStreamResponseContent) UnmarshalJSON(data []byte) error {
	valueEventStreamWebhookResponseContent := new(EventStreamWebhookResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamWebhookResponseContent); err == nil {
		u.typ = "EventStreamWebhookResponseContent"
		u.EventStreamWebhookResponseContent = valueEventStreamWebhookResponseContent
		return nil
	}
	valueEventStreamEventBridgeResponseContent := new(EventStreamEventBridgeResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamEventBridgeResponseContent); err == nil {
		u.typ = "EventStreamEventBridgeResponseContent"
		u.EventStreamEventBridgeResponseContent = valueEventStreamEventBridgeResponseContent
		return nil
	}
	valueEventStreamActionResponseContent := new(EventStreamActionResponseContent)
	if err := json.Unmarshal(data, &valueEventStreamActionResponseContent); err == nil {
		u.typ = "EventStreamActionResponseContent"
		u.EventStreamActionResponseContent = valueEventStreamActionResponseContent
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateEventStreamResponseContent) MarshalJSON() ([]byte, error) {
	if u.typ == "EventStreamWebhookResponseContent" || u.EventStreamWebhookResponseContent != nil {
		return json.Marshal(u.EventStreamWebhookResponseContent)
	}
	if u.typ == "EventStreamEventBridgeResponseContent" || u.EventStreamEventBridgeResponseContent != nil {
		return json.Marshal(u.EventStreamEventBridgeResponseContent)
	}
	if u.typ == "EventStreamActionResponseContent" || u.EventStreamActionResponseContent != nil {
		return json.Marshal(u.EventStreamActionResponseContent)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateEventStreamResponseContentVisitor interface {
	VisitEventStreamWebhookResponseContent(*EventStreamWebhookResponseContent) error
	VisitEventStreamEventBridgeResponseContent(*EventStreamEventBridgeResponseContent) error
	VisitEventStreamActionResponseContent(*EventStreamActionResponseContent) error
}

func (u *UpdateEventStreamResponseContent) Accept(visitor UpdateEventStreamResponseContentVisitor) error {
	if u.typ == "EventStreamWebhookResponseContent" || u.EventStreamWebhookResponseContent != nil {
		return visitor.VisitEventStreamWebhookResponseContent(u.EventStreamWebhookResponseContent)
	}
	if u.typ == "EventStreamEventBridgeResponseContent" || u.EventStreamEventBridgeResponseContent != nil {
		return visitor.VisitEventStreamEventBridgeResponseContent(u.EventStreamEventBridgeResponseContent)
	}
	if u.typ == "EventStreamActionResponseContent" || u.EventStreamActionResponseContent != nil {
		return visitor.VisitEventStreamActionResponseContent(u.EventStreamActionResponseContent)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type EventStreamsCreateRequest struct {
	CreateEventStreamWebHookRequestContent     *CreateEventStreamWebHookRequestContent
	CreateEventStreamEventBridgeRequestContent *CreateEventStreamEventBridgeRequestContent
	CreateEventStreamActionRequestContent      *CreateEventStreamActionRequestContent

	typ string
}

func (e *EventStreamsCreateRequest) GetCreateEventStreamWebHookRequestContent() *CreateEventStreamWebHookRequestContent {
	if e == nil {
		return nil
	}
	return e.CreateEventStreamWebHookRequestContent
}

func (e *EventStreamsCreateRequest) GetCreateEventStreamEventBridgeRequestContent() *CreateEventStreamEventBridgeRequestContent {
	if e == nil {
		return nil
	}
	return e.CreateEventStreamEventBridgeRequestContent
}

func (e *EventStreamsCreateRequest) GetCreateEventStreamActionRequestContent() *CreateEventStreamActionRequestContent {
	if e == nil {
		return nil
	}
	return e.CreateEventStreamActionRequestContent
}

func (e *EventStreamsCreateRequest) UnmarshalJSON(data []byte) error {
	valueCreateEventStreamWebHookRequestContent := new(CreateEventStreamWebHookRequestContent)
	if err := json.Unmarshal(data, &valueCreateEventStreamWebHookRequestContent); err == nil {
		e.typ = "CreateEventStreamWebHookRequestContent"
		e.CreateEventStreamWebHookRequestContent = valueCreateEventStreamWebHookRequestContent
		return nil
	}
	valueCreateEventStreamEventBridgeRequestContent := new(CreateEventStreamEventBridgeRequestContent)
	if err := json.Unmarshal(data, &valueCreateEventStreamEventBridgeRequestContent); err == nil {
		e.typ = "CreateEventStreamEventBridgeRequestContent"
		e.CreateEventStreamEventBridgeRequestContent = valueCreateEventStreamEventBridgeRequestContent
		return nil
	}
	valueCreateEventStreamActionRequestContent := new(CreateEventStreamActionRequestContent)
	if err := json.Unmarshal(data, &valueCreateEventStreamActionRequestContent); err == nil {
		e.typ = "CreateEventStreamActionRequestContent"
		e.CreateEventStreamActionRequestContent = valueCreateEventStreamActionRequestContent
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventStreamsCreateRequest) MarshalJSON() ([]byte, error) {
	if e.typ == "CreateEventStreamWebHookRequestContent" || e.CreateEventStreamWebHookRequestContent != nil {
		return json.Marshal(e.CreateEventStreamWebHookRequestContent)
	}
	if e.typ == "CreateEventStreamEventBridgeRequestContent" || e.CreateEventStreamEventBridgeRequestContent != nil {
		return json.Marshal(e.CreateEventStreamEventBridgeRequestContent)
	}
	if e.typ == "CreateEventStreamActionRequestContent" || e.CreateEventStreamActionRequestContent != nil {
		return json.Marshal(e.CreateEventStreamActionRequestContent)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EventStreamsCreateRequestVisitor interface {
	VisitCreateEventStreamWebHookRequestContent(*CreateEventStreamWebHookRequestContent) error
	VisitCreateEventStreamEventBridgeRequestContent(*CreateEventStreamEventBridgeRequestContent) error
	VisitCreateEventStreamActionRequestContent(*CreateEventStreamActionRequestContent) error
}

func (e *EventStreamsCreateRequest) Accept(visitor EventStreamsCreateRequestVisitor) error {
	if e.typ == "CreateEventStreamWebHookRequestContent" || e.CreateEventStreamWebHookRequestContent != nil {
		return visitor.VisitCreateEventStreamWebHookRequestContent(e.CreateEventStreamWebHookRequestContent)
	}
	if e.typ == "CreateEventStreamEventBridgeRequestContent" || e.CreateEventStreamEventBridgeRequestContent != nil {
		return visitor.VisitCreateEventStreamEventBridgeRequestContent(e.CreateEventStreamEventBridgeRequestContent)
	}
	if e.typ == "CreateEventStreamActionRequestContent" || e.CreateEventStreamActionRequestContent != nil {
		return visitor.VisitCreateEventStreamActionRequestContent(e.CreateEventStreamActionRequestContent)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type UpdateEventStreamRequestContent struct {
	// Name of the event stream.
	Name *string `json:"name,omitempty" url:"-"`
	// List of event types subscribed to in this stream.
	Subscriptions []*EventStreamSubscription   `json:"subscriptions,omitempty" url:"-"`
	Destination   *EventStreamDestinationPatch `json:"destination,omitempty" url:"-"`
	Status        *EventStreamStatusEnum       `json:"status,omitempty" url:"-"`
}
